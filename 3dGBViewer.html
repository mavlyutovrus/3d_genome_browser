<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>3DBD genome browser</title>
		<link href="css/main.css" rel="stylesheet" type="text/css"/>
        <link href="css/cupertino/jquery-ui-1.10.4.custom.css" rel="stylesheet">
        <!-- <link rel="stylesheet" href="http://code.jquery.com/ui/1.10.3/themes/smoothness/jquery-ui.css"> -->
        <link rel="stylesheet" href="js/messi/messi.min.css" />
        <!-- jquery -->
        <script src="http://code.jquery.com/jquery-1.10.2.js"></script>

        <!-- <script src="http://code.jquery.com/ui/1.10.4/jquery-ui.js"></script> -->
        <script src="js/jquery-ui-1.10.4.custom.min.js"></script>

        <!-- lite version of three.js distrib   -->
        <!--script src="js/min.three.js"></script-->
        <script type="text/javascript" src="js/three.min_new.js"></script>
        <script type="text/javascript" src="js/threeoctree.js"></script>

    	<!-- hacked PointerLockControls.js from "three/examples/js/controls/PointerLockControls.js" -->
		<script src="js/PointerLockControls.js"></script>
    	
        <script type='text/javascript' src='js/messi/messi.min.js'></script>

        <script src="content/TextMessages.js"></script>

        <!--script type="text/javascript" src="https://apis.google.com/js/plusone.js"></script-->

        <script>
              $(function() {
                $( "#tabs" ).tabs({
                    "create": function (event, ui) {
                        document.getElementById("blocker").style.top = String($("ul.ui-tabs-nav").height()+27) + "px";
                    },
                    "activate": function(event, ui) {
                        if (ui.newTab.index() == 1) document.body.style.overflow = "hidden";
                        else if (ui.oldTab.index() == 1) document.body.style.overflow = "auto"
                    }
                });
              });

              $(function() {
                $( "#dialog-message" ).dialog({
                  modal: true,
                  autoOpen: false,
                  width: 400
                });
              });

              $(function() {
                $( "button#moveButton" )
                  .button()
                  .click(function( event ) {
                    var incoords = document.getElementById('incoords').value; if (validate(incoords)) {$('#tabs').tabs('option', 'active', 1); } else { $("#dialog-message").dialog( "open" );}
                  });
              });
            
            $(function() {
                $( "#submitCustomData, #cleanButton" )
                  .button()
                  .click(function( event ) {
                    event.preventDefault;
                  });
              });
            
              
        </script>

		<!-- low-resolution 3d model  -->
		<!--<script src="data.js"></script>-->
        
    </head>
    <body>
        <!-- Share scripts for FB/ Twt-->
        <script>(function(d, s, id) {
          var js, fjs = d.getElementsByTagName(s)[0];
          if (d.getElementById(id)) return;
          js = d.createElement(s); js.id = id;
          js.src = "http://connect.facebook.net/us_US/all.js#xfbml=1";
          fjs.parentNode.insertBefore(js, fjs);
        }(document, 'script', 'facebook-jssdk'));
        </script>
        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');
        </script>

        <div id="dialog-message" title="Wrong format of coordinates" >
            <p>Wrong format of input data. Please enter coordinates in format 'X,Y,Z' to specify your next location in Genome space. Also you can move to the place of particular part of specified chromosome. Format: 'chr#,#,#'. Separator can be any symbol except for numeric one. In case of using 3d model of particular chromosomes you can use only this chromosome.</p>
        </div>
        
        <!-- google analytics -->
        <div id="tabs">
          <ul>
            <li><a id="href_tabs-0" href="#tabs-0">Welcome Page/UI</a></li>
            <li><a id="href_tabs-1" href="#tabs-1">Genome Browser</a></li>
            <li><a id="href_tabs-3" href="#tabs-3">Contact us</a></li>
            <li><a id="href_tabs-4" href="#tabs-4">About</a></li>
          </ul>
          <div id="tabs-0">
              <div>
                  <div id="left">
                    <p>Welcome to 3D Genome Browser page<input type="image" onclick="new Messi('Welcome to amazing world of Biology and Info Technologies!', {title: 'Information', center: true, modal: true, viewport: {top: '5vh', left: '10%'}, titleClass: 'info',  
                                });" src="image/system_question_alt_02.png"/></p>
                    <p><input id = "incoords" type="text" title="The format of data is 'x,y,z' or you can use 'chr# start end'." size="40" style=" width: 80%;" >
                        <p><button id="moveButton" type="button">Explore</button></p>
                    </p>
                  </div>
                <div id="right">
                        <h4>Use your own data<input type="image" onclick="new Messi('3D Genome Browser allows user to use its own data of SNPs. For more information about the this, go to the \'About 3D Genome Browser\' tab.<br> To Download the Converter to adopt your sources to appropriate format - <a href=\'http://cs.mcgill.ca/~abutya/supplementary/3DCustomSNPDataConverter.jar\' target=\'_blank\'>click here</a>', {title: 'Information', center: true, modal: true, viewport: {top: '5vh', left: '10%'}, titleClass: 'info',  
                                });" src="image/system_question_alt_02.png"/></h4> 
                        Please specify a file:<br>
                        <input id = "f" type="file" name="datafile" size="40">
                    </p>
                    <div style="float:left; width: 50%">
                        <button id="submitCustomData" onclick="readFile();">Upload file</button>
                    </div>
                    <div style="float:right; width: 50%">
                        <button id="cleanButton" onclick="customerData = {}; $('button#cleanButton').button('disable'); isCustomerData = false;" disabled>Delete User Data</button>
                    </div>
                    <br>
                    <p id="progressBar" style="display:none; clear: both" ></p>
                </div>
              </div>
          </div>
          <div id="tabs-1">
                <div id="detection-sign" >
                    <img id="exclamation-sign" src="image/exclamation.png" alt="SNP!">
                </div>
                <div id="blocker">
                    <div id="instructions">
                        <span style="font-size:40px">Click to Explore</span><br><br>
                        Supported browsers: Firefox, Google Chrome.
                    </div>
                </div>
          </div>
          <div id="tabs-3">
            <p><em>3DBD Genome browser</em>, contact: <a target='_blank' href='http://exascale.info/'>eXascale Infolab</a>:
                <a style="color: rgb(0,0,255)" href="mailto:phil@exascale.info?subject=[3D Genome Browser]">Philippe Cudre-Mauroux</a>, <a style="color: rgb(0,0,255)" href="mailto:ruslan@exascale.info?subject=[3D Genome Browser]">Ruslan Mavlyutov</a>; <br><br><a target='_blank' href='http://csb.cs.mcgill.ca/'>McGill University SoCS</a>: <a style="color: rgb(0,0,255)" href="mailto:jeromew@cs.mcgill.ca?subject=[3D Genome Browser]">Jérôme Waldispühl</a>, <a style="color: rgb(0,0,255)" href="mailto:alexander.butyaev@mail.mcgill.ca?subject=[3D Genome Browser]">Alexander Butyaev</a>.</p>
            
            <!--Share conteiner -->
            <div>
                <div class="button twitter" data-type="button_count"><a href="https://twitter.com/share" class="twitter-share-button" data-url="http://cs.mcgill.ca/~abutya/3dgenomebrowser/3dGB.html" data-text="I'm working with 3D Genome Browser, developed by[CSB group. McGill University] and [eXascale Infolab. Friburg University]">Tweet</a></div>
                <div class="fb-share-button" data-href="http://cs.mcgill.ca/~abutya/3dgenomebrowser/3dGB.html" data-type="button_count" data-text="I'm working with 3D Genome Browser, developed by[CSB group. McGill University] and [eXascale Infolab. Friburg University]">
                </div>
                <div class="g-plusone" data-size="tall" data-href="http://cs.mcgill.ca/~abutya/3dgenomebrowser/3dGB.html" data-text="I'm working with 3D Genome Browser, developed by[CSB group. McGill University] and [eXascale Infolab. Friburg University]" data-annotation="inline" data-width="300" ></div>
                <!--div class="g-plusone" data-annotation="inline" data-width="300"></div-->
                <!--g:plusone></g:plusone>
                <script type="text/javascript">
                    window.___gcfg = {
                        lang: 'en-US'
                    };
                    (function() {
                        var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
                        po.src = 'https://apis.google.com/js/platform.js';
                        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
                    })();
                </script-->
            <!--/div-->


          </div>
        </div>

        <div id="tabs-4">
            <h1>3D Genome Browser</h1>
            <hr>
            <nav class="toc">
                    <h2>Content:</h2>
                        <ol>
                            <li><a href="#introduction">About the 3D Genome Browser</a></li>
                            <li><a href="#functionality">Browser Functionality</a></li>
                            <li><a href="#memory-management">Memory Management</a></li>
                            <li><a href="#well-known-problems">Well-Known Problems</a></li>
                            <li><a href="#controls">Controls</a></li>
                        </ol>
                </nav>
                <hr>
                <h2 id="introduction">About the 3D Genome Browser</h2>
                <p>
                    Welcome to the 3D Genome Browser. This is the website that provides detailed description of the structure of Human Genome. This web browser is fully interactive 3D viewer that allows user to move through the 3D space of genome model, interact with system with a help of commonly-used input/output devices and retrieve data of genome sequence variations, ChIP-sequencing data etc. The data was collected from <a class = "external-link" href="http://www.1000genomes.org/" target="_blank">1000 Genomes Project</a> and <a class = "external-link" href="http://www.genome.gov/encode/" target="_blank">The ENCODE Project</a>.<br>
                    This browser has been implemented with a help of <i>Javascript technologies</i> and, in particular, <i>Three.js</i> - javascript library that provides an opportunity to work with WebGL-3D objects in web browser.<br>
                    It has been optimized for working with big sets of biological data and built on top of a NoSQL database for comfortable visualization, examination and data querying. In addition, the database contains several components that disitinguish this system among most Genome Browsers:</p>
                    <li>Sparse, adaptive 3D index</li>
                    <li>Immutable data chunks</li>
                <p>
                    Both of these components improve the standard approach to the storing the data. From the user side - it reduces the response time and, therefore, increases user's experience of exploring 3D structure of genome and its elements. 
                    <br>
                    <br>
                    The 3D Genome Browser is developed and maintained by Computational Structure Biology Group at Computer Science Department, McGill University, Canada and eXascale Infolab at the University of Fribourg, Switzerland.
                </p>
                <hr>
                <h2 id="functionality">Browser Functionality</h2>
                <p>The general idea of the 3D Genome Browser is to show the genome sequence in 3 dimensions, provide an opportunity to explore genome both in standard (linear) way and using advantages of space location of chromosomes, genes, their interactions. Another important feature of this system is the way of information representetion. In most cases, user can retrieve information while moving through the space in the bottom panel of the screen, or using special commands to get pop up window for detailed information.
                    <br>
                    This system provides wide variety of tools for exploring genome.<br>
                    In comparison with standard Genome Browsers we deal with 3D coordinates, models and associated with them biological entities. That's why it is important to provide an opportunity to change the current position in space with standard way in format  "chr [number of chromosome] [start position] [end position]", where any non numeric symbol can be separator (for instance, "chr 5: 1234567 - 1234765"); and in 3 dimensional way - format "X Y Z", where X,Y,Z are coordinates of particular point in database (very specific, for instance, "147:2345:924") and any non numeric symbol can be separator as well.<br>
                    <br>
    <!--                here we should write about first page-->
                    Fundamentally there are 3 different modes that allow user interact with system in different ways and/or retrieve special information from database.</p>
                <h3 id="func-linear">Linear mode</h3>
                <p>
                Basically, linear mode in 3D space is the putting old canons of representation in a new light. It easily can be compared with such genome browser as <a class = "external-link" href="http://genome.ucsc.edu/" target="_blank">UCSC Genome Browser</a> and track system, which it uses. User can examine and analyze only one sequence of genome at a time but instead of plane tables 3D Genome Browser uses partition of the screen on 2 parts: 3D models and panels with information that is appeared immediately by pointing to the specific part of the genome. To investigate specific part of genome <i>left click of mouse</i> will call popup window with almost the same information but with opportunity to click on any link and continue investigation on the <a class = "external-link" href="http://www.ncbi.nlm.nih.gov/" target="_blank">National Center for Biotechnology Information web site </a>.
                    <br>
                    Also, system provides an opportunity to change the size of observable area of genome sequence and, therefore, of retrieving data from the server by scrolling the mouse (up to several thousands of nucleotides). 
                    <br>
                    Besides, group of scientist raised an issue whether it is possible to map ChIP-sequencing data (Transcription Factors) and Single Nucleotide Polymorphisms (SNPs). This problem has been solved by aligning the position of SNP in chromosome and particular Transcription Factor. Thus, in this mode the system provides this feature for linear part of chromosome. The user can use it by selecting particular <i>linear</i> part of chromosome and then pressing the key "G". There will be shown popup windom that contains basic information about chromosome, SNP position, SNP identificator (click on it to find more information on The National Center for Biotechnology Information website), transcription factor and its affection level. For scientists' comfort, dynamic filtering system has been integrated. As well <b>filtered</b> data can be easily exported in CSV format by clicking "Export to CSV".
                    <br>
                </p>
                <h3 id="func-cubic">Cubic mode</h3>
            <p>
                Currently, almost all Genome Browsers use linear approach for showing the biggest part of data. That is observable area is only integral and complete part of one genome's chromosome. But investigation of interactions between two not connected areas of genome is still open-ended problem.    
                Cubic mode of 3D Genome Browser provides to user an opportunity to use almost all advantages of 3 dimensions of space. Basic shape for retrieveing of data is resizable cube. Once pointer is on the genome strand, the cube will be automatically built around this point. At the same time scrolling action is available for user to change size of observable area. Data that is available for all parts of strands that are located inside the cube will be shown on the popup window after <i>left click of mouse</i>. It contains information about all parts of all chromosomes that fit in the cube: chromosome with positions and complete list of SNPs (links to NCBI website for deep investigation).
                <br>
                Same as previous mode (<i>Linear Mode</i>) system provides an opportunity to map ChIP-Sequencing data to SNPs that are fit in the range of the particular Transcription Factor. The difference is that in the cubic mode can investigate all strands that are in the cubic area.<br>
                <b>Important:</b> All actions for this mode are available for any strand from the space cube, where user is currently located (see <a href="#memory-management">Memory Management</a> chapter).
            </p>
                <h3 id="func-chipseq">ChIP-Seq mode</h3>
            <p>
                From biological terminology, ChIP-sequencing is basically the method to analyze protein (or Transcription Factor) interactions with DNA. By using this mode user gets an opportunity to visualize all transcription factors that have been found for particular Cell Type and investigate it in details using <a class = "external-link" href="https://genome.ucsc.edu/" target="_blank">UCSC genome browser</a>. To start visualization step user should point to particular strand and left click of mouse. There will be appeared colored parts of genome (from green to red). The color identifies the level of affection from the weakest (green) to the strongest (red) level. In numbers that means: affection level 0 - green, affection level 1000 - red.<br>To call popup window with the general information and link to UCSC Genome Browser user can point to the colored part of genome and left click of mouse.
                <br><b>Important:</b> In case of switching to another mode, all colored segments of genome will be disappeared (see <a href="#memory-management">Memory Management</a> chapter).
            </p>

                <h3 id="func-ownSNPData">Using customer's SNP data</h3>
            <p>
                Originally, in Linear and Cubic modes scientist can retrieve SNP data that initially has been collected from enormous libraries of <a class = "external-link" href="http://www.1000genomes.org/" target="_blank">1000 Genomes Project</a>. It is usefull for research, but it can't help to typical customer to investigate his own mutations even if he has required information from Genome Center. 3D Genome Browser provides an opportunity to securely upload the data to the genome browser and to start comparison SNPs with those that came from the 1000 Genome Project. All calculations (which are connected with customer's snp data) are implemented locally on the user's machine and, thus, data cannot be sent to server and/or distributed in SNP resources.<br>

                After choosing the 3d Model of genome (its cell type), on the first tab user can find <i>Use your own data</i>. To start using this feature user should choose file with SNP Data in specific format. 3D Genome Browser accepts only JSON format with data: 
                    <ol>
                        <li>Number of chromosome ("1", "2" etc) - Once per occurrence;</li>
                        <li>Position of the SNP in current chromosome</li>
                        <li>SNP identificator (for example, "rs12564807")</li>
                        <li>Genotype (for example, "AA")</li>
                    </ol>
                    <br><b>Example of the data:</b> <i>{"1" : [[734462,"rs12564807","AA"], ...], "2" : [[...], [...]], ...}</i><br><br>
                    <i>To simplify converting process, we have implemented simple converter (Java-based application).</i> It can be downloaded <a href='http://cs.mcgill.ca/~abutya/supplementary/3DCustomSNPDataConverter.jar' target='_blank'>here</a>. Detailed description of this can be found <a href='http://cs.mcgill.ca/~abutya/supplementary/converterhelp.html' target='_blank'>here</a>.
                    <br><br>

                Once the data is uploaded in system, you have an opportutinity to compare your SNPs with the SNPs that came from server. To do this:
                <ol>
                    <li>Choose <i>Linear mode</i> (for current reliase it works only for linear mode)</li>
                    <li>Try to point to different parts of genome and the same moment observe an exclamation mark to the left from the line that defines your current mode.</li>
                    <li>Left click of mouse and you will find additional column "@Customer Data/Genotype".</li>
                    <li>Using scrolling move to complete line with SNP's identificator, genotype from system and genotype from <i>customer's SNP data</i>. It will be highlighted in either red of green color, depending on match or mismatch of two genotypes.</li>
                </ol>
                <br>
                <b>Important: </b>After finishing the work with <i>cutomer's SNP data</i> to increase the performance of local machine - go to the first "Welcome Page/UI" tab and click "Delete User Data" button (see <a href="#memory-management">Memory Management</a> chapter).

            </p>

            <hr>
            <h2 id="memory-management">Memory Management</h2>
            <p>
                &nbsp;In spite of the fact that this Genome Browser is the website, biggest part of the processing of the data that represents on the user's screen, is on the client machine. Also, the drawing of 3D objects is very memory consuming process. That means the development has been limited by the capabilities of typical computer. To reduce the local machine load, development group introduced the Memory Management Policy.
                <br><br>
                <li>The success of the <a class = "external-link" href="http://web.ornl.gov/sci/techresources/Human_Genome/index.shtml" target="_blank"><b>Human Genome Project</b></a>, first release of draft of human genome and later investigation of Hi-C methodology made possible to create 3D model of full genome. As human genome contains 23 pairs of chromosome and the length of each of them varies in range from 48 to 250 million nucleotides, it is not reasonable to represent all chromosomes at a time: it is not informative and could be ruinous for productivity of local machine. To solve this issue, space has been divided by cubes of fixed size and, thus, user by moving through the space can consequently upload the data from the server.</li>
                <br>
                <li>Another important feature of the policy is the consistent removing of 3D objects from the memory when current distance to the 3D object is getting be greater than one cube. It allows system to balance between memory cosumption and visibility.</li>
                <br>
                <li>As it is mentioned above, to find out 3D objects in specified region <i>Octree</i> approach has been used. Number of nodes in such a tree for specified model in fixed-size cube and resolution can be tremendous. For this reason, user can retrieve data in cubic mode only in the cube, where user currently is located. By moving through the space, crossing the border between cubes the system fully rebuilds an octree. </li>
                <br>
                <li>One of the most important rule of the memory management in this system is to clean ChIP-Seq data when user changes mode from "ChIP-Seq mode". Performance of a local machine fully depends on the number of objects primarily, and, secondly, on the length of the elements.</li>
                <br>
                <li>In 3D Genome Browser user can use own data (see <a href="#func-ownSNPData">Using customer's SNP data</a> chapter), which creates uncontrollable spending of memory by storing (usually 20+ Mb) file there. By using this feature, user is responsible for the performance of his machine. To accelerate machine, after finishing the work with own data open the first tab and click "Delete User Data" button.</li>

            </p>
            <hr>
            <h2 id="well-known-problems">Well Known Problems</h2>
            <p>Currently we defined that 3D Genome Browser supports such web browsers as Google Chrome and FireFox. However, FireFox has its own implementation of Pointer Lock API, which fully depends on FullScreen API. In other words, to use fully 3D Genome Browser in FireFox, firstly make sure that you always in FullScreen mode. Otherwise, it can cause not correct behaviour from the system.
            </p>
            <hr>
            <h2 id="controls">Controls</h2>
            <p>
                <table id = "table_linear">
                  <tr>
                    <th>Mode</th>
                    <th>Key</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td>Linear</td>
                    <td>Left Click</td>
                    <td>Get popup window with basic information about chromosome, selected positions, sequence of DNA, and SNPs</td>
                  </tr>

                  <tr>
                    <td>Cubic</td>
                    <td>Left Click</td>
                    <td>Get popup window with basic information about selected strands, chromosomes, positions and SNPs</td>
                  </tr>

                  <tr>
                    <td>ChIP-Seq</td>
                    <td>Left Click</td>
                    <td><b>For not colored Strand:</b> visualization of ChIP-Seq data<br><b>For colored Strand:</b> get popup window with basic information about the Transcription Factor, its positions and affection level</td>
                  </tr>

                  <tr>
                    <td rowspan="2">Linear and Cubic</td>
                    <td>G</td>
                    <td>Get popup window with mapped ChIP-Seq data and SNPs</td>
                  </tr>
                  <tr>
                    <td>+/- (scroll)</td>
                    <td>Change size of observable area.</td>
                  </tr>

                  <tr>
                    <td rowspan="4">All modes</td>
                    <td>C</td>
                    <td>Change mode in loop from Linear to Cubic, from Cubic to ChIP-Seq and from ChIP-Seq to Linear mode</td>
                  </tr>
                  <tr>
                    <td>Tab</td>
                    <td>Get general information about the mode</td>
                  </tr>
                  <tr>
                    <td>W,S,A,D</td>
                    <td>Move in space Forward, Back, Left, Right respectively</td>
                  </tr>
                  <tr>
                    <td>Mouse</td>
                    <td>Look around</td>
                  </tr>
                </table>
            </p>
            <hr>
            
        </div>

        <script>
            var isChipSeqAvailable = false;
            var isCustomerData = false;
            var customerData;
            var contents;
            var previousLength = 0;
            var isInProgress = true;
            var file;
            var progress_bar_div;
            function readFile() {
                previousLength = 0;
                
                isInProgress = true;
                progress_bar_div = document.getElementById('progressBar');
                progress_bar_div.style.display = '';
                $('p#progressBar').text("I'm still working on this file");
                var reader = new FileReader();
                
                reader.onload = function(event) {
                    contents = event.target.result;
                    isInProgress = false;
                    console.log("Done ");
                };
                
                reader.onerror = function(event) {
                    console.error("File cannot be read " + event.target.error.code);
                    isInProgress = false;
                };

                file = document.getElementById("f").files[0];
                if (typeof file == 'undefined') {
                    $('p#progressBar').text("Error: Select the file");
                    isInProgress = false;
                    return;
                }
                reader.readAsText(file);
                progressBarFunction();
                console.log("Let's write something")
                $('button#cleanButton').button("enable");
                isCustomerData = true;
            }

            function progressBarFunction() {
                console.log(isInProgress + "  " + (typeof contents != 'undefined') + "  "  + file.size + "|now = " + ((typeof contents != 'undefined')?contents.length:""));
                if ((typeof contents === 'undefined')  || ( previousLength == 0 || previousLength != contents.length)) {
                    if ((typeof contents === 'undefined')) previousLength = 0;
                    else previousLength = contents.length;
                    console.log("see this 1");
                    setTimeout(progressBarFunction, 1000);
                    // console.log("see this after setTimeout");
                } else {
                    console.log("See this 2");
                    $('p#progressBar').text("Done");
                    customerData = JSON.parse(contents);
                    contents = '';
                    for (var us in uploaded_splines) {
                        var tempArr = us.split('-');
                        var chridOnlyNum = tempArr[0].replace(/([\d]+).*/,"$1");
                        var arr = AdaptUploadedSpinesForCustomerData(parseInt(tempArr[1]), parseInt(tempArr[2]), chridOnlyNum);
                        uploaded_splines[us][2] = arr[0];
                        uploaded_splines[us][3] = arr[1];
                        uploaded_splines[us][4] = chridOnlyNum;
                    }
                }
            }
        </script>
		<!-- main part -->
        <script>
            var ChangeCameraPositionBoolean = true;
            var globalArrayForWindow;

            var MAX_WAIT_INTERVAL = 10000;
            var waitInterval = 0;
            var resp_count = 0;
            var req_count = 0;
            var tableStrContent = '';
            var healthness;

            var isOneCubeOctree = true;

            var rgn;//made it global for table
            var urlParams;
            (window.onpopstate = function () {
                var match,
                    pl     = /\+/g,  // Regex for replacing addition symbol with a space
                    search = /([^&=]+)=?([^&]*)/g,
                    decode = function (s) { return decodeURIComponent(s.replace(pl, " ")); },
                    query  = window.location.search.substring(1);

                urlParams = {};
                while (match = search.exec(query))
                   urlParams[decode(match[1])] = decode(match[2]);
            })();
            var serviceForStructure, particularChromosome, disease3Dexpression;
            var current_cell_line;
            var zeroCoordinate;
            var scaleFactor; 
        	var blockSize;
            var NODE_THRESHOLD = 625;
            var radiusOfTube = 10;

            var radiusSphere = 40, segmentsWidth = 32, segmentsHeight = 16; //sphere zone parameters
            var maxRadiusSphere = 140, minRadiusSphere = 20;

            switch (urlParams["3dmodel"]){
                case "BCL-1" : 
                { 
                name_of_model = "B-Cell, Leukemia, Chromosome 1";
                current_cell_line = 'B-cell';
                isChipSeqAvailable = false;
                zeroCoordinate={x: 1.5196, y: 4.625, z: 1.75};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=leukemia";
                    disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 0.8;
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;
                    break;
                }
                case "BCL-2" : 
                { 
                 name_of_model = "B-Cell, Leukemia, Chromosome 2";
                current_cell_line = 'B-cell';
                isChipSeqAvailable = false;
                // zeroCoordinate={x: 3, y: 3, z: 3};
                zeroCoordinate={x: 2.607, y: 3.066, z: 2.406};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=leukemia";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    // scaleFactor = 1300; blockSize = 3;
                    scaleFactor = 15000; blockSize = 1;
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;
                    break;
                }
                case "BCL-3" :
                { 
                 name_of_model = "B-Cell, Leukemia, Chromosome 3";
                current_cell_line = 'B-cell';
                isChipSeqAvailable = false;
                zeroCoordinate={x: 3.396, y: 3.129, z: 4.991};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=leukemia";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1;
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;
                    break;
                }
                case "BCL-4" : 
                { 
                 name_of_model = "B-Cell, Leukemia, Chromosome 4";
                current_cell_line = 'B-cell';
                isChipSeqAvailable = false;
                zeroCoordinate={x: 4.637, y: 1.413, z: 2.748};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=leukemia";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1;
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;
                    break;
                }
                case "BCL-5" : 
                { 
                 name_of_model = "B-Cell, Leukemia, Chromosome 5";
                current_cell_line = 'B-cell';
                isChipSeqAvailable = false;
                zeroCoordinate={x: 6.1960, y: 4.679, z: 4.901};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=leukemia";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1;
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;
                    break;
                }
                case "BCL-6" : 
                { 
                 name_of_model = "B-Cell, Leukemia, Chromosome 6";
                current_cell_line = 'B-cell';
                isChipSeqAvailable = false;
                zeroCoordinate={x: 2.6, y: 1, z: 2.3};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=leukemia";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1;
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;
                    break;
                }
                case "BCL-7" : 
                { 
                 name_of_model = "B-Cell, Leukemia, Chromosome 7";
                current_cell_line = 'B-cell';
                isChipSeqAvailable = false;
                zeroCoordinate={x: 2.5224339672252576, y: 2.8265053937650886, z: 2.6624181521072248};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=leukemia";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;
                    break;
                }
                case "BCL-8" : 
                { 
                 name_of_model = "B-Cell, Leukemia, Chromosome 8";
                current_cell_line = 'B-cell';
                isChipSeqAvailable = false;
                zeroCoordinate={x: 3.384638770206183, y: 2.7213556491985345, z: 3.2190198759600035};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=leukemia";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                   scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;
                    break;
                }
                case "BCL-9" : 
                { 
                 name_of_model = "B-Cell, Leukemia, Chromosome 9";
                current_cell_line = 'B-cell';
                isChipSeqAvailable = false;
                zeroCoordinate={x: 1.1286286205784912, y: 2.34872326069342, z: 2.7515753634198};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=leukemia";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;
                    break;
                }
                case "BCL-10" : 
                { 
                 name_of_model = "B-Cell, Leukemia, Chromosome 10";
                current_cell_line = 'B-cell';
                isChipSeqAvailable = false;
                zeroCoordinate={x: 3.7002137110319437, y: 2.803395113630164, z: 2.8327274044350967};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=leukemia";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;
                    break;
                }
                case "BCL-11" : 
                { 
                 name_of_model = "B-Cell, Leukemia, Chromosome 11";
                current_cell_line = 'B-cell';
                isChipSeqAvailable = false;
                zeroCoordinate={x: 2.9175686487197745, y: 3.0422142962947305, z: 2.0713270276646902};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=leukemia";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;
                    break;
                }
                case "BCL-12" : 
                { 
                 name_of_model = "B-Cell, Leukemia, Chromosome 12";
                current_cell_line = 'B-cell';
                isChipSeqAvailable = false;
                zeroCoordinate={x: 4.174361780360315, y: 3.011481034745547, z: 4.752406682114412};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=leukemia";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;
                    break;
                }
                case "BCL-13" : 
                { 
                 name_of_model = "B-Cell, Leukemia, Chromosome 13";
                current_cell_line = 'B-cell';
                isChipSeqAvailable = false;
                zeroCoordinate={x: 3.915946578330066, y: 2.10311133236101, z: 2.2040866952662914};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=leukemia";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;

                    break;
                }
                case "BCL-14" : 
                { 
                 name_of_model = "B-Cell, Leukemia, Chromosome 14";
                current_cell_line = 'B-cell';
                isChipSeqAvailable = false;
                zeroCoordinate={x: 3.816070125510321, y: 2.6803492066361, z: 2.2112362739538534};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=leukemia";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;

                    break;
                }
                case "BCL-15" : 
                { 
                 name_of_model = "B-Cell, Leukemia, Chromosome 15";
                current_cell_line = 'B-cell';
                isChipSeqAvailable = false;
                zeroCoordinate={x: 2.287786912326149, y: 2.289238772912303, z: 2.672768601749768};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=leukemia";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;

                    break;
                }
                case "BCL-16" : 
                { 
                 name_of_model = "B-Cell, Leukemia, Chromosome 16";
                current_cell_line = 'B-cell';
                isChipSeqAvailable = false;
                zeroCoordinate={x: 2.3565839610562507, y: 3.1745956368632826, z: 3.6769545232477876};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=leukemia";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;

                    break;
                }
                case "BCL-17" : 
                { 
                 name_of_model = "B-Cell, Leukemia, Chromosome 17";
                current_cell_line = 'B-cell';
                isChipSeqAvailable = false;
                zeroCoordinate={x: 2.6369316396175915, y: 2.7422466265810446, z: 2.2013006074737618};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=leukemia";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;

                    break;
                }
                case "BCL-18" : 
                { 
                 name_of_model = "B-Cell, Leukemia, Chromosome 18";
                current_cell_line = 'B-cell';
                isChipSeqAvailable = false;
                zeroCoordinate={x: 2.7963916541086737, y: 3.2310423850305496, z: 2.717080901779388};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=leukemia";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;

                    break;
                }
                case "BCL-19" : 
                { 
                 name_of_model = "B-Cell, Leukemia, Chromosome 19";
                current_cell_line = 'B-cell';
                isChipSeqAvailable = false;
                zeroCoordinate={x: 2.422579864207846, y: 3.00588379696229, z: 2.779965908530172};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=leukemia";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;

                    break;
                }
                case "BCL-20" : 
                { 
                 name_of_model = "B-Cell, Leukemia, Chromosome 20";
                current_cell_line = 'B-cell';
                isChipSeqAvailable = false;
                zeroCoordinate={x: 2.714724725538362, y: 2.9557876871210444, z: 2.893564357748228};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=leukemia";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;

                    break;
                }
                case "BCL-21" : 
                { 
                 name_of_model = "B-Cell, Leukemia, Chromosome 21";
                current_cell_line = 'B-cell';
                isChipSeqAvailable = false;
                zeroCoordinate={x: 3.976763264996193, y: 2.975517476333303, z: 2.6491180063221886};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=leukemia";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;

                    break;
                }
                case "BCL-22" : 
                { 
                 name_of_model = "B-Cell, Leukemia, Chromosome 22";
                current_cell_line = 'B-cell';
                isChipSeqAvailable = false;
                zeroCoordinate={x: 2.12026287716053, y: 3.3174266856077033, z: 3.224190734706632};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=leukemia";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;

                    break;
                }
                case "BCL-23" : 
                { 
                 name_of_model = "B-Cell, Leukemia, Chromosome 23";
                current_cell_line = 'B-cell';
                isChipSeqAvailable = false;
                zeroCoordinate={x: 2.2093499344016747, y: 6.19408957037137, z: 3.0928600396076003};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=leukemia";
                disease3Dexpression = healthness + "&chr=X"  + "&";
                    scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;

                    break;
                }
                case "BCH-1" : 
                { 
                 name_of_model = "B-Cell GM06990, Healthy, Chromosome 1";
                current_cell_line = 'GM06990';
                isChipSeqAvailable = true;
                zeroCoordinate={x: 2.028643447604918, y: 2.890738383622912, z: 4.109576482443055};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=normal";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;

                    break;
                }
                case "BCH-2" : 
                { 
                 name_of_model = "B-Cell GM06990, Healthy, Chromosome 2";
                current_cell_line = 'GM06990';
                isChipSeqAvailable = true;
                zeroCoordinate={x: 3.199904037434262, y: 3.5599361421035023, z: 2.016223358671252};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=normal";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;
                    break;
                }
                case "BCH-3" : 
                { 
                 name_of_model = "B-Cell GM06990, Healthy, Chromosome 3";
                current_cell_line = 'GM06990';
                isChipSeqAvailable = true;
                zeroCoordinate={x: 3.6552218202817075, y: 2.8453974944543536, z: 2.4446027459009483};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=normal";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;
                    break;
                }
                case "BCH-4" : 
                { 
                 name_of_model = "B-Cell GM06990, Healthy, Chromosome 4";
                current_cell_line = 'GM06990';
                isChipSeqAvailable = true;
                zeroCoordinate={x: 2.071287723765832, y: 3.0877035224328813, z: 2.78887829509825};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=normal";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;
                    break;
                }
                case "BCH-5" : 
                { 
                 name_of_model = "B-Cell GM06990, Healthy, Chromosome 5";
                current_cell_line = 'GM06990';
                isChipSeqAvailable = true;
                zeroCoordinate={x: 3.6493915149963545, y: 3.2130827648406872, z: 2.5536481253807897};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=normal";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;
                    break;
                }
                case "BCH-6" : 
                { 
                 name_of_model = "B-Cell GM06990, Healthy, Chromosome 6";
                current_cell_line = 'GM06990';
                isChipSeqAvailable = true;
                zeroCoordinate={x: 2.4840182088706366, y: 1.679119369905898, z: 2.8160299181144923};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=normal";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;
                    break;
                }
                case "BCH-7" : 
                { 
                 name_of_model = "B-Cell GM06990, Healthy, Chromosome 7";
                current_cell_line = 'GM06990';
                isChipSeqAvailable = true;
                zeroCoordinate={x: 2.2807329066853628, y: 2.672600303671124, z: 3.7860452041377872};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=normal";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;
                    break;
                }
                case "BCH-8" : 
                { 
                 name_of_model = "B-Cell GM06990, Healthy, Chromosome 8";
                current_cell_line = 'GM06990';
                isChipSeqAvailable = true;
                zeroCoordinate={x: 2.6459739239516518, y: 2.6391411828461817, z: 3.975179853417516};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=normal";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;
                    break;
                }
                case "BCH-9" : 
                { 
                 name_of_model = "B-Cell GM06990, Healthy, Chromosome 9";
                current_cell_line = 'GM06990';
                isChipSeqAvailable = true;
                zeroCoordinate={x: 2.773577392942734, y: 2.5921210446418863, z: 2.2028152115862745};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=normal";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;
                    break;
                }
                case "BCH-10" : 
                { 
                 name_of_model = "B-Cell GM06990, Healthy, Chromosome 10";
                current_cell_line = 'GM06990';
                isChipSeqAvailable = true;
                zeroCoordinate={x: 2.6702232188740513, y: 2.531886396842844, z: 2.8187572029371903};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=normal";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;
                    break;
                }
                case "BCH-11" : 
                { 
                 name_of_model = "B-Cell GM06990, Healthy, Chromosome 11";
                current_cell_line = 'GM06990';
                isChipSeqAvailable = true;
                zeroCoordinate={x: 3.1019471317951934, y: 3.856279271263897, z: 1.6510631427705267};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=normal";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;
                    break;
                }
                case "BCH-12" : 
                { 
                 name_of_model = "B-Cell GM06990, Healthy, Chromosome 12";
                current_cell_line = 'GM06990';
                isChipSeqAvailable = true;
                zeroCoordinate={x: 4.11109074425881, y: 2.7114129501017032, z: 2.2341538540683525};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=normal";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;
                    break;
                }
                case "BCH-13" : 
                { 
                 name_of_model = "B-Cell GM06990, Healthy, Chromosome 13";
                current_cell_line = 'GM06990';
                isChipSeqAvailable = true;
                zeroCoordinate={x: 2.3886978400144803, y: 3.013187538800507, z: 2.2243349109628587};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=normal";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;
                    break;
                }
                case "BCH-14" : 
                { 
                 name_of_model = "B-Cell GM06990, Healthy, Chromosome 14";
                current_cell_line = 'GM06990';
                isChipSeqAvailable = true;
                zeroCoordinate={x: 1.55303995186045, y: 2.197019566042211, z: 2.906060979462621};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=normal";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;
                    break;
                }
                case "BCH-15" : 
                { 
                 name_of_model = "B-Cell GM06990, Healthy, Chromosome 15";
                current_cell_line = 'GM06990';
                isChipSeqAvailable = true;
                zeroCoordinate={x: 4.1430899937886165, y: 2.206063652812622, z: 3.2603409310289};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=normal";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;
                    break;
                }
                case "BCH-16" : 
                { 
                 name_of_model = "B-Cell GM06990, Healthy, Chromosome 16";
                current_cell_line = 'GM06990';
                isChipSeqAvailable = true;
                zeroCoordinate={x: 4.039037458257831, y: 2.5580294526351235, z: 1.929846300832198};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=normal";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;
                    break;
                }
                case "BCH-17" : 
                { 
                 name_of_model = "B-Cell GM06990, Healthy, Chromosome 17";
                current_cell_line = 'GM06990';
                isChipSeqAvailable = true;
                zeroCoordinate={x: 4.133035698044761, y: 2.462407039945692, z: 4.195447668839935};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=normal";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;
                    break;
                }
                case "BCH-18" : 
                { 
                 name_of_model = "B-Cell GM06990, Healthy, Chromosome 18";
                current_cell_line = 'GM06990';
                isChipSeqAvailable = true;
                zeroCoordinate={x: 2.4204389544257787, y: 2.7924236722558198, z: 2.1668763080083284};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=normal";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;
                    break;
                }
                case "BCH-19" : 
                { 
                 name_of_model = "B-Cell GM06990, Healthy, Chromosome 19";
                current_cell_line = 'GM06990';
                isChipSeqAvailable = true;
                zeroCoordinate={x: 1.8115930828234836, y: 2.904626714948919, z: 2.9414152397511137};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=normal";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;
                    break;
                }
                case "BCH-20" : 
                { 
                 name_of_model = "B-Cell GM06990, Healthy, Chromosome 20";
                current_cell_line = 'GM06990';
                isChipSeqAvailable = true;
                zeroCoordinate={x: 3.49361077188669, y: 4.207871717048262, z: 2.4505625440882604};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=normal";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;
                    break;
                }
                case "BCH-21" : 
                { 
                 name_of_model = "B-Cell GM06990, Healthy, Chromosome 21";
                current_cell_line = 'GM06990';
                isChipSeqAvailable = true;
                zeroCoordinate={x: 3.574121184451935, y: 2.6698422763157805, z: 2.7381431250213564};
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    healthness = "m=normal";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;
                    break;
                }
                case "BCH-22" : 
                { 
                 name_of_model = "B-Cell GM06990, Healthy, Chromosome 22";
                current_cell_line = 'GM06990';
                isChipSeqAvailable = true;
                zeroCoordinate={x: 3.45545567678287, y: 3.310117407814258, z: 2.9226027443824822};
                serviceForStructure = "3d";
                particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                healthness = "m=normal";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;
                break;
                }
                case "BCH-23" : 
                { 
                 name_of_model = "B-Cell GM06990, Healthy, Chromosome 23";
                current_cell_line = 'GM06990';
                isChipSeqAvailable = true;
                zeroCoordinate={x: 3.166116488821329, y: 3.753381136085846, z: 2.6700131713938355};
                serviceForStructure = "3d";
                particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                healthness = "m=normal";
                disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                scaleFactor = 15000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    radiusOfTube = 25;
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;
                break;
                }
                default:
                {
                    isChipSeqAvailable = true;
                    name_of_model = "K562 Cell Type, All Chromosome, Simulation";
                    disease3Dexpression="";
                    current_cell_line = 'K562';
                    zeroCoordinate = {x : 400.0, y: 150.0, z: 0.0};
                    scaleFactor = 10; 
                    blockSize = 400;
                    serviceForStructure = "js_test";
                    disease = "";
                    break;
                }
            }
            
            
            var lastRegion, lastIntersection;
            var arrayOfCHIPCoveredTubes = [];
            var lastMode;
            var _messi;
            var meter;
            var minMeter, maxMeter, stepScroll;
            var is_modal_opened = false;
            var mod_message_div;
            var MAX_CHIP_LVL = 1000;
            var percentColors = [
                { pct: 0.0, color: { r: 0x00, g: 0xff, b: 0 } },
                { pct: 0.5, color: { r: 0x88, g: 0x88, b: 0 } },
                { pct: 1.0, color: { r: 0xff, g: 0x00, b: 0 } } ];
            var is_coloring_of_chipseq = false;
            var deb_var;
            var lastBlockIndicesStr;
            var regexpPattern = /^([\d\-]+)[^\d\-]+([\-\d]+)[^\d\-]+([\d\-]+)[^\d\-]*/i; //[num] smth(1+) [num] smth(1+) [num] smth(0+)
            var regexpPatternChrms = /chr[^\d]*([\d]+[ab]*)[^\dab]+([\d]+)[^\d]+([\d]+)[^\d]*/; //format smth(0+) [num] smth(1+) [num] smth(1+) [num] smth(0+)
            var regexpPatternURL = /([\dXY]{1,2})[_]*([abAB]*)[^\d]+([\d]+)[^\d]+([\d]+)/ ;
            var divElement;
            var test_mesh;
        	var DEBUG = true;
			// zero point in local coordinates translates into zeroCoordinate in the model coordinates        
        	
        	// 1 point in the model coordinates =  scaleFactor points in local coordinates
        	
        
            var camera, scene, renderer, controls;
            var projector = new THREE.Projector();
            
            var infoBlock, staticBlock;
            
            var selectionMesh;
            
            var targetBall;
            
            var basesInSelection = 1500;
            
            var sphere;
            var uploaded_area = {};
            
            var uploaded_splines = {};
            var uploaded_splines_chip = {};
            var uploaded_splines_selection = {};

            var time = Date.now();

			// 3d dna molecules
            var objects = [];

            var chipObjects = [];

            var lines = [];
            
            var regionData = {};
			
			// dark screen, when the game starts
            var blocker = document.getElementById( 'blocker' );
            var instructions = document.getElementById( 'instructions' );
            
            var position = "";
            

            var snp_chip_seq_window;

            var is_plane_mode = true; //start with linear mode
            var mode_name;
            var mode_id = 0;
            var NUMBER_OF_MODES = 3;
        

            function validate(incoords) {

                if (incoords.match(regexpPattern) != null) {
                    ChangeCameraPosition(incoords, 0);
                    console.log("option 0");
                    return true;
                } else if (incoords.match(regexpPatternChrms) != null) {
                    if (incoords.replace(regexpPatternChrms, "$1") != particularChromosome) return false;
                    ChangeCameraPosition(incoords, 1);
                    return true;
                } else {
                    return false;
                }
            }

            function ChangeCameraPosition(incoords, option) {
                var foo =   function() {
                                if (ChangeCameraPositionBoolean)
                                    setTimeout(foo, 50);
                            };

                if (option == 0) {
                    var str = incoords.replace(regexpPattern, "$1:$2:$3");
                    var arr = str.split(':');
                    controls.getObject().position = Global2localVector3({x:parseInt(arr[0]), y:parseInt(arr[1]), z:parseInt(arr[2])});
                } else if (option == 1) {
                    console.log("OPTION 1");
                    var str = incoords.replace(regexpPatternChrms, "$1:$2:$3");
                    var arr = str.split(':');

                    if (parseInt(arr[1]) > parseInt(arr[2])) return false;
                    if (arr[0][arr[0].length - 1] == "b" ) {
                        arr[0] = arr[0].replace("b", "a"); //default value - b doesn't work now
                    }

                    var position = Math.floor((parseInt(arr[2]) + parseInt(arr[1]))/2);
                    var request = incoords.replace(regexpPatternChrms, "chrid=$1&bp=" + String(position));

                    var url = 'http://1kgenome.exascale.info/chr_pos?' + request + ( (serviceForStructure == '3d') ?"&"+healthness:"");

                    $.getJSON(url + "?callback=?", null, 
                        function(data) {
                            if (data[0] == -1) {
                                return;
                            }
                            controls.getObject().position = Global2localVector3({x:parseInt(data[1]), y:parseInt(data[2]), z:parseInt(data[3])});
                            controls.getObject().rotation.set(0,0,0);
                            controls.getObject().children[0].rotation.set(0,0,0)
                            ChangeCameraPositionBoolean = false;
                        }
                    );


                    foo();
                    // http://1kgenome.exascale.info/chr_pos?chrid=10a&bp=2000000

                }
            }

            function changeModeIndicator() {
                //maybe it's not necessary 
                ClearInfo();

                switch(mode_id) {
                    case 0: //linear mode
                        if (lastMode == 2) cleanCHIPSEQdata();
                        mode_name = 'Linear mode';
                        $('p#textmode').text(mode_name+' (TAB for info)');
                        lastMode = 0;
                        break;
                    case 1: //cubic mode
                        if (lastMode == 2) cleanCHIPSEQdata();
                        mode_name = 'Cubic mode';
                        $('p#textmode').text(mode_name+' (TAB for info)');
                        lastMode = 1;
                        break;
                    case 2: //CHiP-SEQ mode
                        scene.remove(selectionMesh);
                        mode_name = 'CHiP-Seq mode';
                        $('p#textmode').text(mode_name+' (TAB for info)');
                        lastMode = 2;
                        break;
                    default:
                        $('p#textmode').text('');
                        break;
                }
            }
            
            function cleanCHIPSEQdata() {
                for (var indx in chipObjects) {
                    scene.remove(chipObjects[indx]);
                }
                chipObjects = [];
                uploaded_splines_chip = {};
                arrayOfCHIPCoveredTubes = [];
            }
            
            function appendStringAsNodes(element, html) {
                var frag = document.createDocumentFragment(),
                    tmp = document.createElement('body'), child;
                tmp.innerHTML = html;
                while (child = tmp.firstChild) {
                    frag.appendChild(child);
                }
                element.appendChild(frag);
                frag = tmp = null;
            }

            //generate fake genotype - should be deleted after appearence of the real data!!!
            function getFakeGenotypeForSNP() {
                var text = "";
                var possible = "ACGT";
                for( var i=0; i < 2; i++ )
                    text += possible.charAt(Math.floor(Math.random() * possible.length));
                
                return text;
            }
            
            function reverseLine(s){
                return s.split("").reverse().join("");
            }
            
            function init_controls() {
                var element = document.body;
                var pointerlockchange = function ( event ) {
                    // console.log( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element);
                    if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element) {
                        controls.enabled = true;
                        blocker.style.display = 'none';
                        changeModeIndicator();
                    } else {
                        controls.enabled = false;
                        blocker.style.display = '-webkit-box';
                        blocker.style.display = '-moz-box';
                        blocker.style.display = 'box';
                        if (!is_modal_opened) instructions.style.display = '';
                        $('p#textmode').text('');
                        document.getElementById('detection-sign').style.display = "none";
                    }
            	}
                var pointerlockerror = function ( event ) {
                    instructions.style.display = '';
                }

                // Hook pointer lock state change events
                document.addEventListener( 'pointerlockchange', pointerlockchange, false );
                document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
                document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );

                document.addEventListener( 'pointerlockerror', pointerlockerror, false );
                document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
                document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );
                window.addEventListener( "oncontextmenu", function ( event ) { 
                }, false );
                
                window.addEventListener("click",function(event) {
                    if(controls.enabled == true) {
                        
                        if (mode_id == 0) { // only linear mode
                            var _intersection = GetIntersection();
                            if (_intersection == null) {
                                showErrorAlertModalWindow("Point the area firstly!");
                                return;
                            }
                            if (_intersection.object.name == "")
                                return;

                            is_modal_opened = true;
                            
                            $('p#textmode').text('');
                            document.exitPointerLock = document.exitPointerLock ||
                                                        document.mozExitPointerLock ||
                                                        document.webkitExitPointerLock;
                            document.exitPointerLock();
                            if ( /Firefox/i.test( navigator.userAgent ) ) exitFromFullScreen();
                            tableStrContent = '';
                            
                            var object = _intersection.object;
                            var obj_name = _intersection.object.name;
                            var point = _intersection.point;
                            var region = lastRegion;
                            
                            if (typeof region != 'undefinded' && region.length > 0) {
                                var custDataArrayObj = {};
                                var custDataArray;
                                if (isCustomerData) {
                                    custDataArray = customerData[uploaded_splines[obj_name][4]].slice(uploaded_splines[obj_name][2],uploaded_splines[obj_name][3]+1);
                                    
                                    var startRegPos = parseInt(region[0].replace(/.*bases:\s*([\d]+)[^\d]+([\d]+).*/,'\$1'));
                                    var endRegPos = parseInt(region[0].replace(/.*bases:\s*([\d]+)[^\d]+([\d]+).*/,'\$2'));
                                    for (var indx = 0; indx < custDataArray.length; indx++) {
                                        if ( custDataArray[indx][0] < startRegPos ) continue;
                                        else if (custDataArray[indx][0] > endRegPos ) break;
                                        else {
                                            custDataArrayObj[custDataArray[indx][1]] = custDataArray[indx][2];
                                        }
                                    }
                                }    
                                var tbl = document.createElement('table');
                                tbl.setAttribute('id','table_linear');
                                var tbdy = document.createElement('tbody');
                                for (var track_internal_index = 0; track_internal_index < region.length-1; ++track_internal_index) {
                                    var temp = region[track_internal_index].replace(/Selection: |style\s*=\s*\"[^\"]+"/g, "");
                                    
                                    var tr=document.createElement('tr');
                                    var td=document.createElement('td');
                                    if (track_internal_index == 2) { //isCustomerData && 
                                            var mystr = region[track_internal_index].replace(/.*SNPs:\s/,"").replace(/<a [^>]*href=\"[^\"]*rs=([\d]+)">(rs[\d]+)<\/a>;\s*/g, "\$1,");
                                            var arr = mystr.split(",");
                                            tr=document.createElement('tr');
                                            td=document.createElement('td');
                                            appendStringAsNodes(td, "@SNPs/Genotype");
                                            td.colSpan = "2";
                                            tr.appendChild(td);
                                        
                                            if (isCustomerData) {
//                                                tr=document.createElement('tr');
                                                td=document.createElement('td');
//                                                td.colSpan="1"
                                                appendStringAsNodes(td, "@Customer Data/Genotype");
                                                tr.appendChild(td);
                                            }
                                            tbdy.appendChild(tr);
                                        //itteration over all SNPs in system (not custom)
                                            for (var i = 0; i< arr.length-1;i++) {
                                                tr=document.createElement('tr');
                                                td=document.createElement('td');
                                                appendStringAsNodes(td, "<a target=\"_blank\" href=\"http://www.ncbi.nlm.nih.gov/SNP/snp_ref.cgi?rs="+arr[i]+"\">rs"+arr[i]+"</a>");
                                                tr.appendChild(td);
                                                
                                                td=document.createElement('td');
                                                var snpGenotypeSys = region[3][i];
                                                appendStringAsNodes(td, snpGenotypeSys);
                                                tr.appendChild(td);
                                                if (isCustomerData) {
                                                    td=document.createElement('td');
                                                    if (custDataArrayObj[String(arr[i])]||custDataArrayObj["rs"+String(arr[i])]) { 
                                                        var snpGenotypeCust = custDataArrayObj[String(arr[i])]||custDataArrayObj["rs"+String(arr[i])];
                                                        appendStringAsNodes(td, snpGenotypeCust);
                                                        tr.appendChild(td);
                                                        if (snpGenotypeSys == snpGenotypeCust || snpGenotypeSys == reverseLine(snpGenotypeCust)) tr.style.color="rgb(0,200,0)";
                                                        else tr.style.color = "rgb(255,0,0)";
                                                        delete custDataArrayObj[String(arr[i])];
                                                        delete custDataArrayObj["rs"+String(arr[i])];
                                                    }
                                                }
                                                tbdy.appendChild(tr);
                                            }
                                        
                                            //print everything that is not in the list of System SNPs
                                            console.log(custDataArrayObj);
                                            if (isCustomerData && typeof custDataArrayObj != 'undefined' && Object.size(custDataArrayObj) >0 ) {
                                                tr=document.createElement('tr');
                                                td=document.createElement('td');
                                                appendStringAsNodes(td, "@SNPs are not in the list/Genotype");
                                                td.colSpan = "2";
                                                tr.appendChild(td);
                                                tbdy.appendChild(tr);
                                                for (var custDataIndx in custDataArrayObj) {
                                                    tr=document.createElement('tr');
                                                    td=document.createElement('td');
                                                    appendStringAsNodes(td, custDataIndx);
                                                    td=document.createElement('td');
                                                    appendStringAsNodes(td, custDataArrayObj[custDataIndx]);
//                                                    td.colSpan = "2";
                                                    tr.appendChild(td);
                                                    tbdy.appendChild(tr);
                                                }
                                            }
                                                
                                            tbdy.appendChild(tr);
                                    }
                                    else {
                                        appendStringAsNodes (td, temp);
                                        if (isCustomerData) td.colSpan="3";
                                        else td.colSpan="2";
                                        tr.appendChild(td)
                                        tbdy.appendChild(tr);
                                    }
                                }
                                tbl.appendChild(tbdy);
                                var element = document.body;
                                _messi = new Messi(tbl, {title: 'Linear data', center: false, viewport: {top: '5vh', left: '10%'}, titleClass: 'success', buttons: [{id: 0, label: 'Ok', val: 'O'}], 
                                callback: function(val) { 
                                    if ( /Firefox/i.test( navigator.userAgent ) ) enterInFullScreen();
                                    element.requestPointerLock = element.requestPointerLock ||element.mozRequestPointerLock||element.webkitRequestPointerLock;
                                                    element.requestPointerLock(); is_modal_opened = false;}});   
                            }
                            return false;
                        } else if (mode_id == 1) { // only cubic mode
                            var _intersection = GetIntersection();
                            if (_intersection == null) {
                                showErrorAlertModalWindow("Point the area firstly!");
                                return;
                            }
                            if (_intersection.object.name == "")
                                return;
                            var modelPositionCamera = Local2global(controls.getObject().position);
            	            var blockIndicesCamera = GetBlockIndices(modelPositionCamera);
                            
                            var blockIndicesPointer = _intersection.object.userData[1];
                            
                            if (!(blockIndicesCamera.x == blockIndicesPointer.x && blockIndicesCamera.y == blockIndicesPointer.y && blockIndicesCamera.z == blockIndicesPointer.z)) {
                                showErrorAlertModalWindow('Choose the point in your cubic area to explore (or closest area).');
                                return false;
                            }
                            is_modal_opened = true;
                            $('p#textmode').text('');
                            document.exitPointerLock = document.exitPointerLock ||
                                                        document.mozExitPointerLock ||
                                                        document.webkitExitPointerLock;
                            
                            document.exitPointerLock();
                            if ( /Firefox/i.test( navigator.userAgent ) ) exitFromFullScreen();
                            
                            tableStrContent = '';
                            
                            
                            var arrRequestInfo = buildCubeDataStructureSNPs(searchOctree());

                            waitFunction(arrRequestInfo);

                            return false;
                        } else if (mode_id == 2) { // only for CHIP-SEq mode
                            if (!isChipSeqAvailable) showErrorAlertModalWindow("ChIP-Sequencing Data is not available for this 3d model.")

                            var __intersection = GetIntersectionCHIPSEQ();
                            var _intersection = GetIntersection();

                            if (__intersection) {

                                is_modal_opened = true;
                                $('p#textmode').text('');
                                document.exitPointerLock = document.exitPointerLock ||
                                                            document.mozExitPointerLock ||
                                                            document.webkitExitPointerLock;
                                
                                document.exitPointerLock();
                                if ( /Firefox/i.test( navigator.userAgent ) ) exitFromFullScreen();
                                
                                var temp;
                                // if (typeof lastIntersection  != 'undefined' && intersection[0].point.x == lastIntersection.x && intersection[0].point.y == lastIntersection.y && intersection[0].point.z == lastIntersection.z) {
                                //     return;
                                // } else {
                                    var tbl = document.createElement('table');
                                    tbl.setAttribute('id','table_linear');
                                    var tbdy = document.createElement('tbody');

                                    var tr=document.createElement('tr');
                                    var td=document.createElement('td');
                                    appendStringAsNodes(td, "Chromosome/Positions");
                                    tr.appendChild(td);

                                    td=document.createElement('td');
                                    appendStringAsNodes(td, "Transcription Factors");
                                    tr.appendChild(td);

                                    td=document.createElement('td');
                                    appendStringAsNodes(td, "Affection Level");
                                    tr.appendChild(td);
                                    tbdy.appendChild(tr);

                                    for (var inter_indx in __intersection) {
                                        tr=document.createElement('tr');
                                        temp = uploaded_splines_chip[__intersection[inter_indx].object.name.replace(/^23/, 'x')];
                                        td=document.createElement('td');
                                        appendStringAsNodes(td, "<a target='_blank' href='http://genome.ucsc.edu/cgi-bin/hgTracks?db=hg19&position=chr"+temp[0]+"%3A"+temp[1]+"-"+temp[2]+"' >Chr "+temp[0]+" ("+temp[1] + "-" + temp[2] + ")</a>");
                                        tr.appendChild(td);

                                        td=document.createElement('td');
                                        appendStringAsNodes(td, temp[3]);
                                        tr.appendChild(td);

                                        td=document.createElement('td');
                                        appendStringAsNodes(td, temp[4]);
                                        tr.appendChild(td);
                                        tbdy.appendChild(tr);
                                    }
                                    tbl.appendChild(tbdy);

                                    var element = document.body;
                                    _messi = new Messi(tbl/*tableStrContent*/, {title: 'ChIP-Seq data', center: false, viewport: {top: '5vh', left: '30%'}, titleClass: 'success', buttons: [{id: 0, label: 'Ok', val: 'O'}], 
                                                            callback: function(val) { 
                                                                if ( /Firefox/i.test( navigator.userAgent ) ) enterInFullScreen();
                                                                element.requestPointerLock = element.requestPointerLock ||
                                                                                         element.mozRequestPointerLock ||
                                                                                         element.webkitRequestPointerLock;
                                                            element.requestPointerLock(); is_modal_opened = false;}});

                                //     lastIntersection = intersection[0].point;
                                // }

                                // if () {

                                // } else {
                                //     showErrorAlertModalWindow("You have already colored this part of chromosome. In the pointed area there are no Transcription Factors.");
                                // }
                                return ;
                            } else if (_intersection) {
                                if ($.inArray(_intersection.object.name, arrayOfCHIPCoveredTubes) != -1) {
                                    showErrorAlertModalWindow("You have already colored this part of chromosome. To get popup window with ChIP-Seq data point exactly to the colored segments and click.");
                                    return;
                                } else {
                                    if (_intersection.object.name == "")
                                        return;
                                    arrayOfCHIPCoveredTubes.push(_intersection.object.name);
                                    drawChipSeqDataRunner(_intersection); //should be renamed
                                }
                            } else {
                                showErrorAlertModalWindow("Point the area firstly!");
                                return;
                            }
                        }
                    }
                });

                instructions.addEventListener( 'click', function ( event ) {
                    instructions.style.display = 'none';
                    // Ask the browser to lock the pointer
                    element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
                    if ( /Firefox/i.test( navigator.userAgent ) ) {
                        var fullscreenchange = function ( event ) {
                            if ( document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element ) {
                                document.removeEventListener( 'fullscreenchange', fullscreenchange );
                                document.removeEventListener( 'mozfullscreenchange', fullscreenchange );
                                element.requestPointerLock();
                            }
                        }
                        document.addEventListener( 'fullscreenchange', fullscreenchange, false );
                        document.addEventListener( 'mozfullscreenchange', fullscreenchange, false );
                        element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;
                        element.requestFullscreen();
                        element.requestPointerLock();
                    } else {
                        element.requestPointerLock();
                    }
                }, false );    
                
				{
                    var GKeyDownHandler = function (event) {
                        var element = document.body;
                        if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element )
                            switch ( event.keyCode ) {
                                /*moved to the left click event for the window*/
                                // case 84: //t
                                    
                                //     break;
                                case 71: //g
                                    {
                                        // if (!is_plane_mode) {
                                        if (mode_id == 0) {
                                            var _intersection = GetIntersection();
                                            if (_intersection == null) {
                                                showErrorAlertModalWindow("Point the area firstly!");
                                                return;
                                            }

                                            document.exitPointerLock = document.exitPointerLock ||
                                                                    document.mozExitPointerLock ||
                                                                    document.webkitExitPointerLock;
                                            document.exitPointerLock();
                                            if ( /Firefox/i.test( navigator.userAgent ) ) exitFromFullScreen();

    //                                        element.requestPointerLock = element.requestPointerLock ||
    //                                                                     element.mozRequestPointerLock ||
    //                                                                     element.webkitRequestPointerLock;
    //                                        element.requestPointerLock();
                                            init_new_window_SNP_CHIP_SEQ(rgn, true);
                                        } else if (mode_id == 1) {
                                            var _intersection = GetIntersection();
                                            if (_intersection == null) {
                                                showErrorAlertModalWindow("Point the area firstly!");
                                                return;
                                            }

                                            document.exitPointerLock = document.exitPointerLock ||
                                                                    document.mozExitPointerLock ||
                                                                    document.webkitExitPointerLock;
                                            document.exitPointerLock();
                                            if ( /Firefox/i.test( navigator.userAgent ) ) exitFromFullScreen();
    //                                        element.requestPointerLock = element.requestPointerLock ||
    //                                                                     element.mozRequestPointerLock ||
    //                                                                     element.webkitRequestPointerLock;
    //                                        element.requestPointerLock();
                                            init_new_window_SNP_CHIP_SEQ(_intersection.point, false);
                                        }
                                        break;
                                    }
                                case 67: //c - change mode
                                    // is_plane_mode = !is_plane_mode;
                                    mode_id ++;
                                    if (mode_id >= NUMBER_OF_MODES) mode_id = 0;
                                    changeModeIndicator();
                                    break;  
                                case 9: //tab - information about current mode
                                    is_modal_opened = true;
                                    $('p#textmode').text('');
                                    document.exitPointerLock = document.exitPointerLock ||
                                                                document.mozExitPointerLock ||
                                                                document.webkitExitPointerLock;
                                    document.exitPointerLock();
                                    if ( /Firefox/i.test( navigator.userAgent ) ) exitFromFullScreen();
                                    _messi = new Messi(textMessages[mode_name], {title: mode_name, titleClass: 'success', buttons: [{id: 0, label: 'Ok', val: 'O'}], 
                                        callback: function(val) { 
                                            if ( /Firefox/i.test( navigator.userAgent ) ) enterInFullScreen();
                                            element.requestPointerLock = element.requestPointerLock ||
                                                                     element.mozRequestPointerLock ||
                                                                     element.webkitRequestPointerLock;
                                        element.requestPointerLock(); is_modal_opened = false;
                                                                }});
                                    return false;
                            }
                    }

                    //scrolling event
					var scrollHandler = function (event) {
                        var element = document.body;
                        if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ){
                            
                            
                            if (event.detail != null && event.detail < 0 || event.wheelDeltaY != null && event.wheelDeltaY > 0) {
//                                if (mode_id == 0) basesInSelection = Math.min(3000, basesInSelection + 100);
                                if (mode_id == 0) basesInSelection = Math.min(maxMeter, basesInSelection + stepScroll);
                                if (mode_id == 1) radiusSphere = Math.min(maxRadiusSphere, radiusSphere + 10);
                            } else {
//                                if (mode_id == 0) basesInSelection = Math.max(100, basesInSelection - 100);
                                if (mode_id == 0) basesInSelection = Math.max(minMeter, basesInSelection - stepScroll);
                                if (mode_id == 1)radiusSphere = Math.max(minRadiusSphere, radiusSphere -10);
                            }    
                        }
						
					};
					var mousewheelevt = (/Firefox/i.test(navigator.userAgent)) ? "DOMMouseScroll" : "mousewheel";
					if (document.attachEvent) //if IE (and Opera depending on user setting) 
                    {
                        document.attachEvent("on"+mousewheelevt, scrollHandler);
                        document.attachEvent("onkeydown", GKeyDownHandler);
                    }
					else if (document.addEventListener) //WC3 browsers
                    {
                        document.addEventListener(mousewheelevt, scrollHandler, false);
                        document.addEventListener("keydown", GKeyDownHandler, false);
                    }
				}
            }

            function waitFunction(arrRequestInfo){
                console.log(req_count  + " : " + resp_count);
                if (resp_count < req_count && waitInterval < MAX_WAIT_INTERVAL) {
                    waitInterval = waitInterval + 50;
                    setTimeout(function(){waitFunction(arrRequestInfo);}, 50);
                } else {
                    var internalTemp;
                    var tbl = document.createElement('table');
                    tbl.setAttribute('id','table_cube');
                    var tbdy = document.createElement('tbody');
                    var tr=document.createElement('tr');
                    var td=document.createElement('td');
                    appendStringAsNodes(td, "Chromasome/positions");
                    tr.appendChild(td);
                    td=document.createElement('td');
                    appendStringAsNodes(td, "SNPs");
                    tr.appendChild(td);
                    tbdy.appendChild(tr);
                    if (!arrRequestInfo) arrRequestInfo = [];
                    for (var i = 0; i < arrRequestInfo.length; i++) {
                        internalTemp = arrRequestInfo[i];
                        for (var j = 0; j < internalTemp.length; j++) {
                            tr=document.createElement('tr');
                            td=document.createElement('td');
                            appendStringAsNodes(td, "Chr "+internalTemp[j][0][0] + " ("+internalTemp[j][0][1]+"-"+internalTemp[j][0][2]+")");
                            tr.appendChild(td);
                            td=document.createElement('td');
                            var result = '';
                            var _temp = internalTemp[j][1].responseJSON;
                            for (var it_indx in _temp) {
                                result += " <a target=\"_blank\"  href=\"http://www.ncbi.nlm.nih.gov/SNP/snp_ref.cgi?rs="+_temp[it_indx][1]+"\">rs"+_temp[it_indx][1]+"</a>;";
                            }
                            appendStringAsNodes(td, result);
                            tr.appendChild(td);
                            tbdy.appendChild(tr);
                        }
                    }
                    tbl.appendChild(tbdy);
                    
                    var element = document.body;
                    _messi = new Messi(tbl/*tableStrContent*/, {title: 'Cubic data', center: false, viewport: {top: '5vh', left: '30%'}, titleClass: 'success', buttons: [{id: 0, label: 'Ok', val: 'O'}], 
                                            callback: function(val) { 
                                                if ( /Firefox/i.test( navigator.userAgent ) ) enterInFullScreen();
                                                element.requestPointerLock = element.requestPointerLock ||
                                                                         element.mozRequestPointerLock ||
                                                                         element.webkitRequestPointerLock;
                                            element.requestPointerLock(); is_modal_opened = false;}});
                }
            }

            function drawModalWindowTable(meshesSearch) {


                var element = document.body;
                    if ( /Firefox/i.test( navigator.userAgent ) ) exitFromFullScreen();
                    _messi = new Messi(tableStrContent, {title: 'Cubic data', center: false, viewport: {top: '5vh', left: '30%'}, titleClass: 'success', buttons: [{id: 0, label: 'Ok', val: 'O'}], 
                                            callback: function(val) { 
                                                if ( /Firefox/i.test( navigator.userAgent ) ) enterInFullScreen();
                                                element.requestPointerLock = element.requestPointerLock ||
                                                                         element.mozRequestPointerLock ||
                                                                         element.webkitRequestPointerLock;
                                            element.requestPointerLock(); is_modal_opened = false;}});
            }

            function drawChipSeqDataRunner(_intersection) {
                var name = _intersection.object.name;
                var requestCHIP = name.replace(regexpPatternURL, "chr=$1&start=$3&end=$4&celline="+current_cell_line);
                requestCHIP = requestCHIP.replace('chr=23','chr=X');

                var urlCHIP = 'http://1kgenome.exascale.info/chipseq?' + requestCHIP;

                $.getJSON(urlCHIP + "?callback=?", null, 
                    function(data) {
                        // drawChipSeqData(data, _intersection);
                        chipseqDataPostionDeterminitionAndDraw(data, _intersection);
                    }
                );
            }

            //@deprecated - use very inaccurate method of approximation.
            function drawChipSeqData(data, _intersection) {
                var name = _intersection.object.name;
                var vertices = _intersection.object.geometry.vertices;
                var aLen = vertices.length;
                var startRange = parseInt(name.replace(regexpPatternURL, "$3"));
                var endRange = parseInt(name.replace(regexpPatternURL, "$4"));
                var unit = (endRange - startRange)/(aLen-1);
                var aStart, aEnd; //in array of vertices proportionally
                var chipVertices;
                var chipName;
                for (var indx in data) {
                    if (startRange >= data[indx][1])
                        aStart = 0;
                    else
                        aStart = Math.ceil((data[indx][1]-startRange)/unit);
                    
                    if (endRange <= data[indx][2])
                        aEnd = aLen-1;
                    else
                        aEnd = Math.floor((data[indx][2]-startRange)/unit);
                    var tube_color = getColorForPercentage(data[indx][4]);
                    var material = new THREE.MeshLambertMaterial( { color: tube_color, shading: THREE.SmoothShading } );
                    chipVertices = [];
                    
                    for (var pointIndex = aStart; pointIndex <= aEnd; ++pointIndex) {
                        chipVertices.push(vertices[pointIndex])
                    }
                    var spline = new THREE.SplineCurve3(chipVertices);
                    
                    var segments = chipVertices.length * 2;
                    var radiusSegments = 5;
                    var tube = new THREE.TubeGeometry( spline, segments, 10, radiusSegments, false, false);
                    tube.dynamic = true;
                    var tubeMesh = new THREE.Mesh(tube, material);  
                    tubeMesh.userData = [blockIndicesStr, blockIndices];//?
                    
                    tubeMesh.name = data[indx][0] + "-" + String(data[indx][1]) + "-"  + String(data[indx][2]);
                    uploaded_splines_chip[tubeMesh.name] = [data[indx][0], data[indx][1], data[indx][2], data[indx][3], data[indx][4]];                                
                    scene.add(tubeMesh);
                    chipObjects.push(tubeMesh);
                }
            }

            function chipseqDataPostionDeterminitionAndDraw(data, _intersection) {
                var userDataChip = _intersection.object.userData;
                console.log("RUN");
                // var vertices = vertices of the intersection.object.geometry.vertices
                var vertices = _intersection.object.geometry.vertices;
                // var data = data after

                var _vert1 = uploaded_splines[_intersection.object.name][1];//nodes

                var vertices_start_position = 0; //out
                var last_seen_interval_end = 1; //out
                var left_distance_begin, left_distance_end; //in but without any values
                var start_node, end_node;
                var first_vert = -1;
                var second_vert = -1;
                var tr = true;
                
                if (!data) {
                    showErrorAlertModalWindow('There is no data to be shown. Try to move in the next cube and explore the same part of genome.');
                    return;
                }

                var vert_length = _vert1.length;
                for (var ss = 0; ss <data.length; ss++) {
                    first_vert = -1;
                    second_vert = -1;
                    var distance_between_nodes = -1;
                    start_node = -1;
                    end_node = -1;
                    if (data[ss][2] >= _vert1[vert_length-1][1]) {
                        second_vert = vertices.length-1;
                    }
                    //iterator for beginnings
                    for (var kk = last_seen_interval_end; kk <vert_length; kk++) {

                        // console.log("LF: " + data[ss][1] + "; I have: " + _vert1[kk][1] + "|" + (data[ss][1]<_vert1[kk][1]));
                        if (data[ss][1]<_vert1[kk][1]) {// -------start--------v--
                            last_seen_interval_end = kk;
                            //@useless
                            distance_between_nodes = Math.sqrt(Math.pow(_vert1[kk-1][2] - _vert1[kk][2], 2) + 
                                                    Math.pow(_vert1[kk-1][3] - _vert1[kk][3], 2) +
                                                    Math.pow(_vert1[kk-1][4] - _vert1[kk][4], 2));

                            //Local to global problems (change from distance in global space - to rate in any space (iuncluding local))
                            // left_distance_begin = (data[ss][1] - _vert1[kk-1][1])/(_vert1[kk][1] - _vert1[kk-1][1])*Math.floor(distance_between_nodes); //-----v=======begin------
                            left_distance_begin = (data[ss][1] - _vert1[kk-1][1])/(_vert1[kk][1] - _vert1[kk-1][1]);//changed!!!

                            // console.log("("+data[ss][1]+" - "+_vert1[kk-1][1]+")/("+_vert1[kk][1]+" - "+_vert1[kk-1][1]+")*Math.floor("+distance_between_nodes+")");
                            start_node = kk-1;
                            break;
                        }
                    }

                    if (start_node == -1) {
                        console.log("Start_node has not been defined " + ss);
                        continue;
                    }

                    if (second_vert == -1) {
                        //iterator for ends
                        for (var kk = last_seen_interval_end; kk <vert_length; kk++) {
                            if (data[ss][2]<_vert1[kk][1]) { // -------end--------v--
                                //@useless
                                if (kk != last_seen_interval_end) {
                                    distance_between_nodes = Math.sqrt(Math.pow(_vert1[kk-1][2] - _vert1[kk][2], 2) + 
                                                            Math.pow(_vert1[kk-1][3] - _vert1[kk][3], 2) +
                                                            Math.pow(_vert1[kk-1][4] - _vert1[kk][4], 2));  
                                }
                                end_node = kk-1;

                                //Local to global problems (change from distance in global space - to rate in any space (iuncluding local))
                                // left_distance_end = (data[ss][2] - _vert1[kk-1][1])/(_vert1[kk][1] - _vert1[kk-1][1])*Math.floor(distance_between_nodes); //-----v=======begin------
                                left_distance_end = (data[ss][2] - _vert1[kk-1][1])/(_vert1[kk][1] - _vert1[kk-1][1]); //changed!!!
                                break;
                            }
                        }   
                        if (end_node == -1) {
                            console.log("End_node has not been defined " + ss);
                            continue;
                        }
                    }
                    
                    if (end_node == -1 || start_node == -1) {
                        console.log("Nodes have not been defined " + ss);
                        continue;
                    }
                    
                    if (start_node == _vert1.length-1) {
                        end_node = start_node;
                        start_node = start_node - 1;
                    } else if (end_node == start_node) {
                        console.log("Nodes has been artificially increased in size to be recognizable.");
                        if (end_node == vert_length-1)
                            start_node--;
                        else {
                            end_node++;
                            left_distance_end = 0;
                        }
                    }
                    
                    if (1==1)
                    /*parallel solutions - BEGIN*/
                    {
                        var start_node_vector = Global2local({x:_vert1[start_node][2], y:_vert1[start_node][3],z:_vert1[start_node][4]});
                        var next_to_start_node_vector = Global2local({x:_vert1[start_node+1][2], y:_vert1[start_node+1][3],z:_vert1[start_node+1][4]});

                        var start_local_vector3  = new THREE.Vector3((next_to_start_node_vector.x - start_node_vector.x)*left_distance_begin + start_node_vector.x,
                            (next_to_start_node_vector.y - start_node_vector.y)*left_distance_begin + start_node_vector.y, 
                            (next_to_start_node_vector.z - start_node_vector.z)*left_distance_begin + start_node_vector.z);
                        var minDistance = -1;
                        for (var kk = vertices_start_position; kk < vertices.length; kk++) {
                            distance = Math.pow(vertices[kk].x - start_local_vector3.x, 2) + 
                                Math.pow(vertices[kk].y - start_local_vector3.y, 2) +
                                Math.pow(vertices[kk].z - start_local_vector3.z, 2);
                            if (minDistance == -1 || (distance < minDistance)) {
                                minDistance = distance;
                                first_vert = kk;
                            }
                        }
                        vertices_start_position = first_vert;
                        if (first_vert == -1) {
                            console.log("first_vert has not been defined " + ss);
                            continue;
                        }

                        var end_node_vector = Global2local({x:_vert1[end_node][2], y:_vert1[end_node][3], z:_vert1[end_node][4]});
                        var next_to_end_node_vector = Global2local({x:_vert1[end_node+1][2], y:_vert1[end_node+1][3], z:_vert1[end_node+1][4]});

                        var end_local_vector3 = new THREE.Vector3((next_to_end_node_vector.x - end_node_vector.x)*left_distance_begin + end_node_vector.x, 
                            (next_to_end_node_vector.y - end_node_vector.y)*left_distance_begin + end_node_vector.y, 
                            (next_to_end_node_vector.z - end_node_vector.z)*left_distance_begin + end_node_vector.z);
                        minDistance = -1;
                        for (var kk = first_vert + 1; kk < vertices.length; kk++) {
                            distance = Math.pow(vertices[kk].x - end_local_vector3.x, 2) + 
                                Math.pow(vertices[kk].y - end_local_vector3.y, 2) +
                                Math.pow(vertices[kk].z - end_local_vector3.z, 2);
                            if (minDistance == -1 || (distance < minDistance)) {
                                minDistance = distance;
                                second_vert = kk;
                            }
                        }

                    }
                    /*parallel solutions - END*/
                    //@DeadCode : should be deleted before the next release
                    else {
                        
                        //I can iterate over vertices of object right here with saved state.
                        //iteration to find the closest vertex near node
                        // var is_first_node_found = false;
                        var minDistance = -1;
                        var distance = -1;
                        var first_node_vert = -1;
                        var first_vert = -1;
                        var start_node_vector = Global2local({x:_vert1[start_node][2], y:_vert1[start_node][3],z:_vert1[start_node][4]});
                        var next_to_start_node_vector = Global2local({x:_vert1[start_node+1][2], y:_vert1[start_node+1][3],z:_vert1[start_node+1][4]});
                        //find the closest node point
                        for (var kk = vertices_start_position; kk < vertices.length; kk++) {
                            distance = Math.pow(vertices[kk].x - start_node_vector.x, 2) + 
                                Math.pow(vertices[kk].y - start_node_vector.y, 2) +
                                Math.pow(vertices[kk].z - start_node_vector.z, 2);
                            if (distance < NODE_THRESHOLD) {
                                if (minDistance == -1 || (distance < minDistance)) {
                                    minDistance = distance;
                                    first_node_vert = kk;
                                } else if (minDistance != -1 && distance>2*minDistance) {
                                    // is_first_node_found = true;
                                    break;
                                }
                            } else if (minDistance != -1){
                                // is_first_node_found = true;
                                break;
                            }
                        }

                        if (first_node_vert == -1) {
                            console.log("first_node_vert has not been defined " + ss);
                            continue;
                        }

                        console.log("first_node_vert = " + first_node_vert + " ; minDistance = " + minDistance);//finisherd here!!!

                        // console.log(left_distance_begin);
                        // var sq_left_distance_begin = Math.pow(left_distance_begin,2);

                        var sq_left_distance_begin = Math.pow((next_to_start_node_vector.x - start_node_vector.x)*left_distance_begin /*+ start_node_vector.x - start_node_vector.x*/, 2) + 
                            Math.pow((next_to_start_node_vector.y - start_node_vector.y)*left_distance_begin /*+ start_node_vector.y - start_node_vector.y*/, 2) + 
                            Math.pow((next_to_start_node_vector.z - start_node_vector.z)*left_distance_begin /*+ start_node_vector.z - start_node_vector.z*/, 2);

                        for (var kk = first_node_vert; kk < vertices.length; kk++) {
                            distance = Math.pow(vertices[kk].x - vertices[first_node_vert].x, 2) + 
                                Math.pow(vertices[kk].y - vertices[first_node_vert].y, 2) +
                                Math.pow(vertices[kk].z - vertices[first_node_vert].z, 2);

                                if (distance > sq_left_distance_begin) {
                                    first_vert = kk-1;
                                    break;
                                } else {
                                    // console.log(distance +  " >? " + sq_left_distance_begin);
                                }
                        }

                        if (first_vert == -1) {
                            console.log("first_vert has not been defined " + ss);
                            continue;
                        }
                        
                        if (second_vert == -1) {
                            minDistance = -1;
                            var second_node_vert= -1;
                            var end_node_vector = Global2local({x:_vert1[end_node][2], y:_vert1[end_node][3], z:_vert1[end_node][4]});
                            var next_to_end_node_vector = Global2local({x:_vert1[end_node+1][2], y:_vert1[end_node+1][3], z:_vert1[end_node+1][4]});
                            for (var kk = first_vert; kk < vertices.length; kk++) {
                                distance = Math.pow(vertices[kk].x - end_node_vector.x, 2) + 
                                    Math.pow(vertices[kk].y - end_node_vector.y, 2) +
                                    Math.pow(vertices[kk].z - end_node_vector.z, 2);
    //                            console.log("D: " + distance);
                                if (distance < NODE_THRESHOLD) {
                                    if (minDistance == -1 || (distance < minDistance)) {
                                        minDistance = distance;
                                        second_node_vert = kk;
                                    } else if (minDistance != -1 && distance>2*minDistance) {
                                        // is_first_node_found = true;
                                        break;
                                    }
                                } else if (minDistance != -1){
                                    // is_first_node_found = true;
                                    break;
                                }
                            }   
                            if (second_node_vert == -1) {
                                console.log("second_node_vert has not been defined " + ss);
                                continue;
                            }
                        
                            // var sq_left_distance_end = Math.pow(left_distance_end,2);
                            var sq_left_distance_end = Math.pow((next_to_end_node_vector.x - end_node_vector.x)*left_distance_begin /*+ end_node_vector.x - end_node_vector.x*/, 2) + 
                                Math.pow((next_to_end_node_vector.y - end_node_vector.y)*left_distance_begin /*+ end_node_vector.y - end_node_vector.y*/, 2) + 
                                Math.pow((next_to_end_node_vector.z - end_node_vector.z)*left_distance_begin /*+ end_node_vector.z - end_node_vector.z*/, 2);

                            for (var kk = second_node_vert; kk < vertices.length; kk++) {
                                distance = Math.pow(vertices[kk].x - vertices[second_node_vert].x, 2) + 
                                    Math.pow(vertices[kk].y - vertices[second_node_vert].y, 2) +
                                    Math.pow(vertices[kk].z - vertices[second_node_vert].z, 2);

                                    if (distance > sq_left_distance_end) {
                                        second_vert = kk-1;
                                        break;
                                    }
                            }
                            if (second_vert == -1) {
                                console.log("second_vert has not been defined " + ss);
                                continue;
                            }
                        }
                    }

                    //draw part
                    {
                        var tube_color = getColorForPercentage(data[ss][4]);
                        var material = new THREE.MeshLambertMaterial( { color: tube_color, shading: THREE.SmoothShading } );
                        var chipVertices = [];
                        for (var pointIndex = first_vert; pointIndex <= second_vert; ++pointIndex) {
                            chipVertices.push(new THREE.Vector3(vertices[pointIndex].x, vertices[pointIndex].y, vertices[pointIndex].z));
                        }
                        var spline = new THREE.SplineCurve3(chipVertices);
                        var segments = chipVertices.length * 1;
                        var radiusSegments = 10;
                        var tube = new THREE.TubeGeometry( spline, segments, radiusOfTube-2, radiusSegments, false, false);
                        tube.dynamic = true;
                        var tubeMesh = new THREE.Mesh(tube, material);
                        tubeMesh.userData = userDataChip;//?
                        tubeMesh.name = data[ss][0] + "-" + String(data[ss][1]) + "-"  + String(data[ss][2]);
                        uploaded_splines_chip[tubeMesh.name] = [data[ss][0], data[ss][1], data[ss][2], data[ss][3], data[ss][4]];                                
                        scene.add(tubeMesh);
                        chipObjects.push(tubeMesh);
                    }
                }

            }

            function getColorForPercentage(chipLvl) {
                var pct = chipLvl/MAX_CHIP_LVL;
                for (var i = 1; i < percentColors.length - 1; i++) {
                    if (pct < percentColors[i].pct) {
                        break;
                    }
                }
                var lower = percentColors[i - 1];
                var upper = percentColors[i];
                var range = upper.pct - lower.pct;
                var rangePct = (pct - lower.pct) / range;
                var pctLower = 1 - rangePct;
                var pctUpper = rangePct;
                var color = {
                    r: Math.floor(lower.color.r * pctLower + upper.color.r * pctUpper)/255,
                    g: Math.floor(lower.color.g * pctLower + upper.color.g * pctUpper)/255,
                    b: Math.floor(lower.color.b * pctLower + upper.color.b * pctUpper)/255
                };
                return new THREE.Color().setRGB(color.r, color.g, color.b);
            }
            
            function init_new_window_SNP_CHIP_SEQ (intersectPoint, isPlaneMode) {
                if (isPlaneMode) {
                    var _rgn = intersectPoint;
                    var chrid = String(_rgn[0]);
                    // console.log(chrid);
                    var chridNoStrand = chrid.split('_')[0];
                    var chridOnlyNumber = chrid.replace(/([\dXYxy]+).*/, "$1");
                    // var chridNoStrand = chrid.substr(0, chrid.length - 2);
                    // var chridOnlyNumber = chridNoStrand;
                    if (chridOnlyNumber[chridOnlyNumber.length - 1] == "a") {
                        chridOnlyNumber = chridOnlyNumber.substr(0, chridOnlyNumber.length - 1);
                    }
                    snp_chip_seq_window = window.open("index2.html?isplane="+isPlaneMode+"&chr=" + chridOnlyNumber.replace("23", 'x') 
                              + "&start=" + String(Math.floor(_rgn[1]))
                              + "&end=" + String(Math.floor(_rgn[2]))      
                            /*+ "&celline="+ current_cell_line*/, //parameter of celline - will be hardcoded in the index2.html , top=500
                              "_blank", "scrollbars=yes, resizable=yes, top=500, left=500, width=400, height=400");
                    return;
                } else {
                    var intersectInModelCoordinates = Local2global(intersectPoint);
                    globalArrayForWindow = searchOctree();
                    var result = '';
                    for (var indx in globalArrayForWindow) {
                        result += globalArrayForWindow[indx].chr.replace("23", 'x') + "-" + ((globalArrayForWindow[indx].helix)?globalArrayForWindow[indx].helix : "null" )+ ":";
                        for (var indx2 in globalArrayForWindow[indx].intervals) {
                            result += Math.floor(globalArrayForWindow[indx].intervals[indx2].start) + "_" + Math.floor(globalArrayForWindow[indx].intervals[indx2].end) + "-";
                        }
                        result += ";";
                    }
                    var radiusSphereGlobal = radiusSphere/scaleFactor;
                    snp_chip_seq_window = window.open("index2.html?isplane="+isPlaneMode+"&path=" + result
                       , //parameter of celline - will be hardcoded in the index2.html , top=500
                              "_blank", "scrollbars=yes, resizable=yes, top=500, left=500, width=400, height=400");
                    return;    
                }
            }


            
            var chrid2color = {};
            
			// the pointerLock object has different name in different browsers
			// http://www.html5rocks.com/en/tutorials/pointerlock/intro/
            var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;
            if ( havePointerLock ) {
            	init_controls();
            } else {
            	instructions.innerHTML = "Your browser doesn\'t seem to support Pointer Lock API<br/>Supported browsers: Firefox, Google Chrome.";
            }
            init();
            animate();
            
            function init_light() {
                    var light = new THREE.DirectionalLight( 0xffffff, 1.5 );
                    light.position.set( 1, 1, 1 );
                    scene.add( light );
                    var light = new THREE.DirectionalLight( 0xffffff, 0.75 );
                    light.position.set( -1, - 0.5, -1 );
                    scene.add( light );
            }
            
            function draw_low_resolution_model() {
                    // loading 3d-model
					// data - is an array of arrays, each array is a sequence of points of a DNA molecule
					// each point is represented with 4 numbers: base_index, x,y,z
					var color = new THREE.Color().setHSL( Math.random(),  Math.random(),  Math.random());
					for (var chr_index = 0; chr_index < data.length; ++chr_index) {
						chr_data = data[chr_index];
						var CELL_SIZE = 4;
						points_count = chr_data.length / CELL_SIZE; 
						
						var tube_color = new THREE.Color().setHSL( Math.random(),  Math.random(),  Math.random());
						var material = new THREE.MeshBasicMaterial({
								color: tube_color,
								opacity: 1,
								wireframe: true,
								transparent: false
						});
						var spline_points = [];
						for (var point_index = 0; point_index < points_count; ++point_index) {
							x = chr_data[(point_index) * CELL_SIZE];
							y = chr_data[(point_index) * CELL_SIZE + 1];
							z = chr_data[(point_index) * CELL_SIZE + 2];	
							spline_points.push(new THREE.Vector3(x, y, z));									

						}
						var spline = new THREE.SplineCurve3(spline_points);
						var segments = points_count * 2;
						var radiusSegments =  4;
						var tube = new THREE.TubeGeometry(spline, segments, 1, radiusSegments, false, false);
						tube.dynamic = true;
						tubeMesh = new THREE.Mesh(tube, material);							
						scene.add(tubeMesh);
						objects.push(tubeMesh);
                    }            	
            }
            
            //probably trash
            function InitSelectionMesh() {
				var spline = new THREE.SplineCurve3([new THREE.Vector3(0, 0, 0), new THREE.Vector3(100, 100, 100),]);
				var material = new THREE.LineBasicMaterial({color: 0xff0000});
				var segments = 10;
				var radiusSegments = 6;
				var tube = new THREE.TubeGeometry(spline, segments, 20, radiusSegments, false, false);
				tube.dynamic = true;
				tube.verticesNeedUpdate = true;
				selectionMesh = new THREE.Mesh(tube, material);
				selectionMesh.name = "selection_mesh";
                test_mesh = selectionMesh;
				scene.add(selectionMesh);          	
            }
            
            function UpdateTargetBallPosition() {
				var vector = new THREE.Vector3(0, 0, 0);
				var raycaster = projector.pickingRay(vector, camera);
				raycaster.ray.direction.normalize().multiplyScalar(50);
				var x = raycaster.ray.direction.x + raycaster.ray.origin.x;
				var y = raycaster.ray.direction.y + raycaster.ray.origin.y;
				var z = raycaster.ray.direction.z + raycaster.ray.origin.z;
				targetBall.position.set(x,  y, z);
				targetBall.geometry.verticesNeedUpdate = true;
				scene.remove(targetBall);   	
				scene.add(targetBall); 
            }
            
            function InitTargetBall() {
            	var sphere = new THREE.SphereGeometry(0.5, 10, 10);
            	sphere.dynamic = true;
            	targetBall = new THREE.Mesh(sphere, new THREE.LineBasicMaterial({color: 0xff0000}));
				targetBall.name = "target_ball";            	
				UpdateTargetBallPosition();						          	
            }
                                                     
            function getPositionRangeFromCubeIntersection(meshesSearch) {
                var resultSet = [];
                var verts;
                
                var mentionedMeshes = [];
                var name, aLen;
                var chr, helix;
                var tempObject;
                for (var _mesh in meshesSearch) {
                    name = meshesSearch[_mesh].object.name;

                    if (mentionedMeshes != null && ($.inArray(name, mentionedMeshes) != -1)) {
                        continue;
                    }
                    mentionedMeshes.push(name);
                    tempObject = [];

                    //proportional calculations
                    verts = meshesSearch[_mesh].object.geometry.vertices;
                    aLen = verts.length;
                    chr = (name.replace(regexpPatternURL, "$1"));
                    // helix = (name.replace(regexpPatternURL, "$2"));

                    var minDistance = -1;
                    var secMinDistance = -1;
                    var closestPoint = -1;
                    var secClosestPoint = -1;
                    var distance = -1;
                    var distBetweenNodes = -1;
                    var closestPointInSpehere = -1;
                    var closestPointVertInSphere, closestPointVert;
                    var verts_point = intersection.point;
                    var koef = 0;
                    var aStartVector = -1;
                    var aEndVector = -1;
                    var possibleSolutions = [];
                    var countPossibleSolutions = 0;

                    for (var _v = 0; _v < aLen; _v = findNextNotGroupedPoint(verts, _v)) {
                        distance = Math.pow(verts[_v].x - verts_point.x,2) + 
                                Math.pow(verts[_v].y - verts_point.y,2) + 
                                Math.pow(verts[_v].z - verts_point.z,2);

                        if (minDistance == -1 || ( distance < minDistance ))  {
                            if ( distance > 2 * radiusSphere * radiusSphere ) { //sqrt(2)
                                
                                secClosestPoint = closestPoint;
                                secMinDistance = minDistance;
                                closestPoint = _v;
                                minDistance = distance;
                                possibleSolutions[countPossibleSolutions] = {closestPoint: closestPoint, minDistance: minDistance, secClosestPoint: secClosestPoint, secMinDistance: secMinDistance};
                            }

                        } else if ( minDistance > 0 && distance < 16 * radiusSphere * radiusSphere && distance > minDistance ) {
                            if (possibleSolutions[countPossibleSolutions]) countPossibleSolutions++;
                            minDistance = distance;
                            closestPoint = _v;
                            secClosestPoint = -1;
                            secMinDistance = -1;
                        }
                    }

                    if (minDistance == -1) { //everything in the selection area - as there should be at least something in the minDistance after the end of the loop
                        var trackPoints = uploaded_splines[name][1];
                        var objStart = getPointPositionInChr(trackPoints, 0, verts[0]);
                        var objEnd = getPointPositionInChr(trackPoints, objStart.firstPoint, verts[verts.length-1]);

                        tempObject.push({start: objStart, end: objEnd});
                        
                        if (tempObject.length != 0)
                            resultSet.push({chr: chr, intervals: tempObject, size: tempObject.length, helix: helix});
                        continue;
                    }


                    for (var tempObj in possibleSolutions) {
                        minDistance = possibleSolutions[tempObj].minDistance;
                        closestPoint = possibleSolutions[tempObj].closestPoint;
                        secMinDistance = possibleSolutions[tempObj].secMinDistance;
                        secClosestPoint = possibleSolutions[tempObj].secClosestPoint;
                        //for every possible solution - start from null
                        aStartVector = -1; 
                        aEndVector = -1;

                        // set up the secClosestPoint for complete algorithm
                        if (secClosestPoint == -1) {
                            if (closestPoint == 0) {
                                secClosestPoint = closestPoint;
                                secMinDistance = minDistance;
                                minDistance = -1;
                                for (var indx = findNextNotGroupedPoint(verts, secClosestPoint); indx < aLen; indx = findNextNotGroupedPoint(verts, indx)) {
                                    distance = Math.pow(verts[indx].x - verts_point.x,2) + 
                                        Math.pow(verts[indx].y - verts_point.y,2) + 
                                        Math.pow(verts[indx].z - verts_point.z,2);
                            
                                    if (minDistance == -1 || ( distance < minDistance && distance > 2 * radiusSphere * radiusSphere))  { //sqrt(2)
                                        closestPoint = indx;
                                        minDistance = distance;
                                        break;
                                    } 
                                }
                                if (minDistance == -1) {
                                    aEndVector = verts[verts.length-1];
                                } 
                            } else {
                                aStartVector = verts[0];
                            }
                        }

                        //check - if this possible solution is the solution undeed
                        var nextPoint = -1;
                        var nextPointDistance = -1;
                        var isThereSomethingInSphere = false;
                        //---secClosestPoint------.?.----closestpoint-----.?.-----nextPoint-------------> (strand ++)
                        for (var indx = findNextNotGroupedPoint(verts, closestPoint); indx < aLen; indx = findNextNotGroupedPoint(verts, indx)) {
                            distance = Math.pow(verts[indx].x - verts_point.x,2) + 
                                Math.pow(verts[indx].y - verts_point.y,2) + 
                                Math.pow(verts[indx].z - verts_point.z,2);
                            if ( distance > 2 * radiusSphere * radiusSphere ) { //sqrt(2)
                                nextPoint = indx;
                                nextPointDistance = distance;
                                break;
                            } else {
                                isThereSomethingInSphere = true; //if nextPoint will be found - we shouldn't check anything after - use nextPoint as closestPoint and current closestPoint as secClosestPoint
                            }
                        }

                        if (isThereSomethingInSphere) {
                            secClosestPoint = closestPoint;
                            secMinDistance = minDistance;
                            closestPoint = nextPoint;
                            minDistance = nextPointDistance;
                        } else {

                            //check median of the line between two points : if it is located in the radius area
                            distance = Math.pow((verts[closestPoint].x + verts[nextPoint].x)/2 - verts_point.x,2) + 
                                Math.pow((verts[closestPoint].y + verts[nextPoint].y)/2 - verts_point.y,2) + 
                                Math.pow((verts[closestPoint].z + verts[nextPoint].z)/2 - verts_point.z,2);

                            if ( distance < 2 * radiusSphere * radiusSphere ) { //sqrt(2) - must be here as corners of cube!!!
                                secClosestPoint = closestPoint;
                                secMinDistance = minDistance;
                                closestPoint = nextPoint;
                                minDistance = nextPointDistance;
                            } else {

                                distance = Math.pow((verts[closestPoint].x + verts[secClosestPoint].x)/2 - verts_point.x,2) + 
                                    Math.pow((verts[closestPoint].y + verts[secClosestPoint].y)/2 - verts_point.y,2) + 
                                    Math.pow((verts[closestPoint].z + verts[secClosestPoint].z)/2 - verts_point.z,2);
                                if ( distance < 2 * radiusSphere * radiusSphere ) { //sqrt(2) - must be here as corners of cube!!!
                                    //everything is ok, let's move on to the next stage
                                } else {
                                    continue; // that means that this is pseudo solution with *great probability*
                                }
                            }
                        }

                        //DO NOT CHANGE ANYTHING IN THIS BLOCK WITHOUT UNDERSTANDING!!!

                        //=======================BEGIN==================

                        distBetweenNodes = Math.pow(verts[closestPoint].x - verts[secClosestPoint].x, 2) + 
                                    Math.pow(verts[closestPoint].y - verts[secClosestPoint].y, 2) +
                                    Math.pow(verts[closestPoint].z - verts[secClosestPoint].z, 2);
                    
                        /* 1st case:  2---[---x---]-1       */
                        if (findNextNotGroupedPoint(verts,secClosestPoint) != closestPoint ) { //there are points in the sphere area
                            console.log("/* 1st case:  2---[---x---]-1       */");
                            if (aStartVector == -1) {
                                /*for begins*/
                                closestPointInSpehere = findNextNotGroupedPoint(verts,secClosestPoint);

                                distance = Math.pow(verts[closestPointInSpehere].x - verts_point.x,2) + 
                                        Math.pow(verts[closestPointInSpehere].y - verts_point.y,2) + 
                                        Math.pow(verts[closestPointInSpehere].z - verts_point.z,2);

                                distBetweenNodes = Math.pow(verts[secClosestPoint].x - verts[closestPointInSpehere].x, 2) + 
                                            Math.pow(verts[secClosestPoint].y - verts[closestPointInSpehere].y, 2) +
                                            Math.pow(verts[secClosestPoint].z - verts[closestPointInSpehere].z, 2);

                                if (distBetweenNodes > secMinDistance) {
                                    //using intersection point
                                    closestPointVert = verts[secClosestPoint];
                                    koef = radiusSphere/Math.sqrt(secMinDistance/2); //sqrt(2) - as we should cover corners of cube
                                    aStartVector = new THREE.Vector3(verts_point.x + (closestPointVert.x-verts_point.x)*koef, 
                                        verts_point.y + (closestPointVert.y-verts_point.y)*koef, 
                                            verts_point.z + (closestPointVert.z-verts_point.z)*koef)
                                } else {
                                    //using intermediate point
                                    closestPointVert = verts[secClosestPoint];
                                    closestPointVertInSphere = verts[closestPointInSpehere];
                                    koef = (radiusSphere * Math.sqrt(2) - Math.sqrt(distance)) / Math.sqrt(distBetweenNodes); //sqrt(2) - as we should cover corners of cube
                                    aStartVector = new THREE.Vector3(closestPointVertInSphere.x + (closestPointVert.x-closestPointVertInSphere.x)*koef, 
                                        closestPointVertInSphere.y + (closestPointVert.y-closestPointVertInSphere.y)*koef, 
                                            closestPointVertInSphere.z + (closestPointVert.z-closestPointVertInSphere.z)*koef)
                                }
                            }
                            
                            if (aEndVector == -1) {
                                /*for ends*/
                                closestPointInSpehere = findPreviousNotGroupedPoint(verts, closestPoint);

                                distance = Math.pow(verts[closestPointInSpehere].x - verts_point.x,2) + 
                                        Math.pow(verts[closestPointInSpehere].y - verts_point.y,2) + 
                                        Math.pow(verts[closestPointInSpehere].z - verts_point.z,2);

                                distBetweenNodes = Math.pow(verts[closestPoint].x - verts[closestPointInSpehere].x, 2) + 
                                            Math.pow(verts[closestPoint].y - verts[closestPointInSpehere].y, 2) +
                                            Math.pow(verts[closestPoint].z - verts[closestPointInSpehere].z, 2);

                                if (distBetweenNodes > minDistance) {
                                    //using intersection point
                                    closestPointVert = verts[closestPoint];
                                    koef = radiusSphere/Math.sqrt(minDistance/2); //sqrt(2) - as we should cover corners of cube
                                    aEndVector = new THREE.Vector3(verts_point.x + (closestPointVert.x-verts_point.x)*koef, 
                                        verts_point.y + (closestPointVert.y-verts_point.y)*koef, 
                                            verts_point.z + (closestPointVert.z-verts_point.z)*koef)
                                } else {
                                    //using intermediate point
                                    closestPointVert = verts[closestPoint];
                                    closestPointVertInSphere = verts[closestPointInSpehere];
                                    koef = (radiusSphere* Math.sqrt(2) - Math.sqrt(distance)) / Math.sqrt(distBetweenNodes); //sqrt(2) - as we should cover corners of cube
                                    aEndVector = new THREE.Vector3(closestPointVertInSphere.x + (closestPointVert.x-closestPointVertInSphere.x)*koef, 
                                        closestPointVertInSphere.y + (closestPointVert.y-closestPointVertInSphere.y)*koef, 
                                            closestPointVertInSphere.z + (closestPointVert.z-closestPointVertInSphere.z)*koef)
                                }
                            }
                        } else if ( findNextNotGroupedPoint(verts, secClosestPoint) == closestPoint 
                                        && distBetweenNodes >= secMinDistance /*condition - on different sides from interaction point*/ ) { //there are no points in the sphere area
                            if (aStartVector == -1) {
                            /*for begins*/
                                //using intersection point
                                closestPointVert = verts[secClosestPoint];
                                koef = radiusSphere/Math.sqrt(secMinDistance / 2); //sqrt(2) - as we should cover corners of cube
                                aStartVector = new THREE.Vector3(verts_point.x + (closestPointVert.x-verts_point.x)*koef, 
                                    verts_point.y + (closestPointVert.y-verts_point.y)*koef, 
                                        verts_point.z + (closestPointVert.z-verts_point.z)*koef);
                            }

                            if (aEndVector == -1) {
                            /*for ends*/
                                //using intersection point
                                closestPointVert = verts[closestPoint];
                                koef = radiusSphere/Math.sqrt(minDistance / 2); //sqrt(2) - as we should cover corners of cube
                                aEndVector = new THREE.Vector3(verts_point.x + (closestPointVert.x-verts_point.x)*koef, 
                                    verts_point.y + (closestPointVert.y-verts_point.y)*koef, 
                                        verts_point.z + (closestPointVert.z-verts_point.z)*koef);
                            }

                        } else if (secMinDistance > distBetweenNodes) { /* 2nd case:  2--1--[---x---]---    */
                            
                            console.log("/* 2nd case:  2--1--[---x---]---    */");
                            console.log(secMinDistance+ ">" + distBetweenNodes + " | " + aStartVector +  " | " +  aEndVector + " [" + secClosestPoint + " |||" + closestPoint + "]");
                            var tempPoint = findNextNotGroupedPoint(verts, closestPoint);

                            distance = Math.pow(verts[tempPoint].x - verts_point.x,2) + 
                                    Math.pow(verts[tempPoint].y - verts_point.y,2) + 
                                    Math.pow(verts[tempPoint].z - verts_point.z,2);


                            if (distance < 2 * Math.pow(radiusSphere,2)) {
                                /*for begins*/
                                closestPointInSpehere = tempPoint;

                                distBetweenNodes = Math.pow(verts[closestPoint].x - verts[closestPointInSpehere].x, 2) + 
                                            Math.pow(verts[closestPoint].y - verts[closestPointInSpehere].y, 2) +
                                            Math.pow(verts[closestPoint].z - verts[closestPointInSpehere].z, 2);

                                if (aStartVector == -1) {
                                    if (distBetweenNodes > minDistance) {
                                        //using intersection point
                                        closestPointVert = verts[closestPoint];
                                        koef = radiusSphere / Math.sqrt(minDistance/2); //sqrt(2) - as we should cover corners of cube
                                        aStartVector = new THREE.Vector3(verts_point.x + (closestPointVert.x-verts_point.x)*koef, 
                                            verts_point.y + (closestPointVert.y-verts_point.y)*koef, 
                                                verts_point.z + (closestPointVert.z-verts_point.z)*koef)
                                    } else {
                                        //using intermediate point
                                        closestPointVert = verts[closestPoint];
                                        closestPointVertInSphere = verts[closestPointInSpehere];
                                        koef = (radiusSphere*Math.sqrt(2) - Math.sqrt(distance)) / Math.sqrt(distBetweenNodes); //sqrt(2) - as we should cover corners of cube
                                        aStartVector = new THREE.Vector3(closestPointVertInSphere.x + (closestPointVert.x-closestPointVertInSphere.x)*koef, 
                                            closestPointVertInSphere.y + (closestPointVert.y-closestPointVertInSphere.y)*koef, 
                                                closestPointVertInSphere.z + (closestPointVert.z-closestPointVertInSphere.z)*koef)
                                    }
                                }

                                /*for ends*/
                                minDistance = -1;
                                for (var indx = findNextNotGroupedPoint(verts, closestPointInSpehere); indx < verts.length; indx = findNextNotGroupedPoint(verts, indx)) {
                                    distance = Math.pow(verts[indx].x - verts_point.x,2) + 
                                        Math.pow(verts[indx].y - verts_point.y,2) + 
                                        Math.pow(verts[indx].z - verts_point.z,2);
                                        
                                    if (minDistance == -1 || ( distance < minDistance && distance > 2 * radiusSphere * radiusSphere))  { //sqrt(2)
                                        closestPoint = indx;
                                        minDistance = distance;
                                        break;
                                    }
                                }

                                if (closestPoint == -1) {
                                    aEndVector = verts[aLen-1]
                                } else if (aEndVector == -1) {
                                    /*for ends*/
                                    closestPointInSpehere = findPreviousNotGroupedPoint(verts, closestPoint);

                                    distance = Math.pow(verts[closestPointInSpehere].x - verts_point.x,2) + 
                                            Math.pow(verts[closestPointInSpehere].y - verts_point.y,2) + 
                                            Math.pow(verts[closestPointInSpehere].z - verts_point.z,2);

                                    distBetweenNodes = Math.pow(verts[closestPoint].x - verts[closestPointInSpehere].x, 2) + 
                                                Math.pow(verts[closestPoint].y - verts[closestPointInSpehere].y, 2) +
                                                Math.pow(verts[closestPoint].z - verts[closestPointInSpehere].z, 2);

                                    if (distBetweenNodes > minDistance) {
                                        //using intersection point
                                        closestPointVert = verts[closestPoint];
                                        koef = radiusSphere/Math.sqrt(minDistance/2); //sqrt(2) - as we should cover corners of cube
                                        aEndVector = new THREE.Vector3(verts_point.x + (closestPointVert.x-verts_point.x)*koef, 
                                            verts_point.y + (closestPointVert.y-verts_point.y)*koef, 
                                                verts_point.z + (closestPointVert.z-verts_point.z)*koef)
                                    } else {
                                        //using intermediate point
                                        closestPointVert = verts[closestPoint];
                                        closestPointVertInSphere = verts[closestPointInSpehere];
                                        koef = (radiusSphere*Math.sqrt(2) - Math.sqrt(distance)) / Math.sqrt(distBetweenNodes); //sqrt(2) - as we should cover corners of cube
                                        aEndVector = new THREE.Vector3(closestPointVertInSphere.x + (closestPointVert.x-closestPointVertInSphere.x)*koef, 
                                            closestPointVertInSphere.y + (closestPointVert.y-closestPointVertInSphere.y)*koef, 
                                                closestPointVertInSphere.z + (closestPointVert.z-closestPointVertInSphere.z)*koef)
                                    }
                                }
                            } else {
                                //tempPoint - this is the next point out of the sphere
                                secClosestPoint = closestPoint;
                                closestPoint = tempPoint;
                                secMinDistance = minDistance;
                                minDistance = distance;
                                if (aStartVector == -1) {
                                    /*for begins*/
                                    //using intersection point
                                    closestPointVert = verts[secClosestPoint];
                                    koef = radiusSphere/Math.sqrt(secMinDistance/2); //sqrt(2) - as we should cover corners of cube
                                    aStartVector = new THREE.Vector3(verts_point.x + (closestPointVert.x-verts_point.x)*koef, 
                                        verts_point.y + (closestPointVert.y-verts_point.y)*koef, 
                                            verts_point.z + (closestPointVert.z-verts_point.z)*koef);
                                }

                                if (aEndVector == -1) {
                                    /*for ends*/
                                    //using intersection point
                                    closestPointVert = verts[closestPoint];
                                    koef = radiusSphere/Math.sqrt(minDistance/2); //sqrt(2) - as we should cover corners of cube
                                    aEndVector = new THREE.Vector3(verts_point.x + (closestPointVert.x-verts_point.x)*koef, 
                                        verts_point.y + (closestPointVert.y-verts_point.y)*koef, 
                                            verts_point.z + (closestPointVert.z-verts_point.z)*koef);
                                }
                            } 
                        }
                        var trackPoints = uploaded_splines[name][1];
                        var objStart = getPointPositionInChr(trackPoints, 0, aStartVector);
                        var objEnd = getPointPositionInChr(trackPoints, objStart.firstPoint, aEndVector);
                        
                        if (objStart.position == objEnd.position) {
                            tempObject.push({start: objStart.position-50, end: objEnd.position+50});//show the minimum block
                        } else {
                            tempObject.push({start: objStart.position, end: objEnd.position});    
                        }
//===============================END=============================
                    }
                    if (tempObject.length != 0)
                            resultSet.push({chr: chr, intervals: tempObject, size: tempObject.length, helix: helix});
                }
                return resultSet;
            }


            function findNextNotGroupedPoint(verts, startPointIndex) {
                var NEGL_DISTANCE = 400; //based on the tubes width (10*2) * (10*2)
                var distBetweenNodes = -1;
                for (var _v = startPointIndex+1; _v < verts.length; _v++) {
                    if (verts[_v] === 'undefined') continue;
                        distBetweenNodes = Math.pow(verts[startPointIndex].x - verts[_v].x, 2) + 
                                            Math.pow(verts[startPointIndex].y - verts[_v].y, 2) +
                                            Math.pow(verts[startPointIndex].z - verts[_v].z, 2);
                        if (distBetweenNodes > NEGL_DISTANCE) {
                            return _v;
                        }
                }
                return verts.length;
            }

            function findPreviousNotGroupedPoint(verts, startPointIndex) {
                var NEGL_DISTANCE = 400; //based on the tubes width (10*2) * (10*2)
                var distBetweenNodes = -1;
                for (var _v = startPointIndex-1; _v >= 0; _v--) {
                        distBetweenNodes = Math.pow(verts[startPointIndex].x - verts[_v].x, 2) + 
                                            Math.pow(verts[startPointIndex].y - verts[_v].y, 2) +
                                            Math.pow(verts[startPointIndex].z - verts[_v].z, 2);
                        if (distBetweenNodes > NEGL_DISTANCE) {
                            return _v;
                        }
                }
                return -1;
            }

            function getPointPositionInChr(trackPoints, startPointIndex, local_verts_point) {
                var verts_point = Local2global(local_verts_point);
                var closestPoint = -1;
                var minDistance = -1;
                var secClosestPoint = -1;
                var secMinDistance = -1;
                var distBetweenNodes = -1;
                for (var pointIndex = startPointIndex; pointIndex < trackPoints.length; ++pointIndex) {
                    var x = trackPoints[pointIndex][2];
                    var y = trackPoints[pointIndex][3];
                    var z = trackPoints[pointIndex][4];

                    var distance = Math.pow(verts_point.x - x, 2) + 
                                    Math.pow(verts_point.y - y, 2) +
                                    Math.pow(verts_point.z - z, 2);
                    if (minDistance == -1 || distance < minDistance) {
                        if (pointIndex - closestPoint == 1) {
                            secMinDistance = minDistance;
                            secClosestPoint = closestPoint;    
                        } else {
                            secMinDistance = -1;
                            secClosestPoint = -1;
                        }
                        minDistance = distance;
                        closestPoint = pointIndex;
                    }
                }
                
                console.log("Alll: startPointIndex = " + startPointIndex + " :: " + secClosestPoint + " ["+"] ||| " + closestPoint + " []");
                
                if (secClosestPoint == -1) {
                    if (closestPoint != startPointIndex) {
                        secClosestPoint = closestPoint-1;
                        secMinDistance = Math.pow(verts_point.x - trackPoints[secClosestPoint][2], 2) + 
                                    Math.pow(verts_point.y - trackPoints[secClosestPoint][3], 2) +
                                    Math.pow(verts_point.z - trackPoints[secClosestPoint][4], 2); 
                    } else {
                        secClosestPoint = closestPoint;
                        secMinDistance = minDistance;
                        closestPoint = closestPoint + 1;
                        minDistance = Math.pow(verts_point.x - trackPoints[secClosestPoint][2], 2) + 
                                    Math.pow(verts_point.y - trackPoints[secClosestPoint][3], 2) +
                                    Math.pow(verts_point.z - trackPoints[secClosestPoint][4], 2); 
                    }
                } 

                distBetweenNodes = Math.pow(trackPoints[closestPoint][2] - trackPoints[secClosestPoint][2], 2) + 
                                    Math.pow(trackPoints[closestPoint][3] - trackPoints[secClosestPoint][3], 2) +
                                    Math.pow(trackPoints[closestPoint][4] - trackPoints[secClosestPoint][4], 2);

                if (secMinDistance>=distBetweenNodes) { // v---x------x
                    closestPoint = closestPoint+1;
                    secClosestPoint = secClosestPoint+1;
                    secMinDistance = minDistance;
                    minDistance = Math.pow(verts_point.x - trackPoints[closestPoint][2], 2) + 
                                    Math.pow(verts_point.y - trackPoints[closestPoint][3], 2) +
                                    Math.pow(verts_point.z - trackPoints[closestPoint][4], 2); 
                }

                // x----v-----------x
                //console.log(trackPoints[closestPoint][1] + "|||" + trackPoints[secClosestPoint][1]);
                 console.log("Alll: startPointIndex = " + startPointIndex + " :: " + secClosestPoint + " ["+trackPoints[secClosestPoint][1]+"] ||| " + closestPoint + " ["+trackPoints[closestPoint][1]+"]");
//                return {position: Math.floor((Math.sqrt(secMinDistance)*trackPoints[closestPoint][1] + Math.sqrt(minDistance)*trackPoints[secClosestPoint][1])/(Math.sqrt(secMinDistance)+Math.sqrt(minDistance))), firstPoint: secClosestPoint};
                
                return {position: Math.floor((trackPoints[secClosestPoint][1]*minDistance + trackPoints[closestPoint][1]*secMinDistance) / (minDistance+secMinDistance)), firstPoint: secClosestPoint};
            }
            
            //2 x 1 -> (2)+((1)-(2))*2x/(2x+1x) = [(2)*(2x+1x) + ((1)-(2))*2x]/(2x+1x) = [(2)*1x + (1)*2x]/(2x+1x)
            
            
            function searchOctree() {
                var tempInt = GetIntersection();

                if (tempInt == null) return;
                console.log("call searchOctree()");
                intersectionImpl = tempInt.point;
                var rayCaster = new THREE.Raycaster( new THREE.Vector3().copy( intersectionImpl ), new THREE.Vector3(0,0,radiusSphere).normalize() );
                // var radiusSearch = radiusSphere;
                var meshesSearch = octree.search( rayCaster.ray.origin, radiusSphere, true, rayCaster.ray.direction ); 
                // intersections = rayCaster.intersectOctreeObjects( meshesSearch, true);
                return getPositionRangeFromCubeIntersection(meshesSearch);
            }
			
            function init() {
                    Object.size = function(obj) {
                        var size = 0, key;
                        for (key in obj) {
                            if (obj.hasOwnProperty(key)) size++;
                        }
                        return size;
                    };
            		scene = new THREE.Scene();
					camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 100000 );
                    controls = new THREE.PointerLockControls( camera );
                    scene.add( controls.getObject() );

					//scene.fog = new THREE.Fog( 0xffffff, 0, blockSize * scaleFactor );
					init_light(scene);    
                    //draw_low_resolution_model();
                  
                    renderer = new THREE.WebGLRenderer();
                    renderer.setClearColor( 0xffffff );
                    renderer.setSize( window.innerWidth, window.innerHeight );
                    
                    InitSelectionMesh();
                    InitTargetBall();

                    // create octree
                    octree = new THREE.Octree( {
                      undeferred: false,
                      depthMax: Infinity,
                      objectsThreshold: 8,
                      overlapPct: 0.15
                       // ,
                       // scene: scene
                    } );

                    divElement = document.getElementById("tabs-1");
                    

                    divElement.appendChild( renderer.domElement );

                    // document.body.appendChild( renderer.domElement );
                    window.addEventListener( 'resize', onWindowResize, false );   
                    
            }

            function onWindowResize() {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize( window.innerWidth, window.innerHeight );
                    document.getElementById("blocker").style.top = String($("ul.ui-tabs-nav").height()+27) + "px";
                    mod_message_div.style.bottom = String(infoBlock.clientHeight) + "px";
                    if (typeof $("div#detection-sign").style != 'undefined')
                        $("div#detection-sign").style.bottom = String(infoBlock.clientHeight) + "px";
            }
            
            function Local2global(coordinates) {
            	return {x :  zeroCoordinate.x + coordinates.x / scaleFactor, 
            		    y : zeroCoordinate.y + coordinates.y / scaleFactor, 
            		    z : zeroCoordinate.z + coordinates.z / scaleFactor };
            }
            function Global2local(coordinates) {
            	return {x :  (coordinates.x - zeroCoordinate.x) * scaleFactor, 
            		    y :  (coordinates.y - zeroCoordinate.y) * scaleFactor, 
            		    z :  (coordinates.z - zeroCoordinate.z) * scaleFactor };
            }    

            function Local2globalVector3(coordinates) {
                return new THREE.Vector3(zeroCoordinate.x + coordinates.x / scaleFactor, zeroCoordinate.y + coordinates.y / scaleFactor, zeroCoordinate.z + coordinates.z / scaleFactor);
            }

            function Global2localVector3(coordinates) {
                return new THREE.Vector3((coordinates.x - zeroCoordinate.x) * scaleFactor, (coordinates.y - zeroCoordinate.y) * scaleFactor, (coordinates.z - zeroCoordinate.z) * scaleFactor);
            }
            
            function GenerateColor() {
            	mix = [0.8, 0.8, 0.8];
			    var red = Math.random();
			    var green = Math.random();
			    var blue = Math.random();
			    // mix the color
			    red = (red + mix[0]) / 2;
			    green = (green + mix[1]) / 2;
			    blue = (blue + mix[2]) / 2;
			    return new THREE.Color().setRGB(red, green, blue);
            }
            
            function DrawSNPs(positions, track_points) {
            	var track_points_position = 0;
            	for (var point_index = 0; point_index < positions.length; ++point_index) {
            		var base_index = positions[point_index][0];
            		var snp_id = String(positions[point_index][1]);
            		while (track_points_position < track_points.length && track_points[track_points_position][1] <=  base_index) {
            			++track_points_position;
            		}
            		if (track_points_position > 0 && track_points_position < track_points.length) {
            			var prev_base_index = track_points[track_points_position - 1][1];
            			var curr_base_index = track_points[track_points_position][1];
            			var coefficient = (base_index - prev_base_index) / (curr_base_index - prev_base_index);
            			var x = (1 - coefficient) * track_points[track_points_position - 1][2] + coefficient * track_points[track_points_position][2];
            			var y = (1 - coefficient) * track_points[track_points_position - 1][3] + coefficient * track_points[track_points_position][3];
            			var z = (1 - coefficient) * track_points[track_points_position - 1][4] + coefficient * track_points[track_points_position][4];
            			var localCoords = Global2local({ x: x, y : y, z : z });
		            	var sphere = new THREE.SphereGeometry(12, 10, 10);
		            	var snp_ball = new THREE.Mesh(sphere, new THREE.LineBasicMaterial({color: 0xff0000}));
						snp_ball.name = "rs" + snp_id;            	
						snp_ball.position.set(localCoords.x,  localCoords.y, localCoords.z);
						scene.add(snp_ball);
            		}
            	}
            }
            
            function UploadRegionSNP(chr, track_points) {
        		var request = "chr=" + ((chr==='23')?'X':chr) + "&start=" + String(Math.floor(track_points[0][1])) +
        						 "&end=" + String(Math.floor(track_points[track_points.length - 1][1])); 
			    var url = "http://1kgenome.exascale.info/js_snp?" + request;
			    $.getJSON(url + "?callback=?", null, 
			    	function(positions) {
			    		DrawSNPs(positions, track_points);
			    	}
			    ); 	
            }
            
            function UploadSNP(new_model_points) {
            	var new_tracks = new_model_points["data"];
            	var longest = -1;
            	var length = 0;
            	for (var track_index = 0; track_index < new_tracks.length; ++track_index) {
            		var track_points = new_tracks[track_index][1];
            		if (track_points.length > length) {
            			longest = track_index;
            			length = track_points.length;
            		}
            	}
            	for (var track_index = longest; track_index < longest + 1; ++track_index) {
            		var chrid = new_tracks[track_index][0];
            		var chridNoStrand = chrid.substr(0, chrid.length - 2);
            		var chridOnlyNumber = chridNoStrand;
            		if (chridOnlyNumber[chridOnlyNumber.length - 1] == "a") {
            			chridOnlyNumber = chridOnlyNumber.substr(0, chridOnlyNumber.length - 1);
            		}
            		var track_points = new_tracks[track_index][1];
            		UploadRegionSNP(chridOnlyNumber, track_points);
				}
            }
                        
            
            function DrawPoints(model_points, blockIndicesStr, blockIndices) {
            	new_tracks = model_points["data"];
            	
            	for (var track_index = 0; track_index < new_tracks.length; ++track_index) {
            		chrid = new_tracks[track_index][0];
//            		chridNoStrand = chrid.substr(0, chrid.length - 2);  // not universal
                    chridNoStrand = chrid.split('_')[0];
                    var chridOnlyNum = chrid.replace(/([\d]+).*/, "$1");
            		if (!chrid2color[chridNoStrand]) {
            			//chrid2color[chridNoStrand] = new THREE.Color().setHSL( Math.random(),  Math.random(),  Math.random());
            			chrid2color[chridNoStrand] = GenerateColor();
            		}
            		track_points = new_tracks[track_index][1];
					var tube_color = chrid2color[chridNoStrand];
					var material = new THREE.MeshLambertMaterial( { color: tube_color, shading: THREE.SmoothShading } );
					/*
					var material = new THREE.MeshBasicMaterial({
							color: tube_color,
							opacity: 1,
							wireframe: false,
							transparent: false
					  });
					*/			
                    var approx_track_point = track_points;
                    if ( serviceForStructure == '3d' ) {
                        approx_track_point = createApproximatedTrackPoints(track_points);
                    }

					var spline_points = [];
					var points_count = approx_track_point.length;
                    var lastChinkPosition
					for (var point_index = 0; point_index < points_count; ++point_index) {
						var chunk = approx_track_point[point_index];
                        
						var localCorodinates = Global2local( {x: chunk[2], y: chunk[3], z : chunk[4] });						
						spline_points.push(new THREE.Vector3(localCorodinates.x, localCorodinates.y, localCorodinates.z));
					}
                    var spline = new THREE.SplineCurve3(spline_points);
                    var segments = points_count * 2;
                    var radiusSegments =  6;
                    var tube = new THREE.TubeGeometry(spline, segments, radiusOfTube,    radiusSegments, false, false);

                    if (typeof meter == 'undefined') {
                        if (serviceForStructure == '3d'){
                            console.log(track_points.length + " before " + parseInt(track_points[track_points.length-1][1] - track_points[0][1])/track_points.length)
                            console.log(approx_track_point.length + "now " + parseInt(approx_track_point[approx_track_point.length-1][1] - approx_track_point[0][1])/approx_track_point.length)
                            meter = parseInt(approx_track_point[approx_track_point.length-1][1] - approx_track_point[0][1])/approx_track_point.length;
                            
                            if (healthness === 'm=leukemia') {

                                basesInSelection = meter;
                                minMeter = meter / 5 ; maxMeter = meter * 5; stepScroll = meter / 5;    
                            } else {
                                basesInSelection = meter/2;
                                minMeter = meter / 10 ; maxMeter = meter * 2; stepScroll = meter / 10;    
                            }
                            
                        } else {
                            meter = basesInSelection;
                            minMeter = 100 ; maxMeter = 3000; stepScroll = 100;
                        }
                    } 
                    
					tube.dynamic = true;
					var tubeMesh = new THREE.Mesh(tube, material);	
                    tubeMesh.userData = [blockIndicesStr, blockIndices];
					
					tubeMesh.name = chrid + "-" + String(track_points[0][1]) + "-"  + String(track_points[track_points.length - 1][1]);

                    if (isCustomerData && typeof customerData != 'undefined') {
                    var arr = AdaptUploadedSpinesForCustomerData(approx_track_point[0][1], approx_track_point[approx_track_point.length - 1][1], chridOnlyNum);
                        uploaded_splines[tubeMesh.name] = [chrid, approx_track_point, arr[0], arr[1], chridOnlyNum];//in usual case - as before
                    } else {
                        uploaded_splines[tubeMesh.name] = [chrid, approx_track_point];//in usual case - as before
                    }
                    
					if (serviceForStructure == '3d') 
                        octree.add(tubeMesh, {useFaces: false, useVertices: true, useSeqVertices: false});
                    else octree.add(tubeMesh, {useFaces: false, useVertices: false, useSeqVertices: true});
                    scene.add(tubeMesh);
					objects.push(tubeMesh);
                    console.log('Hi')
				}
            }
            function createApproximatedTrackPoints(track_points) {
                
                function Interpolate2(point, otherPoint, bpIndexNeed) {
                    var bpIndex = point[1];
                    var bpIndexOther = otherPoint[1];
                    var coeff = (bpIndexNeed - bpIndex) / (bpIndexOther - bpIndex);
                    var xCoord = point[2] + (otherPoint[2] - point[2]) * coeff;
                    var yCoord = point[3] + (otherPoint[3] - point[3]) * coeff;
                    var zCoord = point[4] + (otherPoint[4] - point[4]) * coeff;
                    return {x: xCoord, y: yCoord, z: zCoord};
                }

                function Interpolate3(previousPoint, point, otherPoint, bpIndexNeed) {
                    var bpIndexPrevious = previousPoint[1];
                    var bpIndexOther = otherPoint[1];
                    var coeff = (bpIndexNeed - bpIndexPrevious) / (bpIndexOther - bpIndexPrevious);
                    var xCoord = (1-coeff) * (1-coeff) * previousPoint[2] + 2*(1-coeff) * coeff * point[2] + otherPoint[2] * coeff * coeff;
                    var yCoord = (1-coeff) * (1-coeff) * previousPoint[3] + 2*(1-coeff) * coeff * point[3] + otherPoint[3] * coeff * coeff;
                    var zCoord = (1-coeff) * (1-coeff) * previousPoint[4] + 2*(1-coeff) * coeff * point[4] + otherPoint[4] * coeff * coeff;
                    return {x: xCoord, y: yCoord, z: zCoord};
                }

                var result = [];
                var NUMBER_LIMIT = 10000;
                var points_count = track_points.length;
                var rate;
                result[0] = track_points[0];
                var tempObj, previousLastTempObj;
                for (var indx = 0; indx <  points_count-1; indx++) {
                    rate = parseInt((track_points[indx+1][1] - track_points[indx][1])/NUMBER_LIMIT);
                    console.log(track_points[indx][0] + "  -  rate = " + rate);
                    if (rate < 2) {
                        result.push(track_points[indx+1]);
                        continue;
                    }

                    for (var i = 1; i <= rate; i++) {
                        bpIndexNeed = Math.floor(track_points[indx][1] + i/rate* (track_points[indx+1][1] - track_points[indx][1]));
                        
                        /*
                        //3points based Interpolation. Not good for neighbor cubes
                        if (points_count == 2) {
                            tempObj = Interpolate2(track_points[indx], track_points[indx+1], bpIndexNeed);
                        } else if (indx == 0) {
                            tempObj = Interpolate3(track_points[indx], track_points[indx+1], track_points[indx+2], bpIndexNeed);
                            lastTempObj = [track_points[indx+1][0], bpIndexNeed, tempObj.x, tempObj.y, tempObj.z]
                        } else if ( indx < points_count - 2 ) {
                            tempObj = Interpolate3(lastTempObj, track_points[indx+1], track_points[indx+2], bpIndexNeed);
                            if (i == rate) {
                                previousLastTempObj = lastTempObj;
                                lastTempObj = [track_points[indx+1][0], bpIndexNeed, tempObj.x, tempObj.y, tempObj.z]
                            }
                        } else if (indx == points_count - 2) {
                            tempObj = Interpolate3(((previousLastTempObj)?previousLastTempObj:track_points[indx-1]), track_points[indx], track_points[indx+1], bpIndexNeed);
                            // if (i == rate) {
                            //     deb_var = [previousLastTempObj, lastTempObj];
                            //     previousLastTempObj = lastTempObj;
                            //     lastTempObj = [track_points[indx][0], bpIndexNeed, tempObj.x, tempObj.y, tempObj.z]
                            // }
                        }
                        */

                        //linear interpolation
                        tempObj = Interpolate2(track_points[indx], track_points[indx+1], bpIndexNeed);
                        result.push([track_points[indx][0], bpIndexNeed, tempObj.x, tempObj.y, tempObj.z]);
                    }

                    // result.push(track_points[indx+1]);
                }
                
                return result;
            }

            function recursiveInterpolation(result, firstPoint, lastPoint) {
                result.push
            }

            function createApproximatedTrackPoints1(track_points, spline) {
                var result = [];
                var track_points_len = track_points.length;
                var points_count = spline.length;
                var globalVar;
                var start_point = 0;
                var distance, distance_between_nodes;
                var normal_counter = 0;
                
                for (var indx = 0; indx <  points_count; indx = findNextNotGroupedPoint(spline, indx)) {
                    globalVar = Local2globalVector3(spline[indx]);
                    if (indx == 0) {
                        result[normal_counter] = track_points[0];
                    }

                    for (var indx2 = start_point; indx2 < track_points_len-1/*because of decrease*/; indx2++) {
                        distance = Math.pow(track_points[indx2][2] - globalVar.x,2) + 
                                Math.pow(track_points[indx2][3] - globalVar.y,2) + 
                                Math.pow(track_points[indx2][4] - globalVar.z,2);

                        distance_between_nodes = Math.pow(track_points[indx2][2] - track_points[indx2+1][2],2) + 
                                Math.pow(track_points[indx2][3] - track_points[indx2+1][3],2) + 
                                Math.pow(track_points[indx2][4] - track_points[indx2+1][4],2);

                        if ( distance_between_nodes >= distance ) {
                            result[normal_counter] = [track_points[indx2][0], Math.floor(track_points[indx2][1] + (track_points[indx2+1][1] - track_points[indx2][1]) * distance / distance_between_nodes), globalVar.x, globalVar.y, globalVar.z];
                            break;
                        } else {
                            start_point++;
                            continue;
                        }
                    }
                    normal_counter++;
                }
                
                return result;
            }

            function AdaptUploadedSpinesForCustomerData(beginPos, endPos, chridOnlyNum) {
                var customerDataStart=-1, customerDataEnd=-1;
                {   
                    var custArray = customerData[chridOnlyNum];
                    var lenCustomerData = custArray.length;
                    for (var point_index = 0; point_index < lenCustomerData; ++point_index) {
                        if (customerDataStart==-1 && custArray[point_index][0] > beginPos) {
                            customerDataStart=point_index;
                        } else if (customerDataStart!=-1 && customerDataEnd==-1 && custArray[point_index][0] > endPos) {
                            customerDataEnd=point_index-1;
                            return [customerDataStart, customerDataEnd];
                        }
                    }
                }
            }
            
            function DrawBox(cornerModelCoordinates, edgeSize) {
		       var vertices = [];
		       for (var pointIndex = 0; pointIndex < 8; ++pointIndex) {
		           var xCoord = cornerModelCoordinates.x + edgeSize * (pointIndex % 2);
		           var yCoord = cornerModelCoordinates.y + edgeSize * ((pointIndex >> 1) % 2);
		           var zCoord = cornerModelCoordinates.z + edgeSize * ((pointIndex >> 2) % 2);
		           vertexLocalCoordinates = Global2local({x: xCoord, y: yCoord, z: zCoord });
		           vertices[pointIndex] = new THREE.Vector3(vertexLocalCoordinates.x, vertexLocalCoordinates.y, vertexLocalCoordinates.z);
		       }
		       for (var firstIndex = 0; firstIndex < vertices.length; ++firstIndex) {
		           for (var secondIndex = firstIndex + 1; secondIndex < vertices.length; ++secondIndex) {
		               var matchedCoordinates = ((firstIndex % 2) == (secondIndex % 2)) ? 1 : 0;
		               matchedCoordinates += ((firstIndex >> 1) % 2 == (secondIndex >> 1) % 2) ? 1 : 0;
		               matchedCoordinates += ((firstIndex >> 2) % 2 == (secondIndex >> 2) % 2) ? 1 : 0;
		               if (matchedCoordinates == 2) {
						   var material = new THREE.LineBasicMaterial({color: 0x0000af});
						   var geometry = new THREE.Geometry();
						   geometry.vertices.push(vertices[firstIndex]);
						   geometry.vertices.push(vertices[secondIndex]);	               	
						   var line = new THREE.Line(geometry, material);
						   scene.add(line);
		               }
		           }           
		       }      
            }

            function UploadPoints(blockCornerCoordinates, blockIndicesStr, blockIndices) {
                overlap = blockSize * 0.2;
                
            	var request = "xstart=" + String(blockCornerCoordinates.x - overlap) 
            				  + "&xend=" + String(blockCornerCoordinates.x + blockSize + overlap)
            				  + "&zstart=" + String(blockCornerCoordinates.z - overlap)      
            				  + "&zend=" + String(blockCornerCoordinates.z + blockSize + overlap)  
            				  + "&ystart=" + String(blockCornerCoordinates.y - overlap)      
            				  + "&yend=" + String(blockCornerCoordinates.y + blockSize + overlap);
			    var url = "http://1kgenome.exascale.info/"+serviceForStructure+"?" + disease3Dexpression + request;
			    $.getJSON(url + "?callback=?", null, 
			    	function(model_points) {
			    		DrawPoints(model_points, blockIndicesStr, blockIndices);
			    		//UploadSNP(model_points);
			    	}
			    ).fail(function() { showErrorAlertModalWindow('Service is not available at this moment. We are doing all the best to fix it now. Please, try again later.') });
            }
            
            function GetBlockIndices(modelPosition) {
            	blockOffset = blockSize / 2;
		        var blockIndexX = Math.floor((modelPosition.x + blockOffset) / blockSize);
		        var blockIndexY = Math.floor((modelPosition.y + blockOffset) / blockSize);
		        var blockIndexZ = Math.floor((modelPosition.z + blockOffset) / blockSize);   
		        //System.out.println(String.format("%f %f %f -> %d %d %d", x, y, z, blockIndexX, blockIndexY, blockIndexZ));
		        return {x : blockIndexX, y : blockIndexY, z : blockIndexZ };
            }
            
            function GetBlockCornerCoordinates(blockIndices) {
            	blockOffset = blockSize / 2;
            	var xCoord = blockIndices.x * blockSize - blockOffset;
            	var yCoord = blockIndices.y * blockSize - blockOffset;
            	var zCoord = blockIndices.z * blockSize - blockOffset;
            	return {x : xCoord, y: yCoord, z: zCoord};
            }
            
            function Coords2Str(coordinates) {
                return String(coordinates.x) + ":" + String(coordinates.y) + ":" + String(coordinates.z);
            }

            function Str2Coords(coorLine) {
                var arr = coorLine.split(':');
                return {x : parseInt(arr[0]), y : parseInt(arr[1]), z : parseInt(arr[2]) };
            }
            
            function UpdateModel() {
            	var modelPosition = Local2global(controls.getObject().position);
            	var blockIndices = GetBlockIndices(modelPosition);
            	var blockIndicesStr = Coords2Str(blockIndices);

                //delete textures in the others cube only if 
                if (lastBlockIndicesStr != blockIndicesStr) {
                    //immediate cleaning the octree - recreate everytime you left the cube
                    if (isOneCubeOctree) {
                        octree = new THREE.Octree( {
                          undeferred: false,
                          depthMax: Infinity,
                          objectsThreshold: 8,
                          overlapPct: 0.15
                           // ,
                           // scene: scene
                        } );
                        if (blockIndicesStr in uploaded_area) {

                            var objArray = $.grep(objects, function(v,i){return v.userData[0] === blockIndicesStr});
                            
                            for (var _o in objArray) {
                                if (serviceForStructure == '3d') 
                                    octree.add(objArray[_o], {useFaces: false, useVertices: true, useSeqVertices: false});
                                else octree.add(objArray[_o], {useFaces: false, useVertices: false, useSeqVertices: true});

                            }
                        }
                    }
                    DeleteTexturesFromCubes2(blockIndicesStr, blockIndices);
                    lastBlockIndicesStr = blockIndicesStr;
                }

            	if (blockIndicesStr in uploaded_area) {

                    // console.log("Alex Alex Alex");
                    // if (uploaded_area[blockIndicesStr]) // if it is SOMEHOW is still true
                        // return;
            		// recreate textures in the particular cube (Tube Mesh to Line)
                    // RecreateTexturesInCube(blockIndicesStr);
            	} else {
                    uploaded_area[blockIndicesStr] = true;
                    var blockCornerCoordinates = GetBlockCornerCoordinates(blockIndices);
                    DrawBox(blockCornerCoordinates, blockSize);
                    UploadPoints(blockCornerCoordinates, blockIndicesStr, blockIndices);
                } 
            }

            //Delete Mesh out of the alowed space region
            function DeleteTexturesFromCubes2(blockIndicesStr, blockIndices) {
                var objectsIndcesToDelete = [];
                var tempUserData, tempUserDataCoord;
                var distanceToDelete = 1;
                //for (var _obj in objects) {
                console.log("Delete started");
                
                for (var _obj = 0; _obj < objects.length; ++_obj) {
                        tempUserData = objects[_obj].userData[0];
                        tempUserDataCoord = objects[_obj].userData[1];
                        if (tempUserData != blockIndicesStr && !(blockIndices.x - tempUserDataCoord.x <= distanceToDelete && blockIndices.x - tempUserDataCoord.x >= (-1*distanceToDelete) && blockIndices.y - tempUserDataCoord.y <= distanceToDelete && blockIndices.y - tempUserDataCoord.y >= (-1*distanceToDelete) && blockIndices.z - tempUserDataCoord.z <= distanceToDelete && blockIndices.z - tempUserDataCoord.z >= (-1*distanceToDelete))) {
                            
                            if (tempUserData in uploaded_area) delete uploaded_area[tempUserData];
                            scene.remove(objects[_obj]);

                            delete uploaded_splines[objects[_obj].name];
                            if (!isOneCubeOctree) octree.remove(objects[_obj]);
                            
                            objectsIndcesToDelete.push(_obj);
                        }
                }
                // octree.rebuild();
                console.log("Delete finished");
                if (objects.length>0 && objectsIndcesToDelete.length>0) {
                    objects = $.grep(objects, function(v,i){return $.inArray(i,objectsIndcesToDelete)==-1});
                }
                
                if (chipObjects.length==0) return;
                objectsIndcesToDelete = [];
                console.log("Chip Delete started");
                for (var _obj = 0; _obj < chipObjects.length; ++_obj) {
                        tempUserData = chipObjects[_obj].userData[0];
                        tempUserDataCoord = chipObjects[_obj].userData[1];

                        if (tempUserData != blockIndicesStr && !(blockIndices.x - tempUserDataCoord.x <= distanceToDelete && blockIndices.x - tempUserDataCoord.x >= (-1*distanceToDelete) && blockIndices.y - tempUserDataCoord.y <= distanceToDelete && blockIndices.y - tempUserDataCoord.y >= (-1*distanceToDelete) && blockIndices.z - tempUserDataCoord.z <= distanceToDelete && blockIndices.z - tempUserDataCoord.z >= (-1*distanceToDelete))) {
                            
                            if (tempUserData in uploaded_area) delete uploaded_area[tempUserData];
                            scene.remove(chipObjects[_obj]);

                            delete uploaded_splines_chip[chipObjects[_obj].name];
                            
                            objectsIndcesToDelete.push(_obj);
                        }
                }
                // octree.rebuild();
                console.log("Chip Delete finished");
                if (chipObjects.length>0 && objectsIndcesToDelete.length>0) {
                    chipObjects = $.grep(chipObjects, function(v,i){return $.inArray(i,objectsIndcesToDelete)==-1});
                }
                
                
                
            }

            function GetIntersectionCHIPSEQ() {
                var vector = new THREE.Vector3(0, 0, 0);
                var raycaster = projector.pickingRay(vector, camera);
                var closestObjectDistance;
                var intersects = raycaster.intersectObjects(chipObjects);
                if (intersects.length == 0) {
                    return null;
                }
                closestObjectDistance = intersects[0].distance;
                intersects = $.grep(intersects, function(v){return v.distance <= closestObjectDistance + 5});
                return intersects;
            }

            function GetIntersection() {
            	var vector = new THREE.Vector3(0, 0, 0);
            	var raycaster = projector.pickingRay(vector, camera);
            	
                // var intersects = raycaster.intersectObjects(objects);
                var intersects = raycaster.intersectObjects(objects);
				if (intersects.length == 0) {
					return null;
				}
				return intersects[0];
            }


            
            function GetSelectedTrackPoints(intersectPoint, trackName) {
            	var intersectInModelCoordinates = Local2global(intersectPoint);
                // trackPoints from 3dQuery
            	var trackPoints = uploaded_splines[trackName][1];
            	var chrid = trackName.split("-")[0];
            	var closestPoint = -1;
            	var minDistance = -1;
            	for (var pointIndex = 0; pointIndex < trackPoints.length; ++pointIndex) {
                    if (typeof trackPoints[pointIndex] == 'undefined'){
                        console.log("ff+ " + pointIndex);
                        continue;
                    }
            		var x = trackPoints[pointIndex][2];
            		var y = trackPoints[pointIndex][3];
            		var z = trackPoints[pointIndex][4];
            		var distance = Math.pow(intersectInModelCoordinates.x - x, 2) + 
            						Math.pow(intersectInModelCoordinates.y - y, 2) +
            						Math.pow(intersectInModelCoordinates.z - z, 2);
            		if (minDistance == -1 || distance < minDistance) {
            			minDistance = distance;
            			closestPoint = pointIndex;
            		}
            	}
			    
			    var start = closestPoint;
			    while (start > 0 && Math.abs(trackPoints[start][1] - trackPoints[closestPoint][1]) < basesInSelection / 2) {
			    	--start;
			    }
			    var end = closestPoint;
			    while (end < trackPoints.length - 1 && Math.abs(trackPoints[end][1] - trackPoints[closestPoint][1]) < basesInSelection / 2) {
			    	++end;
			    }
			    
			   	function Interpolate(point, otherPoint, bpIndexNeed) {
			   		var bpIndex = trackPoints[point][1];
			   		var bpIndexOther = trackPoints[otherPoint][1];
			   		var coeff = (bpIndexNeed - bpIndex) / (bpIndexOther - bpIndex);
			   		var xCoord = trackPoints[point][2] + (trackPoints[otherPoint][2] - trackPoints[point][2]) * coeff;
			   		var yCoord = trackPoints[point][3] + (trackPoints[otherPoint][3] - trackPoints[point][3]) * coeff;
			   		var zCoord = trackPoints[point][4] + (trackPoints[otherPoint][4] - trackPoints[point][4]) * coeff;
			   		return {x: xCoord, y: yCoord, z: zCoord};
			   	}
			   	
		   		var otherPoint = start < trackPoints.length - 1 ? start + 1 : start;
		   		var exactStartPosition = Interpolate(start, otherPoint, trackPoints[closestPoint][1] - basesInSelection / 2);
		   		otherPoint = end > 0 ? end - 1 : end;
		   		var exactEndPosition = Interpolate(end, otherPoint, trackPoints[closestPoint][1] + basesInSelection / 2);
				
				var selectionTrackPoints = [Global2local(exactStartPosition)];
				for (var pointIndex = start + 1; pointIndex < end; ++pointIndex) {
					selectionTrackPoints.push(Global2local({x: trackPoints[pointIndex][2], y: trackPoints[pointIndex][3], z: trackPoints[pointIndex][4]}));
				}
				selectionTrackPoints.push(Global2local(exactEndPosition));
                //draw selection old - plane
                // if (is_plane_mode)
                if (mode_id == 0)
                {
                    var spline = new THREE.SplineCurve3(selectionTrackPoints);
                    var segments = serviceForStructure=='3d' ? Math.floor(basesInSelection/6500) : basesInSelection/50; 
                    var radiusSegments = 6;
                    
                    var tube = new THREE.TubeGeometry(spline, segments, radiusOfTube+10, radiusSegments, false, false);
                    tube.dynamic = true;
                    scene.remove(selectionMesh);

                    delete selectionMesh;
                    {
                        var material = new THREE.MeshBasicMaterial({
                                color: 0xff0000,
                                opacity: 1,
                                wireframe: true,
                                transparent: false
                        });                     
                        
                        selectionMesh = new THREE.Mesh(tube, material);
                        selectionMesh.geometry.verticesNeedUpdate = true;
                        scene.add(selectionMesh);
                    }
                    
                } else if (mode_id == 1)
				//draw selection new - cube
                {
                    var cube = new THREE.CubeGeometry(radiusSphere*2,radiusSphere*2,radiusSphere*2, 5, 5, 5);
                    cube.dynamic = true;
                    scene.remove(selectionMesh);
                    {
                        var material = new THREE.MeshBasicMaterial({
                                color: 0xff0000,
                                opacity: 1,
                                wireframe: true,
                                transparent: false
                        });                     
                        
                        selectionMesh = new THREE.Mesh(cube, material);
                        selectionMesh.position = new THREE.Vector3(intersectPoint.x, intersectPoint.y, intersectPoint.z);
                        // selectionMesh.geometry.verticesNeedUpdate = true;
                        scene.add(selectionMesh);
                    }
                    
                }
				return [chrid, trackPoints[closestPoint][1] - basesInSelection / 2, 
							trackPoints[closestPoint][1] + basesInSelection / 2]; 	
            }
            
            function ClearInfo() {
            	if (infoBlock) {
            		infoBlock.innerHTML = "";
                    lastRegion = [];
                    rgn = [];
                    document.getElementById('detection-sign').style.display = "none";
            	}

            }
            
            
            function PositionToString(region) {
//                deb_var = region;
            	var helix = region[0].split("_")[1];//temp storage
                if (typeof helix == 'undefined')
                    helix = '';
                else if (helix == 'a') helix = ', helix A';
                else helix = ', helix B';
            	var info = "Selection: chromosome: " + region[0].split("_")[0] +  helix;
            	info += ", bases: " + String(Math.floor(region[1])) + "&ndash;" + String(Math.floor(region[2]));
            	return info;            	
            }

			function Popup(data) {
				var popup = window.open("","MsgWindow","width=200,height=100");
				popup.document.write("<p>" + data + "</p>");								
			}

			function UploadRegionData(region) {
            	var request = "start=" + String(Math.floor(region[1])) 
            				  + "&end=" + String(Math.floor(region[2]))
            				  + "&chrid=" + String(region[0]);
			    var url = "http://1kgenome.exascale.info/range?" + request;		
			    $.getJSON(url + "?callback=?", null, 
			    	function(regionInfo) {
			    		var key = PositionToString(region);
			    		var chrid = region[0];
			    		chrid = chrid.replace("_b", "_a");
			    		var key_a = PositionToString([chrid, region[1], region[2]]);
			    		chrid = chrid.replace("_a", "_b");
			    		var key_b = PositionToString([chrid, region[1], region[2]]);
			    		formated_data = "<br/>@Bases: <a target='_blank' style=\"color: rgb(0,255,0)\" href='http://1kgenome.exascale.info/range?" + request + "'>" + regionInfo.substring(0, 50) + "...</a>";
			    		regionData[key_a][1] = formated_data;
			    		regionData[key_b][1] = formated_data;
			    		infoBlock.innerHTML = regionData[key][0] + regionData[key][1] + regionData[key][2];
			    		/*
			    		if (infoBlock.innerHTML == key) {
			    			infoBlock.innerHTML = regionData[key];
			    		} else {
			    			console.log("da fuck: " + infoBlock.innerHTML);
			    		}
			    		*/
			    	}
			    ); 	
			    
			    {//SNPs
			    	var chrid = String(region[0]);
                     console.log(chrid);
            		var chridNoStrand = chrid.split('_')[0];
            		var chridOnlyNumber = chridNoStrand;
            		if (chridOnlyNumber[chridOnlyNumber.length - 1] == "a") {
            			chridOnlyNumber = chridOnlyNumber.substr(0, chridOnlyNumber.length - 1);
            		}
			    	
	        		var request = "chr=" + ((chridOnlyNumber=='23')?'X':chridOnlyNumber) + "&start=" + String(Math.floor(region[1])) +
	        						 "&end=" + String(Math.floor(region[2])); 
				    var url = "http://1kgenome.exascale.info/js_snp?" + request;
				    $.getJSON(url + "?callback=?", null, 
				    	function(positions) {
				    		snips = "";
                            var genotypeArray = [];
			            	for (var point_index = 0; point_index < positions.length; ++point_index) {
			            		var base_index = positions[point_index][0];

                                genotypeArray[point_index] = /*getFakeGenotypeForSNP();*/positions[point_index][2]+positions[point_index][3];
			            		var snp_id = /*"rs" + */String(positions[point_index][1]);
			            		snips += " <a target=\"_blank\" style=\"color: rgb(255,255,0)\" href=\"http://www.ncbi.nlm.nih.gov/SNP/snp_ref.cgi?rs="+snp_id+"\">rs"+snp_id+"</a>;";
			            	}

			            	formated_data = "<br/>@SNPs:" + snips;
			            	var key = PositionToString(region);
				    		var chrid = region[0];
				    		chrid = chrid.replace("_b", "_a");
				    		var key_a = PositionToString([chrid, region[1], region[2]]);
				    		chrid = chrid.replace("_a", "_b");
				    		var key_b = PositionToString([chrid, region[1], region[2]]);
				    		regionData[key_a][2] = formated_data;
				    		regionData[key_b][2] = formated_data;
                            regionData[key_a][3] = genotypeArray;
                            regionData[key_b][3] = genotypeArray;
				    		infoBlock.innerHTML = regionData[key][0] + regionData[key][1] + regionData[key][2]; //@TODO: change place of storing data for genotype!!! and call here only regionData[positionStr]
				    	}
				    );
			    }		    

			}

            /*@deprecated*/
            function buildCubeDataStructure(model_points) {
                 var new_cube_tracks = model_points["data"];
                    if (new_cube_tracks.length == 0) {
                        console.log("NULL");
                        resp_count++;
                        return;
                    }
                 for (var track_index = 0; track_index < new_cube_tracks.length; ++track_index) {
                    chrid = new_cube_tracks[track_index][0];
//                    chridNoStrand = chrid.substr(0, chrid.length - 2);
                    chridNoStrand = chrid.split('_')[0];
                     
                    var chridOnlyNumber = chridNoStrand;
                    if (chridOnlyNumber[chridOnlyNumber.length - 1] == "a") {
                        chridOnlyNumber = chridOnlyNumber.substr(0, chridOnlyNumber.length - 1);
                    }

                    track_points = new_cube_tracks[track_index][1];
                    var request = "chr=" + ((chridOnlyNumber=='23')?'X':chridOnlyNumber) + "&start=" + String(Math.floor(track_points[0][1])) +
                                     "&end=" + String(Math.floor(track_points[track_points.length - 1][1])); 
                    var url = "http://1kgenome.exascale.info/js_snp?" + request;
                    req_count++;
                    $.getJSON(url + "?callback=?", null, 
                        function(positions) {
                            snips = "";
                            for (var point_index = 0; point_index < positions.length; ++point_index) {
                                var base_index = positions[point_index][0];
                                var snp_id = /*"rs" + */String(positions[point_index][1]);
                                snips += " <a target=\"_blank\" style=\"color: rgb(0,0,255)\" href=\"http://www.ncbi.nlm.nih.gov/SNP/snp_ref.cgi?rs="+snp_id+"\">rs"+snp_id+"</a>;";
                            }
                            // infoBlock.innerHTML += snips;
                            if (tableStrContent.length == 0) tableStrContent += snips;
                            else tableStrContent += "<br>" + snips;

                            resp_count++;
                        }
                    );
                }
                req_count--;
            }

            function buildCubeDataStructureSNPs(resultSet) {
                    if (resultSet == null || resultSet.length == 0) {
                        console.log("EMPTY area - you should not see this");
                        return;
                    }
                 var arrRequestInfo = [];
                 for (var track_index in resultSet) {
                    var chridOnlyNumber = resultSet[track_index].chr;
                    arrRequestInfo[track_index] = [];
                    for (var intervals_indx in resultSet[track_index].intervals) {
                        console.log("["+track_index+"]" + "["+intervals_indx+"]")
                        var request = "chr=" + ((chridOnlyNumber=='23')?'X':chridOnlyNumber) + "&start=" + String(Math.floor(resultSet[track_index].intervals[intervals_indx].start)) +
                                     "&end=" + String(Math.floor(resultSet[track_index].intervals[intervals_indx].end)); 
                        var url = "http://1kgenome.exascale.info/js_snp?" + request;
                        req_count++;
                        arrRequestInfo[track_index][intervals_indx] = [];
                        arrRequestInfo[track_index][intervals_indx][0] = [chridOnlyNumber, String(resultSet[track_index].intervals[intervals_indx].start), String(resultSet[track_index].intervals[intervals_indx].end)];
                        arrRequestInfo[track_index][intervals_indx][1] = $.getJSON(url + "?callback=?", null, 
                            function(positions) {
                                snips = "";
                                for (var point_index = 0; point_index < positions.length; ++point_index) {
                                    var base_index = positions[point_index][0];
                                    var snp_id = /*"rs" + */String(positions[point_index][1]);
                                    snips += " <a target=\"_blank\" style=\"color: rgb(0,0,255)\" href=\"http://www.ncbi.nlm.nih.gov/SNP/snp_ref.cgi?rs="+snp_id+"\">rs"+snp_id+"</a>;";
                                }
                                if (tableStrContent.length == 0) tableStrContent += snips;
                                else tableStrContent += "<br><hr>" + snips;

                                resp_count++;
                            }
                        );
                    }
                }
                return arrRequestInfo;
            }

            function GetSelectedTrackPointsVollume3Dquery(intersectPoint) {
                var intersectInModelCoordinates = Local2global(intersectPoint);
                
                var radiusSphereGlobal = 2 * radiusSphere/scaleFactor;

                tableStrContent = '';
                console.log("Clean tableStrContent");
                req_count =1;
                resp_count = 0;
                var request = "xstart=" + String(intersectInModelCoordinates.x - radiusSphereGlobal) 
                              + "&xend=" + String(intersectInModelCoordinates.x + radiusSphereGlobal)
                              + "&zstart=" + String(intersectInModelCoordinates.z - radiusSphereGlobal)      
                              + "&zend=" + String(intersectInModelCoordinates.z + radiusSphereGlobal)  
                              + "&ystart=" + String(intersectInModelCoordinates.y - radiusSphereGlobal)      
                              + "&yend=" + String(intersectInModelCoordinates.y + radiusSphereGlobal);      
                var url = "http://1kgenome.exascale.info/"+serviceForStructure+"?" + disease3Dexpression + request;
                $.getJSON(url + "?callback=?", null, 
                    function(model_points) {
                        buildCubeDataStructure(model_points);
                    }
                );

                
            }
            
            function UpdateInfoChipSeq() {
                intersection = GetIntersectionCHIPSEQ();
                if (intersection == null) {
                    ClearInfo();
                    return;
                }
                
                var temp;
                if (typeof lastIntersection  != 'undefined' && intersection[0].point.x == lastIntersection.x && intersection[0].point.y == lastIntersection.y && intersection[0].point.z == lastIntersection.z) {
                    return;
                } else {
                    ClearInfo();
                    for (var inter_indx in intersection) {
                        temp = uploaded_splines_chip[intersection[inter_indx].object.name];
                        // infoBlock.innerHTML += intersection[inter_indx].object.name + "; ";
                        infoBlock.innerHTML += "<a target='_blank' style='color: rgb(255,255,0)' href='http://genome.ucsc.edu/cgi-bin/hgTracks?db=hg19&position=chr"+temp[0]+"%3A"+temp[1]+"-"+temp[2]+"' >"+temp[0]+"-"+temp[1] + ":"+temp[2] + " -> " + temp[3] + "("+temp[4]+")</a>; ";
                    }
                    lastIntersection = intersection[0].point;
                }
            }

            function UpdateInfo() {
                if (mode_id == 2) {
                    UpdateInfoChipSeq();
                    return;
                }

                intersection = GetIntersection();
                if (intersection == null) {
                    ClearInfo();
                    return;
                }

                if (mode_id == 1) {

                    ClearInfo();
                    //draw selection new - cube
                    {
                        var cube = new THREE.CubeGeometry(radiusSphere*2,radiusSphere*2,radiusSphere*2, 5, 5, 5);
                        cube.dynamic = true;
                        scene.remove(selectionMesh);
                        {
                            var material = new THREE.MeshBasicMaterial({
                                    color: 0xff0000,
                                    opacity: 1,
                                    wireframe: true,
                                    transparent: false
                            });
                            selectionMesh = new THREE.Mesh(cube, material);
                            selectionMesh.position = new THREE.Vector3(intersection.point.x, intersection.point.y, intersection.point.z);
                            scene.add(selectionMesh);
                        }
                    }
                    return;
                }

            	object = intersection.object;
            	point = intersection.point;
            	if (object.name == "") {
                    ClearInfo();
            		return;
            	}

                if ((typeof uploaded_splines[object.name] === 'undefined')) {
                    console.log("Warning: undefined!!!"); 
                    ClearInfo();
                    return;
                }


            	var region = GetSelectedTrackPoints(point, object.name);
                rgn = region;
            	var positionStr = PositionToString(region);
            	if (positionStr in regionData && (lastRegion==null || lastRegion[0] != regionData[positionStr][0] && lastRegion[1] != regionData[positionStr][1] && lastRegion[2] != regionData[positionStr][2])) {
            		infoBlock.innerHTML = regionData[positionStr][0] + regionData[positionStr][1] + regionData[positionStr][2]; //@TODO: change place of storing data for genotype!!! and call here only regionData[positionStr]
                    lastRegion = regionData[positionStr];
                    
                    if (isCustomerData) {
                        var custDataArray = customerData[uploaded_splines[object.name][4]].slice(uploaded_splines[object.name][2],uploaded_splines[object.name][3]+1);
                        var startRegPos = parseInt(region[1]);
                        var endRegPos = parseInt(region[2]);
                        for (var indx = 0; indx < custDataArray.length; indx++) {
                            if ( custDataArray[indx][0] < startRegPos ) continue;
                            else if (custDataArray[indx][0] > endRegPos ) {
                                document.getElementById('detection-sign').style.display = "none";
                                break;
                            }
                            else {
                                document.getElementById('detection-sign').style.display = "";
                                break;
                            }
                        }
                    }
                    
            	} else if (!(positionStr in regionData)) {
            		//show something immidiately
            		infoBlock.innerHTML = positionStr + "<br/>data uploading...";
            		//also works like flag: request is already sent
            		regionData[PositionToString([region[0].replace("_b", "_a"), region[1], region[2]])] = [positionStr, "", ""];
            		regionData[PositionToString([region[0].replace("_a", "_b"), region[1], region[2]])] = [positionStr, "", ""];
                    //show snps of the user here
                    
                    
                    if (isCustomerData) {
                        var custDataArray = customerData[uploaded_splines[object.name][4]].slice(uploaded_splines[object.name][2],uploaded_splines[object.name][3]+1);
                        var startRegPos = parseInt(region[1]);
                        var endRegPos = parseInt(region[2]);
                        for (var indx = 0; indx < custDataArray.length; indx++) {
                            if ( custDataArray[indx][0] < startRegPos ) continue;
                            else if (custDataArray[indx][0] > endRegPos ) {
                                document.getElementById('detection-sign').style.display = "none";
                                break;
                            }
                            else {
                                document.getElementById('detection-sign').style.display = "";
                                break;
                            }
                        }
                    }
                    
                    
            		UploadRegionData(region);            		
            	}
            }

            function animate() {
                    requestAnimationFrame( animate );
                    UpdateTargetBallPosition();
                    UpdateInfo();
                   	UpdateModel();
                        
                    // updateGUI();    
                    controls.update( Date.now() - time );
                    renderer.render( scene, camera );
                    octree.update();
                    time = Date.now();
            }
            
            function showErrorAlertModalWindow(message) {
                document.exitPointerLock = document.exitPointerLock ||document.mozExitPointerLock || document.webkitExitPointerLock;
                document.exitPointerLock();                
                var element = document.body;
                is_modal_opened = true;
                _messi = new Messi(
                    message, {title: 'Error Message', center: true, /*viewport: {top: '5vh', left: '10%'},*/ titleClass: 'anim error', buttons: [{id: 0, label: 'Close', val: 'O'}], 
                    callback: function(val) { 
                        element.requestPointerLock = element.requestPointerLock ||element.mozRequestPointerLock || element.webkitRequestPointerLock;
                        element.requestPointerLock();
                        is_modal_opened = false;
                }});
            }
            
            function exitFromFullScreen() {
                document.exitFullscreen = document.mozCancelFullScreen || document.webkitCancelFullScreen || document.msExitFullscreen;
                document.exitFullscreen();
                
            }
            
            function enterInFullScreen() {
                var element = document.body;
                element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;
                element.requestFullscreen();
            }

        </script>
        
        <script>
        	infoBlock = document.createElement('div');
			infoBlock.id = "infoblock";
			// document.body.appendChild(infoBlock); 
            divElement.appendChild(infoBlock);
            mod_message_div = document.createElement('p');
            mod_message_div.id = "textmode";
            mod_message_div.style.bottom = String(infoBlock.clientHeight) + "px";
            document.getElementById("detection-sign").style.bottom = String(infoBlock.clientHeight) + "px";
            document.getElementById('detection-sign').style.display = "none";
//            mod_message_div.style = "display:none";
            mod_message_div.appendChild(document.createTextNode(""));
            divElement.appendChild(mod_message_div);

			/*staticBlock = document.createElement('div');
			staticBlock.id = "staticblock";
			staticBlock.innerHTML = "<em>3DBD Genome browser</em>, contact: <a target='_blank' href='http://exascale.info/'>eXascale Infolab</a>, {phil, ruslan}@exascale.info; <a target='_blank' href='http://www.scs.carleton.ca/'>McGill University SoCS</a>, jeromew@cs.mcgill.ca, alexander.butyaev@mail.mcgill.ca.";
			// document.body.appendChild(staticBlock); 
            divElement.appendChild(staticBlock);*/
				
		</script>
    </body>
</html>
