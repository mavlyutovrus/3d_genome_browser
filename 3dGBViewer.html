<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>3DBD genome browser</title>
		<link href="css/main.css" rel="stylesheet" type="text/css"/>
        <link href="css/cupertino/jquery-ui-1.10.4.custom.css" rel="stylesheet">
        <!-- <link rel="stylesheet" href="http://code.jquery.com/ui/1.10.3/themes/smoothness/jquery-ui.css"> -->
        <link rel="stylesheet" href="js/messi/messi.min.css" rel="stylesheet" type="text/css"/>
        
        <!-- jquery -->
        
        <script src="http://code.jquery.com/jquery-1.10.2.js"></script>
        <!-- <script src="http://code.jquery.com/ui/1.10.4/jquery-ui.js"></script> -->
        <script src="js/jquery-ui-1.10.4.custom.min.js"></script>
        <!--script src="js/dat.gui.min.js"></script-->

        <!-- lite version of three.js distrib   -->
        <!--script src="js/min.three.js"></script-->
        <script type="text/javascript" src="js/three.min_new.js"></script>
        <script type="text/javascript" src="js/threeoctree.js"></script>

    	<!-- hacked PointerLockControls.js from "three/examples/js/controls/PointerLockControls.js" -->
		<script src="js/PointerLockControls.js"></script>
    	
        <script type='text/javascript' src='js/messi/messi.min.js'></script>

        <script src="content/TextMessages.js"></script>
        <script src="content/geneData.json"></script>

        <!--script type="text/javascript" src="https://apis.google.com/js/plusone.js"></script-->

        <script>
              $(function() {
                $( "#tabs" ).tabs({
                    "create": function (event, ui) {
                        document.getElementById("blocker").style.top = String($("ul.ui-tabs-nav").height()+27) + "px";
                    },
                    "activate": function(event, ui) {
                        if (ui.newTab.index() == 1) document.body.style.overflow = "hidden";
                        else if (ui.oldTab.index() == 1) document.body.style.overflow = "auto"
                    }
                });
                $("#href_tabs-5").click(function() {window.location = "scripting.html"});
              });

              $(function() {
                $( "#dialog-message" ).dialog({
                  modal: true,
                  autoOpen: false,
                  width: 400
                });
              });

              $(function() {
                $( "button#moveButton" )
                  .button()
                  .click(function( event ) {
                    var incoords = document.getElementById('incoords').value; 
                    var moveCameraChoice = document.getElementById('moveCameraChoice').value;
                    // if (
                        validate(incoords, moveCameraChoice);
                        // ) {$('#tabs').tabs('option', 'active', 1); } else { $("#dialog-message").dialog( "open" );}
                  });
              });
            
            $(function() {
                $( "#submitCustomData, #cleanButton" )
                  .button()
                  .click(function( event ) {
                    event.preventDefault;
                  });
              });
            
              
        </script>

		<!-- low-resolution 3d model  -->
		<!--<script src="data.js"></script>-->
        
    </head>
    <body>
        <!-- Share scripts for FB/ Twt-->
        <script>(function(d, s, id) {
          var js, fjs = d.getElementsByTagName(s)[0];
          if (d.getElementById(id)) return;
          js = d.createElement(s); js.id = id;
          js.src = "http://connect.facebook.net/us_US/all.js#xfbml=1";
          fjs.parentNode.insertBefore(js, fjs);
        }(document, 'script', 'facebook-jssdk'));
        </script>
        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');
        </script>

        <div id="dialog-message" title="Wrong format of coordinates" >
            <p>Wrong format of input data. Please enter coordinates in format 'X,Y,Z' to specify your next location in Genome space. Also you can move to the place of particular part of specified chromosome. Format: 'chr#,#,#'. Separator can be any symbol except for numeric one. In case of using 3d model of particular chromosomes you can use only this chromosome.<br>As well you can move to and color particular gene (if it exists in the database). Format 'chr#,NAME_OF_GENE'. Not available for simulated 3d model.</p>
        </div>
        
        <!-- google analytics -->
        <div id="tabs">
          <ul>
            <li><a id="href_tabs-0" href="#tabs-0">Welcome Page/UI</a></li>
            <li><a id="href_tabs-1" href="#tabs-1">Genome Browser</a></li>
            <li><a id="href_tabs-3" href="#tabs-3">Contact us</a></li>
            <li><a id="href_tabs-4" href="#tabs-4">About</a></li>
            <li><a id="href_tabs-5" href="#tabs-5">Script'ing</a></li>
          </ul>
          <div id="tabs-0">
              <div>
                  <div id="left">
                    <p>Welcome to 3D Genome Browser page<input type="image" onclick="new Messi('Welcome to amazing world of Biology and Info Technologies!', {title: 'Information', center: true, modal: true, viewport: {top: '5vh', left: '10%'}, titleClass: 'info',  
                                });" src="image/system_question_alt_02.png"/></p>
                    <p><form action="3dGBViewer.html">
              <select id="moveCameraChoice">
                  <option id = "1" value="chr-pos">Positions in chromosome</option>
                  <option id = "2" value="gene">Gene</option>
                  <option id = "3" value="coords">Model coordinates</option>
              </select>

                    <input id = "incoords" type="text" title="The format of data is 'x,y,z' or you can use 'chr# start end'." size="40" style=" width: 60%;" >      
                        <p><button id="moveButton" type="button">Explore</button></p>
                        <p>Current model: <i id="name_of_model"></i><br><a href="3dGB.html">Change Model</a></p>
                    </p>
                  </div>
                <div id="right">
                        <h4>Use your own data<input type="image" onclick="new Messi('3D Genome Browser allows user to use its own data of SNPs. For more information about the this, go to the \'About 3D Genome Browser\' tab.<br> To Download the Converter to adopt your sources to appropriate format - <a href=\'http://cs.mcgill.ca/~abutya/supplementary/3DCustomSNPDataConverter.jar\' target=\'_blank\'>click here</a>', {title: 'Information', center: true, modal: true, viewport: {top: '5vh', left: '10%'}, titleClass: 'info',  
                                });" src="image/system_question_alt_02.png"/></h4> 
                        Please specify a file:<br>
                        <input id = "f" type="file" name="datafile" size="40">
                    </p>
                    <div style="float:left; width: 50%">
                        <button id="submitCustomData" onclick="readFile();">Upload file</button>
                    </div>
                    <div style="float:right; width: 50%">
                        <button id="cleanButton" onclick="customerData = {}; $('button#cleanButton').button('disable'); isCustomerData = false;" disabled>Delete User Data</button>
                    </div>
                    <br>
                    <p id="progressBar" style="display:none; clear: both" ></p>
                </div>
              </div>
          </div>
          <div id="tabs-1">
                <div id="keys" style="display:none">
                    <img id="tab-icon" src="image/tab-icon.png" alt="Information">
                    <img id="letter-C-icon" src="image/letter-uppercase-C-icon.png" alt="Change mode">
                    <img id="letter-G-icon" src="image/letter-uppercase-G-icon.png" alt="SNP ChIP-Seq mapping">
                    <img id="letter-F-icon" src="image/letter-uppercase-F-icon.png" alt="ChIP-Seq colouring">
                    <img id="letter-R-icon" src="image/letter-uppercase-R-icon.png" alt="Remove ChIP-Seq colouring">
                    <img id="letter-P-icon" src="image/letter-uppercase-P-icon.png" alt="List genes in cube">
                    <img id="thermometer" src="image/thermometer.png" alt="Measure of colour">
                </div>
                <div id="detection-sign" >
                    <img id="exclamation-sign" src="image/exclamation.png" alt="SNP!">
                </div>
                <div id="blocker">
                    <div id="instructions">
                        <span style="font-size:40px">Click to Explore</span><br><br>
                        Supported browsers: Firefox, Google Chrome.
                    </div>
                </div>
          </div>
          <div id="tabs-3">
            <p><em>3DBD Genome browser</em>, contact: <a target='_blank' href='http://exascale.info/'>eXascale Infolab</a>:
                <a style="color: rgb(0,0,255)" href="mailto:phil@exascale.info?subject=[3D Genome Browser]">Philippe Cudre-Mauroux</a>, <a style="color: rgb(0,0,255)" href="mailto:ruslan@exascale.info?subject=[3D Genome Browser]">Ruslan Mavlyutov</a>; <br><br><a target='_blank' href='http://csb.cs.mcgill.ca/'>McGill University SoCS</a>: <a style="color: rgb(0,0,255)" href="mailto:jeromew@cs.mcgill.ca?subject=[3D Genome Browser]">Jérôme Waldispühl</a>, <a style="color: rgb(0,0,255)" href="mailto:alexander.butyaev@mail.mcgill.ca?subject=[3D Genome Browser]">Alexander Butyaev</a>.</p>
            
            <!--Share conteiner -->
            <div>
                <div class="button twitter" data-type="button_count"><a href="https://twitter.com/share" class="twitter-share-button" data-url="http://cs.mcgill.ca/~abutya/3dgenomebrowser/3dGB.html" data-text="I'm working with 3D Genome Browser, developed by[CSB group. McGill University] and [eXascale Infolab. Friburg University]">Tweet</a></div>
                <div class="fb-share-button" data-href="http://cs.mcgill.ca/~abutya/3dgenomebrowser/3dGB.html" data-type="button_count" data-text="I'm working with 3D Genome Browser, developed by[CSB group. McGill University] and [eXascale Infolab. Friburg University]">
                </div>
                <div class="g-plusone" data-size="tall" data-href="http://cs.mcgill.ca/~abutya/3dgenomebrowser/3dGB.html" data-text="I'm working with 3D Genome Browser, developed by[CSB group. McGill University] and [eXascale Infolab. Friburg University]" data-annotation="inline" data-width="300" ></div>
                <!--div class="g-plusone" data-annotation="inline" data-width="300"></div-->
                <!--g:plusone></g:plusone>
                <script type="text/javascript">
                    window.___gcfg = {
                        lang: 'en-US'
                    };
                    (function() {
                        var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
                        po.src = 'https://apis.google.com/js/platform.js';
                        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
                    })();
                </script-->
            <!--/div-->


          </div>
        </div>

        <div id="tabs-4">
            <h1>3D Genome Browser</h1>
            <hr>
            <nav class="toc">
                    <h2>Content:</h2>
                        <ol>
                            <li><a href="#introduction">About the 3D Genome Browser</a></li>
                            <li><a href="#functionality">Browser Functionality</a></li>
                            <li><a href="#memory-management">Memory Management</a></li>
                            <li><a href="#well-known-problems">Well-Known Problems</a></li>
                            <li><a href="#controls">Controls</a></li>
                        </ol>
                </nav>
                <hr>
                <h2 id="introduction">About the 3D Genome Browser</h2>
                <p>
                    Welcome to the 3D Genome Browser. This is the website that provides detailed description of the structure of Human Genome. This web browser is fully interactive 3D viewer that allows user to move through the 3D space of genome model, interact with system with a help of commonly-used input/output devices and retrieve data of genome sequence variations, ChIP-sequencing data etc. The data was collected from <a class = "external-link" href="http://www.1000genomes.org/" target="_blank">1000 Genomes Project</a> and <a class = "external-link" href="http://www.genome.gov/encode/" target="_blank">The ENCODE Project</a>.<br>
                    This browser has been implemented with a help of <i>Javascript technologies</i> and, in particular, <i>Three.js</i> - javascript library that provides an opportunity to work with WebGL-3D objects in web browser.<br>
                    It has been optimized for working with big sets of biological data and built on top of a NoSQL database for comfortable visualization, examination and data querying. In addition, the database contains several components that disitinguish this system among most Genome Browsers:</p>
                    <li>Sparse, adaptive 3D index</li>
                    <li>Immutable data chunks</li>
                <p>
                    Both of these components improve the standard approach to the storing the data. From the user side - it reduces the response time and, therefore, increases user's experience of exploring 3D structure of genome and its elements. 
                    <br>
                    <br>
                    The 3D Genome Browser is developed and maintained by Computational Structure Biology Group at Computer Science Department, McGill University, Canada and eXascale Infolab at the University of Fribourg, Switzerland.
                </p>
                <hr>
                <h2 id="functionality">Browser Functionality</h2>
                <p>The general idea of the 3D Genome Browser is to show the genome sequence in 3 dimensions, provide an opportunity to explore genome both in standard (linear) way and using advantages of space location of chromosomes, genes, their interactions. Another important feature of this system is the way of information representetion. In most cases, user can retrieve information while moving through the space in the bottom panel of the screen, or using special commands to get pop up window for detailed information.
                    <br>
                    This system provides wide variety of tools for exploring genome.<br>
                    In comparison with standard Genome Browsers we deal with 3D coordinates, models and associated with them biological entities. That is why it is important to provide an opportunity to change the current position in space with standard way in format  "chr [number of chromosome] [start position] [end position]", where any non numeric symbol can be separator (for instance, "chr 5: 1234567 - 1234765"); and in 3 dimensional way - format "X Y Z", where X,Y,Z are coordinates of particular point in database (this way is very specific and usually usefull for people, who want to make a connection between initial <i>Hi-C</i> data and visual representation; for instance, "147:2345:924"), any non numeric symbol can be separator as well. As 3D Genome Browser works with such biological data as genes, user can move the camera to look at the specific location of gene and its surroundings. Knowledge of the location of gene is not required.<br>
                    <table border = "1px" id='table_linear'>
                        <tr>
                            <th></th>
                            <th>B-Cell, Leukemia</th>
                            <th>B-Cell, Healthy</th>
                            <th>K562, Simulations</th>
                        </tr>
                        <tr>
                            <th>Positions in chromosome</th>
                            <td colspan="2"><i>chr12 12345-23456</i><br>OR<br><i>12345-23456</i><br>(this example is for <b>12</b> chromosome model)</td>
                            <td><i>chr12 12345-23456</i></td>
                        </tr>
                        <tr>
                            <th>Gene</th>
                            <td colspan="3"><i><a class = "external-link" href="http://www.ncbi.nlm.nih.gov/gene/7157" target="_blank">TP53</a></i><br>OR <i>any other name of gene</i> (case sensitive)</td>
                        </tr>
                        <tr>
                            <th>Model coordinates</th>
                            <td colspan="3"><i>5.23:4.534:1.89</i><br>Which corresponds to X, Y, Z coordinates in database</td>
                        </tr>
                    </table>
                <h6><i>Example of using search field of 3D Genome Browser</i></h6>
                    <br>
                    Fundamentally there are 3 different modes that allow user interact with system in different ways and/or retrieve special information from database.</p>
                <h3 id="func-linear">Linear mode</h3>
                <p>
                Basically, linear mode in 3D space is the putting old canons of representation in a new light. It easily can be compared with such genome browser as <a class = "external-link" href="http://genome.ucsc.edu/" target="_blank">UCSC Genome Browser</a> and track system, which it uses. User can examine and analyze only one sequence of genome at a time but instead of plane tables 3D Genome Browser uses partition of the screen on 2 parts: 3D models and panels with information that is appeared immediately by pointing to the specific part of the genome. To investigate specific part of genome <i>left click of mouse</i> will call popup window with almost the same information but with opportunity to click on any link and continue investigation on the <a class = "external-link" href="http://www.ncbi.nlm.nih.gov/" target="_blank">National Center for Biotechnology Information web site </a>.
                    <br>
                    Also, system provides an opportunity to change the size of observable area of genome sequence and, therefore, of retrieving data from the server by scrolling the mouse (up to several thousands of nucleotides). 
                    <br>
                    Besides, group of scientist raised an issue whether it is possible to map ChIP-sequencing data (Transcription Factors) and Single Nucleotide Polymorphisms (SNPs). This problem has been solved by aligning the position of SNP in chromosome and particular Transcription Factor. Thus, in this mode the system provides this feature for linear part of chromosome. The user can use it by selecting particular <i>linear</i> part of chromosome and then pressing the key "G". There will be shown popup windom that contains basic information about chromosome, SNP position, SNP identificator (click on it to find more information on The National Center for Biotechnology Information website), transcription factor and its effect level. For scientists' comfort, dynamic filtering system has been integrated. As well <b>filtered</b> data can be easily exported in CSV format by clicking "Export to CSV".
                    <br>
                </p>
                <h3 id="func-cubic">Cubic mode</h3>
            <p>
                Currently, almost all Genome Browsers use linear approach for showing the biggest part of data. That is observable area is only integral and complete part of one genome's chromosome. But investigation of interactions between two not connected areas of genome is still open-ended problem.    
                Cubic mode of 3D Genome Browser provides to user an opportunity to use almost all advantages of 3 dimensions of space. Basic shape for retrieveing of data is resizable cube. Once pointer is on the genome strand, the cube will be automatically built around this point. At the same time scrolling action is available for user to change size of observable area. Data that is available for all parts of strands that are located inside the cube will be shown on the popup window after <i>left click of mouse</i>. It contains information about all parts of all chromosomes that fit in the cube: chromosome with positions and complete list of SNPs (links to NCBI website for deep investigation).
                <br>
                Same as previous mode (<i>Linear Mode</i>) system provides an opportunity to map ChIP-Sequencing data to SNPs that are fit in the range of the particular Transcription Factor. The difference is that in the cubic mode can investigate all strands that are in the cubic area.<br>
                <b>Important:</b> All actions for this mode are available for any strand from the space cube, where user is currently located (see <a href="#memory-management">Memory Management</a> chapter).
            </p>
                <h3 id="func-chipseq">ChIP-Seq mode</h3>
            <p>
                From biological terminology, ChIP-sequencing is basically the method to analyze protein (or Transcription Factor) interactions with DNA. By using this mode user gets an opportunity to visualize all transcription factors that have been found for particular Cell Type and investigate it in details using <a class = "external-link" href="https://genome.ucsc.edu/" target="_blank">UCSC genome browser</a>. Visualization step starts automatical when user switch mode to <i>ChIP-Seq mode</i>. There will be appeared colored parts of genome (from green to red), which are the measured representation of protein-DNA interaction. The color identifies the level of affection from the weakest (green) to the strongest (red) level. In numbers that means: effect level 0 - green, effect level 1000 - red.<br>To call popup window with the general information and link to UCSC Genome Browser user can point to the colored part of genome and left click of mouse. While moving to another cube, ChIP-Seq data will not be coloured untill user clicks <b>F</b> key. To refresh the memory and to delete <b>whole</b> stored information (ChIP-Seq data, visualization entities) user should click <b>R</b> key. In this case all colored segments of genome will be disappeard.  
                <br><b>Important:</b> In case of switching to another mode, all colored segments of genome will be disappeared (see <a href="#memory-management">Memory Management</a> chapter).
            </p>
                <br>
                <h3 id="func-gene">Genes</h3>
                <p><i>The 3D Genome Browser</i> provides an opportunity to work with genes as well. With help of this system user can move camera to the location of particular gene and colour gene in logarithmic scale: <b>log(GENE_EXPRESSION_LEVEL)</b> (normalized according to the <i>maximum</i> gene expression level over the whole genome; green-red colors are used for coloring). Also system is able to list all genes which are available in current cube (fully or partly). Here user can choose particular gene, find some information and ask system to colour it.</p>
                <h3 id="func-ownSNPData">Using customer's SNP data</h3>
            <p>
                Originally, in Linear and Cubic modes scientist can retrieve SNP data that initially has been collected from enormous libraries of <a class = "external-link" href="http://www.1000genomes.org/" target="_blank">1000 Genomes Project</a>. It is usefull for research, but it can't help to typical customer to investigate his own mutations even if he has required information from Genome Center. 3D Genome Browser provides an opportunity to securely upload the data to the genome browser and to start comparison SNPs with those that came from the 1000 Genome Project. All calculations (which are connected with customer's snp data) are implemented locally on the user's machine and, thus, data cannot be sent to server and/or distributed in SNP resources.<br>

                After choosing the 3d Model of genome (its cell type), on the first tab user can find <i>Use your own data</i>. To start using this feature user should choose file with SNP Data in specific format. 3D Genome Browser accepts only JSON format with data: 
                    <ol>
                        <li>Number of chromosome ("1", "2" etc) - Once per occurrence;</li>
                        <li>Position of the SNP in current chromosome</li>
                        <li>SNP identificator (for example, "rs12564807")</li>
                        <li>Genotype (for example, "AA")</li>
                    </ol>
                    <br><b>Example of the data:</b> <i>{"1" : [[734462,"rs12564807","AA"], ...], "2" : [[...], [...]], ...}</i><br><br>
                    <i>To simplify converting process, we have implemented simple converter (Java-based application).</i> It can be downloaded <a href='http://cs.mcgill.ca/~abutya/supplementary/3DCustomSNPDataConverter.jar' target='_blank'>here</a>. Detailed description of this can be found <a href='http://cs.mcgill.ca/~abutya/supplementary/converterhelp.html' target='_blank'>here</a>.
                    <br><br>

                Once the data is uploaded in system, you have an opportutinity to compare your SNPs with the SNPs that came from server. To do this:
                <ol>
                    <li>Choose <i>Linear mode</i> (for current reliase it works only for linear mode)</li>
                    <li>Try to point to different parts of genome and the same moment observe an exclamation mark to the left from the line that defines your current mode.</li>
                    <li>Left click of mouse and you will find additional column "@Customer Data/Genotype".</li>
                    <li>Using scrolling move to complete line with SNP's identificator, genotype from system and genotype from <i>customer's SNP data</i>. It will be highlighted in either red of green color, depending on match or mismatch of two genotypes.</li>
                </ol>
                <br>
                <b>Important: </b>After finishing the work with <i>cutomer's SNP data</i> to increase the performance of local machine - go to the first "Welcome Page/UI" tab and click "Delete User Data" button (see <a href="#memory-management">Memory Management</a> chapter).

            </p>

            <hr>
            <h2 id="memory-management">Memory Management</h2>
            <p>
                &nbsp;In spite of the fact that this Genome Browser is the website, biggest part of the processing of the data that represents on the user's screen, is on the client machine. Also, the drawing of 3D objects is very memory consuming process. That means the development has been limited by the capabilities of typical computer. To reduce the local machine load, development group introduced the Memory Management Policy.
                <br><br>
                <li>The success of the <a class = "external-link" href="http://web.ornl.gov/sci/techresources/Human_Genome/index.shtml" target="_blank"><b>Human Genome Project</b></a>, first release of draft of human genome and later investigation of Hi-C methodology made possible to create 3D model of full genome. As human genome contains 23 pairs of chromosome and the length of each of them varies in range from 48 to 250 million nucleotides, it is not reasonable to represent all chromosomes at a time: it is not informative and could be ruinous for productivity of local machine. To solve this issue, space has been divided by cubes of fixed size and, thus, user by moving through the space can consequently upload the data from the server.</li>
                <br>
                <li>Another important feature of the policy is the consistent removing of 3D objects from the memory when current distance to the 3D object is getting be greater than one cube. It allows system to balance between memory cosumption and visibility.</li>
                <br>
                <li>As it is mentioned above, to find out 3D objects in specified region <i>Octree</i> approach has been used. Number of nodes in such a tree for specified model in fixed-size cube and resolution can be tremendous. For this reason, user can retrieve data in cubic mode only in the cube, where user currently is located. By moving through the space, crossing the border between cubes the system fully rebuilds an octree. </li>
                <br>
                <li>One of the most important rule of the memory management in this system is to clean ChIP-Seq data when user changes mode from "ChIP-Seq mode". Performance of a local machine fully depends on the number of objects primarily, and, secondly, on the length of the elements.</li>
                <br>
                <li>In 3D Genome Browser user can use own data (see <a href="#func-ownSNPData">Using customer's SNP data</a> chapter), which creates uncontrollable spending of memory by storing (usually 20+ Mb) file there. By using this feature, user is responsible for the performance of his machine. To accelerate machine, after finishing the work with own data open the first tab and click "Delete User Data" button.</li>

            </p>
            <hr>
            <h2 id="well-known-problems">Well Known Problems</h2>
            <p>Currently we defined that 3D Genome Browser supports such web browsers as Google Chrome and FireFox. However, FireFox has its own implementation of Pointer Lock API, which fully depends on FullScreen API. In other words, to use fully 3D Genome Browser in FireFox, firstly make sure that you always in FullScreen mode. Otherwise, it can cause not correct behaviour from the system.
            </p>
            <hr>
            <h2 id="controls">Controls</h2>
            <p>
                <table id = "table_linear">
                  <tr>
                    <th>Mode</th>
                    <th>Key</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td>Linear</td>
                    <td>Left Click</td>
                    <td>Get popup window with basic information about chromosome, selected positions, sequence of DNA, and SNPs</td>
                  </tr>

                  <tr>
                    <td>Cubic</td>
                    <td>Left Click</td>
                    <td>Get popup window with basic information about selected strands, chromosomes, positions and SNPs</td>
                  </tr>

                  <tr>
                    <td rowspan = "3">ChIP-Seq</td>
                    <td>Left Click</td>
                    <td><b>For colored part of strand:</b> get popup window with basic information about the Transcription Factor, its positions and level of effect</td>
                  </tr>
                  <tr>
                    <td>F</td>
                    <td>Colour all strands in current cube according to the ChIP-Seq experiment data: Transcription Factor and effect level (<b>only for cube other from one where mode has been activated</b>).</td>
                  </tr>
                  <tr>
                    <td>R</td>
                    <td>Refresh field of view: to erase all coloured parts of strands from the memory. (It will immediately improve performance of user's local machine.)</td>
                  </tr>

                  <tr>
                    <td rowspan="2">Linear and Cubic</td>
                    <td>G</td>
                    <td>Get popup window with mapped ChIP-Seq data and SNPs</td>
                  </tr>
                  <tr>
                    <td>+/- (scroll)</td>
                    <td>Change size of observable area.</td>
                  </tr>

                  <tr>
                    <td rowspan="5">All modes</td>
                    <td>C</td>
                    <td>Change mode in loop from Linear to Cubic, from Cubic to ChIP-Seq and from ChIP-Seq to Linear mode</td>
                  </tr>
                  <tr>
                    <td>Tab</td>
                    <td>Get general information about the mode</td>
                  </tr>
                  <tr>
                    <td>W,S,A,D</td>
                    <td>Move in space Forward, Back, Left, Right respectively</td>
                  </tr>
                  <tr>
                    <td>Mouse</td>
                    <td>Look around</td>
                  </tr>
                  <tr>
                    <td>P</td>
                    <td>List all genes available in current cube with some information and opportunity to colour it</td>
                </tr>
                </table>
            </p>
            <hr>
            
        </div>

        <script>
            var isChipSeqAvailable = false;
            var isCustomerData = false;
            var customerData;
            var contents;
            var previousLength = 0;
            var isInProgress = true;
            var file;
            var progress_bar_div;


            function readFile() {
                previousLength = 0;
                
                isInProgress = true;
                progress_bar_div = document.getElementById('progressBar');
                progress_bar_div.style.display = '';
                $('p#progressBar').text("I'm still working on this file");
                var reader = new FileReader();
                
                reader.onload = function(event) {
                    contents = event.target.result;
                    isInProgress = false;
                    if (DEBUG) console.log("Done ");
                };
                
                reader.onerror = function(event) {
                    console.error("File cannot be read " + event.target.error.code);
                    isInProgress = false;
                };

                file = document.getElementById("f").files[0];
                if (typeof file == 'undefined') {
                    $('p#progressBar').text("Error: Select the file");
                    isInProgress = false;
                    return;
                }
                reader.readAsText(file);
                progressBarFunction();
                if (DEBUG) console.log("Let's write something")
                $('button#cleanButton').button("enable");
                isCustomerData = true;
            }

            function progressBarFunction() {
                if (DEBUG) console.log(isInProgress + "  " + (typeof contents != 'undefined') + "  "  + file.size + "|now = " + ((typeof contents != 'undefined')?contents.length:""));
                if ((typeof contents === 'undefined')  || ( previousLength == 0 || previousLength != contents.length)) {
                    if ((typeof contents === 'undefined')) previousLength = 0;
                    else previousLength = contents.length;
                    if (DEBUG) console.log("see this 1");
                    setTimeout(progressBarFunction, 1000);
                    // if (DEBUG) console.log("see this after setTimeout");
                } else {
                    if (DEBUG) console.log("See this 2");
                    $('p#progressBar').text("Done");
                    customerData = JSON.parse(contents);
                    contents = '';
                    for (var us in uploaded_splines) {
                        var tempArr = us.split('-');
                        var chridOnlyNum = tempArr[0].replace(/([\d]+).*/,"$1");
                        var arr = AdaptUploadedSpinesForCustomerData(parseInt(tempArr[1]), parseInt(tempArr[2]), chridOnlyNum);
                        uploaded_splines[us][2] = arr[0];
                        uploaded_splines[us][3] = arr[1];
                        uploaded_splines[us][4] = chridOnlyNum;
                    }
                }
            }
        </script>
		<!-- main part -->
        <script>
            var ChangeCameraPositionBoolean = true;
            var globalArrayForWindow;

            var MAX_WAIT_INTERVAL = 10000;
            var waitInterval = 0;
            var resp_count = 0, req_count = 0;
            var draw_tube_response_counter = 0, draw_tube_request_counter = 0;
            var tableStrContent = '';
            var healthness;
            var STEP;
            var NUMBER_LIMIT;
            var isOneCubeOctree = true;

            var rgn;//made it global for table
            var urlParams;
            (window.onpopstate = function () {
                var match,
                    pl     = /\+/g,  // Regex for replacing addition symbol with a space
                    search = /([^&=]+)=?([^&]*)/g,
                    decode = function (s) { return decodeURIComponent(s.replace(pl, " ")); },
                    query  = window.location.search.substring(1);

                urlParams = {};
                while (match = search.exec(query))
                   urlParams[decode(match[1])] = decode(match[2]);
            })();
            var serviceForStructure, particularChromosome, disease3Dexpression;
            var current_cell_line;
            var zeroCoordinate;
            var startPositionOfCamera;
            var scaleFactor; 
        	var blockSize;
            var NODE_THRESHOLD = 625;
            var radiusOfTube = 10;

            var radiusSphere = 40, segmentsWidth = 32, segmentsHeight = 16; //sphere zone parameters
            var maxRadiusSphere = 140, minRadiusSphere = 20;

            wrong_all_dialog_message = "Wrong format of input data. Please enter coordinates in format 'X,Y,Z' to specify your next location in Genome space. Also you can move to the place of particular part of specified chromosome. Format: 'chr#,#,#'. Separator can be any symbol except for numeric one. In case of using 3d model of particular chromosomes you can use only this chromosome.<br>As well you can move to and color particular gene (if it exists in the database). Format 'chr#,NAME_OF_GENE'. Not available for simulated 3d model.";
            
            wrong_gene_dialog_message = "Wrong format of input data. Please use the following format: 'gene NAME_OF_GENE'. Not available for simulated 3d model.";

            switch (urlParams["3dmodel"]){
                case "BCL-1" : 
                {
					modelInit(urlParams["3dmodel"], {x: 1.5196, y: 4.625, z: 1.75},{ x:3.673729257641921, y:3.361283842794761, z:3.6355240174672496});
					break;
				}
                case "BCL-2" : 
                {
					modelInit(urlParams["3dmodel"], {x: 2.607, y: 3.066, z: 2.406},{ x:3.5586804979253115, y:3.9493983402489605, z:3.7101618257261406});
					break;
				}
                case "BCL-3" :
                {
					modelInit(urlParams["3dmodel"], {x: 3.396, y: 3.129, z: 4.991},{ x:4.119121827411169, y:3.450279187817259, z:3.734208121827414});
					break;
				}
                case "BCL-4" : 
                {
					modelInit(urlParams["3dmodel"], {x: 4.637, y: 1.413, z: 2.748},{ x:3.7957631578947373, y:3.8731684210526316, z:3.5223000000000004});
					break;
				}
                case "BCL-5" : 
                {
					modelInit(urlParams["3dmodel"], {x: 6.1960, y: 4.679, z: 4.901},{ x:3.683418994413409, y:4.332815642458104, z:3.7095418994413416});
					break;
				}
                case "BCL-6" : 
                {
					modelInit(urlParams["3dmodel"], {x: 2.6, y: 1, z: 2.3},{ x:4.1948284023668645, y:2.678230769230768, z:2.881508875739646});
					break;
				}
                case "BCL-7" : 
                {
					modelInit(urlParams["3dmodel"], {x: 2.5224339672252576, y: 2.8265053937650886, z: 2.6624181521072248},{ x:3.364528662420382, y:3.913605095541399, z:2.9429808917197455});
					break;
				}
                case "BCL-8" : 
                {
					modelInit(urlParams["3dmodel"], {x: 3.384638770206183, y: 2.7213556491985345, z: 3.2190198759600035},{ x:4.092013793103449, y:2.7636482758620704, z:2.549186206896552});
					break;
				}
                case "BCL-9" : 
                {
					modelInit(urlParams["3dmodel"], {x: 1.1286286205784912, y: 2.34872326069342, z: 2.7515753634198},{ x:3.3798629032258067, y:3.329379032258067, z:4.533451612903225});
					break;
				}
                case "BCL-10" : 
                {
					modelInit(urlParams["3dmodel"], {x: 3.7002137110319437, y: 2.803395113630164, z: 2.8327274044350967},{ x:4.024348148148149, y:2.8717259259259267, z:3.472244444444445});
					break;
				}
                case "BCL-11" : 
                {
					modelInit(urlParams["3dmodel"], {x: 2.9175686487197745, y: 3.0422142962947305, z: 2.0713270276646902},{ x:3.201857142857144, y:2.6029022556390986, z:3.3891654135338354});
					break;
				}
                case "BCL-12" : 
                {
					modelInit(urlParams["3dmodel"], {x: 4.174361780360315, y: 3.011481034745547, z: 4.752406682114412},{ x:3.6681136363636364, y:5.033348484848483, z:3.86771212121212});
					break;
				}
                case "BCL-13" : 
                {
					modelInit(urlParams["3dmodel"], {x: 3.915946578330066, y: 2.10311133236101, z: 2.2040866952662914},{ x:3.6534795918367333, y:2.967959183673469, z:2.6533877551020413});
					break;
				}
                case "BCL-14" : 
                {
					modelInit(urlParams["3dmodel"], {x: 3.816070125510321, y: 2.6803492066361, z: 2.2112362739538534},{ x:4.920382022471911, y:3.0371235955056184, z:2.962157303370787});
					break;
				}
                case "BCL-15" : 
                {
					modelInit(urlParams["3dmodel"], {x: 2.287786912326149, y: 2.289238772912303, z: 2.672768601749768},{ x:2.086650602409638, y:2.8645180722891563, z:3.31078313253012});
					break;
				}
                case "BCL-16" : 
                {
					modelInit(urlParams["3dmodel"], {x: 2.3565839610562507, y: 3.1745956368632826, z: 3.6769545232477876},{ x:3.0347160493827157, y:2.190938271604938, z:2.9798024691358016});
					break;
				}
                case "BCL-17" : 
                {
					modelInit(urlParams["3dmodel"], {x: 2.6369316396175915, y: 2.7422466265810446, z: 2.2013006074737618},{ x:3.909417721518987, y:2.718012658227848, z:2.9789999999999996});
					break;
				}
                case "BCL-18" : 
                {
					modelInit(urlParams["3dmodel"], {x: 2.7963916541086737, y: 3.2310423850305496, z: 2.717080901779388},{ x:3.4595974025974034, y:3.1485194805194805, z:2.529337662337662});
					break;
				}
                case "BCL-19" : 
                {
					modelInit(urlParams["3dmodel"], {x: 2.422579864207846, y: 3.00588379696229, z: 2.779965908530172},{ x:2.3159298245614037, y:3.315842105263157, z:3.0585614035087723});
					break;
				}
                case "BCL-20" : 
                {
					modelInit(urlParams["3dmodel"], {x: 2.714724725538362, y: 2.9557876871210444, z: 2.893564357748228},{ x:2.401258064516129, y:3.6485483870967754, z:2.709129032258064});
					break;
				}
                case "BCL-21" : 
                {
					modelInit(urlParams["3dmodel"], {x: 3.976763264996193, y: 2.975517476333303, z: 2.6491180063221886},{ x:2.869444444444444, y:2.827444444444444, z:2.378972222222222});
					break;
				}
                case "BCL-22" : 
                {
					modelInit(urlParams["3dmodel"], {x: 2.12026287716053, y: 3.3174266856077033, z: 3.224190734706632},{ x:2.7148055555555555, y:2.870527777777777, z:2.624861111111111});
					break;
				}
                case "BCL-23" : 
                {
					modelInit(urlParams["3dmodel"], {x: 2.2093499344016747, y: 6.19408957037137, z: 3.0928600396076003},{ x:3.0167058823529405, y:4.037333333333331, z:2.639921568627452});
					break;
				}
                case "BCH-1" : 
                {
					modelInit(urlParams["3dmodel"], {x: 2.028643447604918, y: 2.890738383622912, z: 4.109576482443055},{ x:3.307488105726872, y:2.985998237885467, z:3.163096916299559});
					break;
				}
                case "BCH-2" : 
                {
					modelInit(urlParams["3dmodel"], {x: 3.199904037434262, y: 3.5599361421035023, z: 2.016223358671252},{ x:3.221269230769233, y:2.911872073578596, z:3.3352842809364542});
					break;
				}
                case "BCH-3" : 
                {
					modelInit(urlParams["3dmodel"], {x: 3.6552218202817075, y: 2.8453974944543536, z: 2.4446027459009483},{ x:3.242031729785053, y:2.7875035823950856, z:3.167759467758448});
					break;
				}
                case "BCH-4" : 
                {
					modelInit(urlParams["3dmodel"], {x: 2.071287723765832, y: 3.0877035224328813, z: 2.78887829509825},{ x:2.718669141039237, y:2.7089554612937414, z:3.1495906680805956});
					break;
				}
                case "BCH-5" : 
                {
					modelInit(urlParams["3dmodel"], {x: 3.6493915149963545, y: 3.2130827648406872, z: 2.5536481253807897},{ x:3.429731762065087, y:2.71439618406285, z:2.7418821548821573});
					break;
				}
                case "BCH-6" : 
                {
					modelInit(urlParams["3dmodel"], {x: 2.4840182088706366, y: 1.679119369905898, z: 2.8160299181144923},{ x:3.281967895362664, y:3.2437883472057076, z:2.403865636147444});
					break;
				}
                case "BCH-7" : 
                {
					modelInit(urlParams["3dmodel"], {x: 2.2807329066853628, y: 2.672600303671124, z: 3.7860452041377872},{ x:2.2095269230769223, y:3.0074730769230777, z:2.851666666666671});
					break;
				}
                case "BCH-8" : 
                {
					modelInit(urlParams["3dmodel"], {x: 2.6459739239516518, y: 2.6391411828461817, z: 3.975179853417516},{ x:2.234738161559888, y:2.3231490250696405, z:3.339614206128136});
					break;
				}
                case "BCH-9" : 
                {
					modelInit(urlParams["3dmodel"], {x: 2.773577392942734, y: 2.5921210446418863, z: 2.2028152115862745},{ x:3.109446078431373, y:2.3603235294117653, z:2.6150473856209167});
					break;
				}
                case "BCH-10" : 
                {
					modelInit(urlParams["3dmodel"], {x: 2.6702232188740513, y: 2.531886396842844, z: 2.8187572029371903},{ x:3.035225563909773, y:2.8323819548872153, z:3.1028436090225546});
					break;
				}
                case "BCH-11" : 
                {
					modelInit(urlParams["3dmodel"], {x: 3.1019471317951934, y: 3.856279271263897, z: 1.6510631427705267},{ x:2.3354901365705616, y:3.2146722306525017, z:2.799534142640363});
					break;
				}
                case "BCH-12" : 
                {
					modelInit(urlParams["3dmodel"], {x: 4.11109074425881, y: 2.7114129501017032, z: 2.2341538540683525},{ x:3.179316030534353, y:2.7677145038167947, z:2.7698549618320603});
					break;
				}
                case "BCH-13" : 
                {
					modelInit(urlParams["3dmodel"], {x: 2.3886978400144803, y: 3.013187538800507, z: 2.2243349109628587},{ x:2.8852058212058194, y:3.0113097713097714, z:3.111401247401248});
					break;
				}
                case "BCH-14" : 
                {
					modelInit(urlParams["3dmodel"], {x: 1.55303995186045, y: 2.197019566042211, z: 2.906060979462621},{ x:2.557314479638009, y:2.5030429864253394, z:3.365572398190047});
					break;
				}
                case "BCH-15" : 
                {
					modelInit(urlParams["3dmodel"], {x: 4.1430899937886165, y: 2.206063652812622, z: 3.2603409310289},{ x:2.9237128953771303, y:2.9451435523114364, z:2.900637469586373});
					break;
				}
                case "BCH-16" : 
                {
					modelInit(urlParams["3dmodel"], {x: 4.039037458257831, y: 2.5580294526351235, z: 1.929846300832198},{ x:3.264806045340051, y:2.5466851385390425, z:3.101677581863981});
					break;
				}
                case "BCH-17" : 
                {
					modelInit(urlParams["3dmodel"], {x: 4.133035698044761, y: 2.462407039945692, z: 4.195447668839935},{ x:2.5917182741116767, y:3.2044492385786794, z:3.0736827411167527});
					break;
				}
                case "BCH-18" : 
                {
					modelInit(urlParams["3dmodel"], {x: 2.4204389544257787, y: 2.7924236722558198, z: 2.1668763080083284},{ x:2.121180851063831, y:3.2538510638297864, z:2.9228377659574463});
					break;
				}
                case "BCH-19" : 
                {
					modelInit(urlParams["3dmodel"], {x: 1.8115930828234836, y: 2.904626714948919, z: 2.9414152397511137},{ x:2.229637010676155, y:3.005256227758008, z:2.4051992882562256});
					break;
				}
                case "BCH-20" : 
                {
					modelInit(urlParams["3dmodel"], {x: 3.49361077188669, y: 4.207871717048262, z: 2.4505625440882604},{ x:3.1584518272425277, y:3.2092325581395333, z:2.645049833887044});
					break;
				}
                case "BCH-21" : 
                {
					modelInit(urlParams["3dmodel"], {x: 3.574121184451935, y: 2.6698422763157805, z: 2.7381431250213564},{ x:3.5315317919075175, y:2.255953757225433, z:2.4053063583815026});
					break;
				}
                case "BCH-22" : 
                {
					modelInit(urlParams["3dmodel"], {x: 3.45545567678287, y: 3.310117407814258, z: 2.9226027443824822},{ x:2.6691420454545454, y:3.209954545454544, z:2.4944659090909096});
					break;
				}
                case "BCH-23" : 
                {
					modelInit(urlParams["3dmodel"], {x: 3.166116488821329, y: 3.753381136085846, z: 2.6700131713938355},{ x:2.9378922470433584, y:3.216975032851509, z:2.783600525624178});
					break;
				}
                default:
                {
                    modelInit(urlParams["3dmodel"], {x : 0, y: 10, z: 0}, {x : 400.0, y: 150.0, z: 0.0})
                    break;
                }
            }


            
            var lastRegion, lastIntersection;
            // var arrayOfCHIPCoveredTubes = [];
            var lastMode;
            var _messi;
            var meter;
            var minMeter, maxMeter, stepScroll;
            var is_modal_opened = false;
            var mod_message_div;
            var MAX_CHIP_LVL = 1000;
            var FIXED_HEIGHT_SCREEN = 495;
            var percentColors = [
                { pct: 0.0, color: { r: 0x00, g: 0xff, b: 0 } },
                { pct: 0.5, color: { r: 0x88, g: 0x88, b: 0 } },
                { pct: 1.0, color: { r: 0xff, g: 0x00, b: 0 } } ];
            var is_coloring_of_chipseq = false;
            var deb_var = [];
            var lastBlockIndicesStr;
            var regexpPattern = /^([\d\-]+)[^\d\-]+([\-\d]+)[^\d\-]+([\d\-]+)[^\d\-]*/i; //[num] smth(1+) [num] smth(1+) [num] smth(0+)
            var regexpPatternChrms;// = /chr[^\d]*([\d]+[ab]*)[^\dab]+([\d]+)[^\d]+([\d]+)[^\d]*/; //format smth(0+) [num] smth(1+) [num] smth(1+) [num] smth(0+)
            // var regexpPatternGene = /gene[\s]+([^\s]+)\s*$/;
            var regexpPatternGene = /^[\s]*([^\s]+)\s*$/;
            var regexpPatternURL = /([\dXY]{1,2})[_]*([abAB]*)[^\d]+([\d]+)[^\d]+([\d]+)/ ;
            var divElement;
            var test_mesh;
        	var DEBUG = false;
			// zero point in local coordinates translates into zeroCoordinate in the model coordinates        
        	
        	// 1 point in the model coordinates =  scaleFactor points in local coordinates
        	
        
            var camera, scene, renderer, controls;
            var projector = new THREE.Projector();
            
            var infoBlock, staticBlock, keys_block;
            
            var selectionMesh;
            
            var targetBall;
            
            var basesInSelection = 1500;
            
            var sphere;
            var uploaded_area = {};
            
            var uploaded_splines = {};
            var uploaded_splines_chip = {};
            var uploaded_splines_selection = {};
            var uploaded_splines_genes = {};

            var chipSecCubes = {};

            var time = Date.now();

			// 3d dna molecules
            var objects = [];

            var chipObjects = [];

            var geneObjects = [];

            var suggestionGeneInCube = {};
            
            var regionData = {};

            var checkboxes = [];
			
			// dark screen, when the game starts
            var blocker = document.getElementById( 'blocker' );
            var instructions = document.getElementById( 'instructions' );
            
            var position = "";

            var snp_chip_seq_window;

            var is_plane_mode = true; //start with linear mode
            var mode_name = 'Linear mode';
            var mode_id = 0;
            var NUMBER_OF_MODES = 3;
            var leftPoint = null, rightPoint = null, assumedPoint = null;
            var geneDrawQueue = [];
            
            function modelInit(model, _startPositionOfCamera, _zeroCoordinate) {
                zeroCoordinate = _zeroCoordinate;
                if (DEBUG) console.log(_startPositionOfCamera)
                if (model.match(/^bcl-([1-9]|1[0-9]|2[0-3]|[xy])$/i)) {
                    current_cell_line = 'B-cell';
                    isChipSeqAvailable = false;
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    name_of_model = "B-Cell, Leukemia, Chromosome " + particularChromosome;
                    healthness = "m=leukemia";
                    disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    // scaleFactor = 12000; blockSize = 0.8;
                    scaleFactor = 5000; blockSize = 1;
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    // radiusOfTube = 60; //was 25
                    radiusOfTube = scaleFactor/12000*60; //was 25
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;
                    NUMBER_LIMIT = 50000;
                    STEP = 500000; //normal vs leukemia statistical approximation
                    regexpPatternChrms = /^(chr\s*([1-9]|1[0-9]|2[0-3]|[xy])[_ab]*\s+)*\s*([\d]+)[^\d]+([\d]+)[^\d]*/i;
                } else if (model.match(/^bch-([1-9]|1[0-9]|2[0-3]|[xy])$/i)) {
                    current_cell_line = 'GM06990';
                    isChipSeqAvailable = true;
                    serviceForStructure = "3d";
                    particularChromosome = parseInt(urlParams["3dmodel"].split("-")[1]);
                    name_of_model = "B-Cell GM06990, Healthy, Chromosome " + particularChromosome;
                    healthness = "m=normal";
                    disease3Dexpression = healthness + "&chr=" + particularChromosome + "&";
                    // scaleFactor = 12000; blockSize = 1; // before 1300 | 3
                    scaleFactor = 5000; blockSize = 1; // before 1300 | 3
                    NODE_THRESHOLD = NODE_THRESHOLD*scaleFactor/10;
                    // radiusOfTube = 60; //was 25
                    radiusOfTube = scaleFactor/12000*50; //was 25
                    minRadiusSphere = 70;
                    maxRadiusSphere = 180;
                    radiusSphere = 100;
                    NUMBER_LIMIT = 30000;
                    STEP = 200000; //normal vs leukemia statistical approximation
                    regexpPatternChrms = /^(chr\s*([1-9]|1[0-9]|2[0-3]|[xy])[_ab]*\s+)*\s*([\d]+)[^\d]+([\d]+)[^\d]*/i;
                } else {
                    isChipSeqAvailable = true;
                    disease3Dexpression="";
                    current_cell_line = 'K562';
                    name_of_model = "K562 Cell Type, All Chromosomes, Simulation"
                    scaleFactor = 10; 
                    blockSize = 400;
                    serviceForStructure = "js_test";
                    disease = "";
                    // $('option#2').attr('disabled','disabled');
                    STEP = 700;
                    regexpPatternChrms = /^(chr\s*([1-9]|1[0-9]|2[0-3]|[xy])[_ab]*\s+)([\d]+)[^\d]+([\d]+)[^\d]*/i
                }
                $("i#name_of_model").text(name_of_model);
                wrong_chrms_dialog_message = "Wrong format of input data. Please, do use the following format: '" + ((serviceForStructure=="3d")?"[chr#,]#,#', where the first part is optional" : "chr#,#,#'") + ". \nSeparator can be any symbol except for numeric one." +
                ((serviceForStructure=="3d")?" In terms of current model, you can use only " + particularChromosome+" chromosomes." : "");

                startPositionOfCamera = Global2local({x:_startPositionOfCamera.x, y:_startPositionOfCamera.y, z:_startPositionOfCamera.z});
            }

            function validate(incoords, moveCameraChoice) {
                switch(moveCameraChoice) {
                    case "coords" :
                    {
                        if (incoords.match(regexpPattern) != null) {
                            ChangeCameraPosition(incoords, 0);
                            return true;
                        } 
                        break;
                    }
                    case "chr-pos" :
                    {
                        var temp = incoords.match(regexpPatternChrms);
                        if (temp) {
                            if (particularChromosome && temp[2] && temp[2].toUpperCase() != particularChromosome.toUpperCase()) {
                                $("#dialog-message").text(wrong_chrms_dialog_message).dialog("open");
                                return false;
                            }
                            ChangeCameraPosition(incoords, 1);
                        } else {
                            $("#dialog-message").text(wrong_chrms_dialog_message).dialog("open");
                                return false;
                        }
                        break;
                    }
                    case "gene" :
                    {
                        var temp = incoords.match(regexpPatternGene);
                        if (temp) {
                            ChangeCameraPosition(incoords, 2);
                            break;
                        } else {
                            $("#dialog-message").text("Wrong format of input data. Please, enter only the name of the gene.").dialog("open");
                                return false;
                        }
                    }
                }

                // if (incoords.match(regexpPatternChrms) != null) {
                //     if (incoords.replace(regexpPatternChrms, "$1") != particularChromosome) {
                //         $("#dialog-message").text(wrong_chrms_dialog_message).dialog("open");
                //         return false;
                //     }
                //     ChangeCameraPosition(incoords, 1);
                // } else if (serviceForStructure != "js_test" && incoords.match(regexpPatternGene) != null ) {
                //     ChangeCameraPosition(incoords, 2);
                // } else {
                //     $("#dialog-message").text(wrong_all_dialog_message).dialog( "open" );
                // }
            }

            function getjsonChrPositionFunction(_chr, promoter_begin, bp, _temp_foo, isLeft, p) {
                if (DEBUG) console.log("ppp = " + p)
                $.getJSON("http://1kgenome.exascale.info/chr_pos?chrid="+_chr+"&bp="+bp+((!healthness)?"":"&" + healthness) + "?callback=?", 
                null,
                function(data) {
                    // res_num++; //increase number of responses
                    var t = promoter_begin - data[0];
                    // var k = t?t<0?-1:1:0;
                    var k = t<0?-1:1;
                    // if (DEBUG) console.log(k + "  " + isLeft);
                    if (isLeft==true) { //from the left to right
                        if (k==1) {
                            if (p >10) { //limit for the end of the strand
                                rightPoint = data;
                                _temp_foo(promoter_begin);
                                showErrorAlertModalWindow("It looks like you are trying to look out the range of chromosome. Last point of the chromosome is shown.")
                            } else {
                                assumedPoint = data[0] + k * p * STEP;
                                if (DEBUG) console.log("1) p = " + p + "; assumedPoint = " + assumedPoint);

                                getjsonChrPositionFunction(_chr, promoter_begin, assumedPoint, _temp_foo, true, p+1);
                            }
                        } else {
                            rightPoint = data;
                            _temp_foo(promoter_begin);
                        }
                    } else if (isLeft==false && p > 0) {//from the right to left
                        if (k==-1) {
                            assumedPoint = data[0] + k * p * STEP;
                            if (DEBUG) console.log("2) p = " + p + "; assumedPoint = " + assumedPoint);
                            getjsonChrPositionFunction(_chr, promoter_begin, assumedPoint, _temp_foo, false, p+1);
                        } else {
                            leftPoint = data;
                            _temp_foo(promoter_begin);
                        }
                    } else { //when isLeft is undefined - first way
                        //if k == -1 - we found right border, 1 - we found left side
                        if (k==-1) {
                            rightPoint = data;
                            assumedPoint = data[0] + k * STEP;
                            if (assumedPoint < 0) {
                                leftPoint = data;
                                _temp_foo(promoter_begin);
                            } else 
                                getjsonChrPositionFunction(_chr, promoter_begin, assumedPoint, _temp_foo, false, 2);
                        } else {
                            leftPoint = data;
                            assumedPoint = data[0] + k * STEP;
                            getjsonChrPositionFunction(_chr, promoter_begin, assumedPoint, _temp_foo, true, 2);
                        }
                    }
                });
            }

            function ChangeCameraPosition(incoords, option) {
                leftPoint = null;
                rightPoint = null;
                var foo =   function() {
                                if (ChangeCameraPositionBoolean)
                                    setTimeout(foo, 50);
                            };

                if (option == 0) {
                    var str = incoords.replace(regexpPattern, "$1:$2:$3");
                    var arr = str.split(':');
                    //reset angle/rotation
                    controls.getObject().rotation.y = 0; // Rotates Yaw Object
                    controls.getObject().children[0].rotation.x = 0; // Rotates the Pitch Object
                    controls.getObject().position = Global2localVector3({x:parseFloat(arr[0]), y:parseFloat(arr[1]), z:parseFloat(arr[2])});
                    $('#tabs').tabs('option', 'active', 1);
                } else if (option == 1) {
                    var arr = incoords.match(regexpPatternChrms);
                    if (parseInt(arr[3]) >= parseInt(arr[4])) {
                        $("#dialog-message").text("Start position must be less than end position.").dialog("open");
                        return false;
                    }
                    var _temp_foo = function (promoter_begin) {
                        var rate = ((rightPoint[0]-leftPoint[0]==0)?0:(promoter_begin-leftPoint[0])/(rightPoint[0]-leftPoint[0]));
                        var X_new = leftPoint[1] + rate * (rightPoint[1] - leftPoint[1]); 
                        var Y_new = leftPoint[2] + rate * (rightPoint[2] - leftPoint[2]); 
                        var Z_new = leftPoint[3] + rate * (rightPoint[3] - leftPoint[3]);

                        controls.getObject().rotation.y = 0; // Rotates Yaw Object
                        controls.getObject().children[0].rotation.x = 0; // Rotates the Pitch Object
                        var vector = Global2localVector3({x:X_new, y:Y_new, z:Z_new});
                        if (DEBUG) console.log(vector);
                        vector.z = vector.z + blockSize*scaleFactor/20; //shift for looking at the point or near that your need
                        controls.getObject().position = vector;
                    }
                    getjsonChrPositionFunction(((arr[2])?arr[2]:particularChromosome), parseInt(arr[3]), parseInt(arr[3]), _temp_foo); //@TEST X_Y Chromosome
                    $('#tabs').tabs('option', 'active', 1);
                } else if (option == 2) {
                    var str = incoords.replace(regexpPatternGene, "$1");
                    // var arr = str.split(':');
                    var promoterBegin;
                    // if (arr[0][arr[0].length - 1] == "b" ) {
                    //     arr[0] = arr[0].replace("b", "a"); //default value - b doesn't work now
                    // }
                    var isFound = false;
                    var _chr = particularChromosome;
                    var genePars;
                    if ((!genedata[_chr] || !genedata[_chr][str]) && serviceForStructure == "3d") {
                        for (var _v in genedata) {
                            if (_v == _chr) continue;
                            if (genedata[_v][str]) {
                                isFound = true;
                                $("#dialog-message").text("This gene doesn't exist in this chromosome. Try to change model with " + _v + " chromosome model.").dialog( "open" );
                                return false;
                            }
                        }
                        if (!isFound) {
                            $("#dialog-message").text("This gene doesn't exist in our database. Make sure that you enter correct gene.").dialog( "open" );
                            return false;
                        }
                    } else if (serviceForStructure != "3d") {
                        for (var _v in genedata) {
                            if (genedata[_v][str]) {
                                isFound = true;
                                _chr = _v;
                                genePars = genedata[_chr][str];
                                break;
                            }
                        }
                        if (!isFound) {
                            $("#dialog-message").text("This gene doesn't exist in our database. Make sure that you enter correct gene.").dialog( "open" );
                            return false;
                        }
                    } else {
                        genePars = genedata[_chr][str];
                    }

                    if (genePars[0] == '+') {
                        promoterBegin = genePars[1]-1000;
                    } else {
                        promoterBegin = genePars[2]+1000;
                    }

                    var _temp_foo = function (promoter_begin) {
                        var rate = (promoter_begin-leftPoint[0])/(rightPoint[0]-leftPoint[0]);
                        var X_new = leftPoint[1] + rate * (rightPoint[1] - leftPoint[1]); 
                        var Y_new = leftPoint[2] + rate * (rightPoint[2] - leftPoint[2]); 
                        var Z_new = leftPoint[3] + rate * (rightPoint[3] - leftPoint[3]);
                        controls.getObject().rotation.y = 0; // Rotates Yaw Object
                        controls.getObject().children[0].rotation.x = 0; // Rotates the Pitch Object
                        var vector = Global2localVector3({x:X_new, y:Y_new, z:Z_new});
                        vector.z = vector.z + blockSize*scaleFactor/20;//shift for looking at the point or near that your need
                        controls.getObject().position = vector;

                        //add one new gene to draw on screen
                        geneDrawQueue.push([_chr, str, false]);
                    }
                    getjsonChrPositionFunction(_chr, promoterBegin, promoterBegin, _temp_foo);
                    $('#tabs').tabs('option', 'active', 1);
                }
            }

            function changeModeIndicator() {
                //maybe it's not necessary 
                ClearInfo();
                switch(mode_id) {
                    case 0: //linear mode
                        if (lastMode == 2) cleanCHIPSEQdata();
                        document.getElementById("letter-G-icon").style.display = "block";
                        document.getElementById("letter-F-icon").style.display = "none";
                        document.getElementById("thermometer").style.display = "none";
                        document.getElementById("letter-R-icon").style.display = "none";
                        mode_name = 'Linear mode';
                        $('p#textmode').text(mode_name+' (TAB for info)');
                        lastMode = 0;
                        break;
                    case 1: //cubic mode
                        if (lastMode == 2) cleanCHIPSEQdata();
                        document.getElementById("letter-G-icon").style.display = "block";
                        document.getElementById("letter-F-icon").style.display = "none";
                        document.getElementById("thermometer").style.display = "none";
                        document.getElementById("letter-R-icon").style.display = "none";
                        mode_name = 'Cubic mode';
                        $('p#textmode').text(mode_name+' (TAB for info)');
                        lastMode = 1;
                        break;
                    case 2: //CHiP-SEQ mode
                        scene.remove(selectionMesh);
                        document.getElementById("letter-G-icon").style.display = "none";
                        document.getElementById("letter-F-icon").style.display = "block";
                        document.getElementById("thermometer").style.display = "block";
                        document.getElementById("letter-R-icon").style.display = "block";
                        if (!isChipSeqAvailable) showErrorAlertModalWindow("ChIP-Sequencing Data is not available for this 3d model.", function() {mode_id ++;if (mode_id >= NUMBER_OF_MODES) mode_id = 0;changeModeIndicator();});
                        mode_name = 'CHiP-Seq mode';
                        if (lastMode != 2)
                            drawChipSeqDataForCurrentCube();
                        $('p#textmode').text(mode_name+' (TAB for info)');
                        lastMode = 2;
                        break;
                    default:
                        $('p#textmode').text('');
                        break;
                }
            }
            
            function cleanCHIPSEQdata() {
                for (var indx in chipObjects) {
                    scene.remove(chipObjects[indx]);
                }
                chipObjects = [];
                uploaded_splines_chip = {};
                // arrayOfCHIPCoveredTubes = [];
                chipSecCubes = {};
            }
            
            function init_controls() {
                var element = document.body;
                var pointerlockchange = function ( event ) {
                    if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element) {
                        controls.enabled = true;
                        blocker.style.display = 'none';
                        changeModeIndicator();   
                    } else {
                        controls.enabled = false;
                        blocker.style.display = '-webkit-box';
                        blocker.style.display = '-moz-box';
                        blocker.style.display = 'box';
                        if (!is_modal_opened) {
                            instructions.style.display = '';
                        }
                        $('p#textmode').text('');
                        document.getElementById('detection-sign').style.display = "none";
                        keys_block.style.display = "none";
                    }
            	}
                var pointerlockerror = function ( event ) {
                    instructions.style.display = '';
                }

                // Hook pointer lock state change events
                document.addEventListener( 'pointerlockchange', pointerlockchange, false );
                document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
                document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );

                document.addEventListener( 'pointerlockerror', pointerlockerror, false );
                document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
                document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );
                window.addEventListener( "oncontextmenu", function ( event ) { 
                }, false );
                
                window.addEventListener("click",function(event) {
                    if(controls.enabled == true) {
                        
                        if (mode_id == 0) { // only linear mode
                            var _intersection = GetIntersection();
                            if (_intersection == null) {
                                showErrorAlertModalWindow("Point the area firstly!");
                                return;
                            }
                            if (_intersection.object.name == "")
                                return;
                            tableStrContent = '';
                            
                            var object = _intersection.object;
                            var obj_name = _intersection.object.name;
                            var point = _intersection.point;
                            var region = lastRegion;
                            
                            if (typeof region != 'undefinded' && region.length > 0) {
                                var custDataArrayObj = {};
                                var custDataArray;
                                if (isCustomerData) {
                                    custDataArray = customerData[uploaded_splines[obj_name][4]].slice(uploaded_splines[obj_name][2],uploaded_splines[obj_name][3]+1);
                                    
                                    var startRegPos = parseInt(region[0].replace(/.*bases:\s*([\d]+)[^\d]+([\d]+).*/,'\$1'));
                                    var endRegPos = parseInt(region[0].replace(/.*bases:\s*([\d]+)[^\d]+([\d]+).*/,'\$2'));
                                    for (var indx = 0; indx < custDataArray.length; indx++) {
                                        if ( custDataArray[indx][0] < startRegPos ) continue;
                                        else if (custDataArray[indx][0] > endRegPos ) break;
                                        else {
                                            custDataArrayObj[custDataArray[indx][1]] = custDataArray[indx][2];
                                        }
                                    }
                                }    
                                var tbl = document.createElement('table');
                                tbl.setAttribute('id','table_linear');
                                var tbdy = document.createElement('tbody');
                                for (var track_internal_index = 0; track_internal_index < region.length-1; ++track_internal_index) {
                                    var temp = region[track_internal_index].replace(/Selection: |style\s*=\s*\"[^\"]+"/g, "");
                                    
                                    var tr=document.createElement('tr');
                                    var td=document.createElement('td');
                                    if (track_internal_index == 2) { //isCustomerData && 
                                            var mystr = region[track_internal_index].replace(/.*SNPs:\s/,"").replace(/<a [^>]*href=\"[^\"]*rs=([\d]+)">(rs[\d]+)<\/a>;\s*/g, "\$1,");
                                            var arr = mystr.split(",");
                                            tr=document.createElement('tr');
                                            td=document.createElement('td');
                                            appendStringAsNodes(td, "@SNPs/Genotype");
                                            td.colSpan = "2";
                                            tr.appendChild(td);
                                        
                                            if (isCustomerData) {
                                                td=document.createElement('td');
                                                appendStringAsNodes(td, "@Customer Data/Genotype");
                                                tr.appendChild(td);
                                            }
                                            tbdy.appendChild(tr);
                                        //itteration over all SNPs in system (not custom)
                                            for (var i = 0; i< arr.length-1;i++) {
                                                tr=document.createElement('tr');
                                                td=document.createElement('td');
                                                appendStringAsNodes(td, "<a target=\"_blank\" href=\"http://www.ncbi.nlm.nih.gov/SNP/snp_ref.cgi?rs="+arr[i]+"\">rs"+arr[i]+"</a>");
                                                tr.appendChild(td);
                                                
                                                td=document.createElement('td');
                                                var snpGenotypeSys = region[3][i];
                                                appendStringAsNodes(td, snpGenotypeSys);
                                                tr.appendChild(td);
                                                if (isCustomerData) {
                                                    td=document.createElement('td');
                                                    if (custDataArrayObj[String(arr[i])]||custDataArrayObj["rs"+String(arr[i])]) { 
                                                        var snpGenotypeCust = custDataArrayObj[String(arr[i])]||custDataArrayObj["rs"+String(arr[i])];
                                                        appendStringAsNodes(td, snpGenotypeCust);
                                                        tr.appendChild(td);
                                                        if (snpGenotypeSys == snpGenotypeCust || snpGenotypeSys == reverseLine(snpGenotypeCust)) tr.style.color="rgb(0,200,0)";
                                                        else tr.style.color = "rgb(255,0,0)";
                                                        delete custDataArrayObj[String(arr[i])];
                                                        delete custDataArrayObj["rs"+String(arr[i])];
                                                    }
                                                }
                                                tbdy.appendChild(tr);
                                            }
                                        
                                            //print everything that is not in the list of System SNPs
                                            if (isCustomerData && typeof custDataArrayObj != 'undefined' && Object.size(custDataArrayObj) >0 ) {
                                                tr=document.createElement('tr');
                                                td=document.createElement('td');
                                                appendStringAsNodes(td, "@SNPs are not in the list/Genotype");
                                                td.colSpan = "2";
                                                tr.appendChild(td);
                                                tbdy.appendChild(tr);
                                                for (var custDataIndx in custDataArrayObj) {
                                                    tr=document.createElement('tr');
                                                    td=document.createElement('td');
                                                    appendStringAsNodes(td, custDataIndx);
                                                    td=document.createElement('td');
                                                    appendStringAsNodes(td, custDataArrayObj[custDataIndx]);
                                                    tr.appendChild(td);
                                                    tbdy.appendChild(tr);
                                                }
                                            }
                                                
                                            tbdy.appendChild(tr);
                                    }
                                    else {
                                        appendStringAsNodes (td, temp);
                                        if (isCustomerData) td.colSpan="3";
                                        else td.colSpan="2";
                                        tr.appendChild(td)
                                        tbdy.appendChild(tr);
                                    }
                                }
                                tbl.appendChild(tbdy);
                                
                                drawMessiModalWindow(tbl, 'Linear data', '5vh', '10%');
                            }
                            return false;
                        } else if (mode_id == 1) { // only cubic mode
                            var _intersection = GetIntersection();
                            if (_intersection == null) {
                                showErrorAlertModalWindow("Point the area firstly!");
                                return;
                            }
                            if (_intersection.object.name == "")
                                return;
                            var modelPositionCamera = Local2global(controls.getObject().position);
            	            var blockIndicesCamera = GetBlockIndices(modelPositionCamera);
                            var blockIndicesPointer = _intersection.object.userData[1];

                            if (!(blockIndicesCamera.x == blockIndicesPointer.x && blockIndicesCamera.y == blockIndicesPointer.y && blockIndicesCamera.z == blockIndicesPointer.z)) {
                                showErrorAlertModalWindow('Choose the point in your cubic area to explore (or closest area).');
                                return false;
                            }
                            
                            exitPointerLockFunction(); //for delayed 
                            
                            tableStrContent = '';
                            var arrRequestInfo = buildCubeDataStructureSNPs(searchOctree());
                            waitFunction(arrRequestInfo);
                            return false;
                        } else if (mode_id == 2) { // only for CHIP-SEq mode
                            if (!isChipSeqAvailable) showErrorAlertModalWindow("ChIP-Sequencing Data is not available for this 3d model.", function() {mode_id ++;if (mode_id >= NUMBER_OF_MODES) mode_id = 0;changeModeIndicator();});
                            var __intersection = GetIntersectionCHIPSEQ();
                            var _intersection = GetIntersection();

                            if (__intersection) {
                                var temp;
                                var tbl = document.createElement('table');
                                tbl.setAttribute('id','table_linear');
                                var tbdy = document.createElement('tbody');

                                var tr=document.createElement('tr');
                                var td=document.createElement('td');
                                appendStringAsNodes(td, "Chromosome/Positions");
                                tr.appendChild(td);

                                td=document.createElement('td');
                                appendStringAsNodes(td, "Transcription Factors");
                                tr.appendChild(td);

                                td=document.createElement('td');
                                appendStringAsNodes(td, "Effect Level");
                                tr.appendChild(td);
                                tbdy.appendChild(tr);

                                for (var inter_indx in __intersection) {
                                    tr=document.createElement('tr');
                                    temp = uploaded_splines_chip[__intersection[inter_indx].object.name.replace(/^23/, 'x')];
                                    td=document.createElement('td');
                                    appendStringAsNodes(td, "<a target='_blank' href='http://genome.ucsc.edu/cgi-bin/hgTracks?db=hg19&position=chr"+temp[0]+"%3A"+temp[1]+"-"+temp[2]+"' >Chr "+temp[0]+" ("+temp[1] + "-" + temp[2] + ")</a>");
                                    tr.appendChild(td);

                                    td=document.createElement('td');
                                    appendStringAsNodes(td, temp[3]);
                                    tr.appendChild(td);

                                    td=document.createElement('td');
                                    appendStringAsNodes(td, temp[4]);
                                    tr.appendChild(td);
                                    tbdy.appendChild(tr);
                                }
                                tbl.appendChild(tbdy);

                                drawMessiModalWindow(tbl, 'ChIP-Seq data', '5vh', '30%');
                                
                                return ;
                            } /*else if (_intersection) {
                                if ($.inArray(_intersection.object.name, arrayOfCHIPCoveredTubes) != -1) {
                                    showErrorAlertModalWindow("You have already colored this part of chromosome. To get popup window with ChIP-Seq data point exactly to the colored segments and click.");
                                    return;
                                } else {
                                    if (_intersection.object.name == "")
                                        return;
                                    arrayOfCHIPCoveredTubes.push(_intersection.object.name);
                                    drawChipSeqDataRunner(_intersection); //should be renamed
                                }
                            } */ else {
                                showErrorAlertModalWindow("Point the colored area of Transcription Factors!");
                                return;
                            }
                        }
                    }
                });

                instructions.addEventListener( 'click', function ( event ) {
                    instructions.style.display = 'none';
                    // Ask the browser to lock the pointer
                    element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
                    if ( /Firefox/i.test( navigator.userAgent ) ) {
                        var fullscreenchange = function ( event ) {
                            if ( document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element ) {
                                document.removeEventListener( 'fullscreenchange', fullscreenchange );
                                document.removeEventListener( 'mozfullscreenchange', fullscreenchange );
                                element.requestPointerLock();
                            }
                        }
                        document.addEventListener( 'fullscreenchange', fullscreenchange, false );
                        document.addEventListener( 'mozfullscreenchange', fullscreenchange, false );
                        element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;
                        element.requestFullscreen();
                        element.requestPointerLock();
                        document.getElementById('detection-sign').style.display = "none";
                        if ($(document).height() > FIXED_HEIGHT_SCREEN){
                            keys_block.style.display = "block";
                        }
                            
                    } else {
                        element.requestPointerLock();
                        document.getElementById('detection-sign').style.display = "none";
                        if ($(document).height() > FIXED_HEIGHT_SCREEN)
                            keys_block.style.display = "block";
                    }
                }, false );    
                
				{
                    var GKeyDownHandler = function (event) {
                        var element = document.body;
                        if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element )
                            switch ( event.keyCode ) {
                                case 80: //p
                                    {   
                                        suggestionGeneInCube = {};
                                        var modelPosition = Local2global(controls.getObject().position);
                                        var blockIndices = GetBlockIndices(modelPosition);
                                        var blockIndicesStr = Coords2Str(blockIndices);
                                        var tempNameArr = [];
                                        var _chr, _rangeBegin, _rangeEnd, genes;
                                        for (var _obj in objects) {
                                            if (objects[_obj].userData[0] == blockIndicesStr) {
                                                tempNameArr = objects[_obj].name.split('-');
                                                if (DEBUG) console.log(objects[_obj].name);
                                                _chr = tempNameArr[0].replace(/([\dXYxy]+).*/, "$1");
                                                if (!suggestionGeneInCube[_chr]) suggestionGeneInCube[_chr] = {};
                                                _rangeBegin = parseInt(tempNameArr[1]);
                                                _rangeEnd = parseInt(tempNameArr[2]);
                                                genes = genedata[_chr];
                                                for (var _index in genes) {
                                                    if (_rangeBegin<genes[_index][1] && _rangeEnd>genes[_index][2]) {
                                                        suggestionGeneInCube[_chr][_index] = true;
                                                    } else if ((_rangeBegin<genes[_index][1] && _rangeEnd>genes[_index][1]) ||
                                                        (_rangeBegin<genes[_index][2] && _rangeEnd>genes[_index][2]) ||
                                                        (_rangeBegin>genes[_index][1] && _rangeEnd<genes[_index][2])) { //gene is larger than strand
                                                        suggestionGeneInCube[_chr][_index] = false;
                                                    }
                                                }
                                                if (Object.size(suggestionGeneInCube[_chr]) == 0) delete suggestionGeneInCube[_chr];
                                            }
                                        }
                                        showSuggestionGeneInCubeWindow();
                                        break;
                                    }
                                case 82: //r - in chipseq mode - arise everything, clean the memory.
                                    {
                                        if (mode_id == 2) {
                                            cleanCHIPSEQdata()
                                        }
                                        break;
                                    }
                                case 70: //f - in chipseq mode - show the chipseq data in current cube (not the same cube where mode has been activated)
                                    {
                                        if (mode_id == 2) {
                                            var modelPosition = Local2global(controls.getObject().position);
                                            var blockIndices = GetBlockIndices(modelPosition);
                                            var blockIndicesStr = Coords2Str(blockIndices);
                                            if (chipSecCubes[blockIndicesStr]) {
                                                showErrorAlertModalWindow("ChIP-Seq data for current cube has been already shown.");
                                            } else {
                                                drawChipSeqDataForCurrentCube();
                                                chipSecCubes[blockIndicesStr] = true;
                                            }
                                        }
                                        break;
                                    }
                                case 71: //g - get mapping ChIP-Seq data and SNPs
                                    {
                                        if (mode_id == 0) {
                                            var _intersection = GetIntersection();
                                            if (_intersection == null) {
                                                showErrorAlertModalWindow("Point the area firstly!");
                                                return;
                                            }

                                            document.exitPointerLock = document.exitPointerLock ||
                                                                    document.mozExitPointerLock ||
                                                                    document.webkitExitPointerLock;
                                            document.exitPointerLock();
                                            keys_block.style.display = "none";
                                            if ( /Firefox/i.test( navigator.userAgent ) ) exitFromFullScreen();
                                            init_new_window_SNP_CHIP_SEQ(rgn, true);
                                        } else if (mode_id == 1) {
                                            var _intersection = GetIntersection();
                                            if (_intersection == null) {
                                                showErrorAlertModalWindow("Point the area firstly!");
                                                return;
                                            }

                                            document.exitPointerLock = document.exitPointerLock ||
                                                                    document.mozExitPointerLock ||
                                                                    document.webkitExitPointerLock;
                                            document.exitPointerLock();
                                            keys_block.style.display = "none";
                                            if ( /Firefox/i.test( navigator.userAgent ) ) exitFromFullScreen();
                                            init_new_window_SNP_CHIP_SEQ(_intersection.point, false);
                                        }
                                        break;
                                    }
                                case 67: //c - change mode
                                    mode_id ++;
                                    if (mode_id >= NUMBER_OF_MODES) mode_id = 0;
                                    changeModeIndicator();
                                    break;  
                                case 9: //tab - information about current mode
                                    drawMessiModalWindow(textMessages[mode_name], mode_name, null, null, false, true);//central
                                    return false;
                            }
                    }

                    //scrolling event
					var scrollHandler = function (event) {
                        var element = document.body;
                        if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ){
                            
                            
                            if (event.detail != null && event.detail < 0 || event.wheelDeltaY != null && event.wheelDeltaY > 0) {
                                if (mode_id == 0) basesInSelection = Math.min(maxMeter, basesInSelection + stepScroll);
                                if (mode_id == 1) radiusSphere = Math.min(maxRadiusSphere, radiusSphere + 10);
                            } else {
                                if (mode_id == 0) basesInSelection = Math.max(minMeter, basesInSelection - stepScroll);
                                if (mode_id == 1)radiusSphere = Math.max(minRadiusSphere, radiusSphere -10);
                            }    
                        }
						
					};
					var mousewheelevt = (/Firefox/i.test(navigator.userAgent)) ? "DOMMouseScroll" : "mousewheel";
					if (document.attachEvent) //if IE (and Opera depending on user setting) 
                    {
                        document.attachEvent("on"+mousewheelevt, scrollHandler);
                        document.attachEvent("onkeydown", GKeyDownHandler);
                    }
					else if (document.addEventListener) //WC3 browsers
                    {
                        document.addEventListener(mousewheelevt, scrollHandler, false);
                        document.addEventListener("keydown", GKeyDownHandler, false);
                    }
				}
            }

            function toggleAll(source) {
                var _checkboxes = document.getElementsByName('checkBoxToColour');
                for(var i=0, n=_checkboxes.length;i<n;i++) {
                    _checkboxes[i].checked = source.checked;
                }
            }

            function showSuggestionGeneInCubeWindow() {
                
                checkboxes = [];
                var isFirst = true;
                var chkBox;
                var upperTbl = document.createElement('div');
                upperTbl.innerHTML = "<input type='text' value='' placeholder='Search' id='inputFilter'></input>";
                var tbl = document.createElement('table');
                tbl.setAttribute('id','table_cube');
                tbl.setAttribute('class', 'order_table');

                var tbdy = document.createElement('tbody');
                var tr=document.createElement('tr');
                tr.setAttribute('class', 'guide');
                
                var td=document.createElement('th');
                appendStringAsNodes(td, "Chromasome");
                tr.appendChild(td);
                td=document.createElement('th');
                appendStringAsNodes(td, "Gene");
                tr.appendChild(td);
                td=document.createElement('th');
                appendStringAsNodes(td, "+/- strand");
                tr.appendChild(td);
                td=document.createElement('th');
                appendStringAsNodes(td, "Gene expression");
                tr.appendChild(td);
                td=document.createElement('th');
                appendStringAsNodes(td, "In cube");
                tr.appendChild(td);
                td=document.createElement('th');
                td.innerHTML = "Color in cube[<input type='checkbox' onclick='toggleAll(this);'>]";

                // appendStringAsNodes(td, "");
                tr.appendChild(td);
                tbdy.appendChild(tr);
                
                for (var _chr in suggestionGeneInCube) {
                    // tr=document.createElement('tr');
                    // td=document.createElement('td');
                    // td.rowSpan = Object.size(suggestionGeneInCube[_chr]);
                    // appendStringAsNodes(td, _chr);
                    // tr.appendChild(td);
                    isFirst = true;
                    for (var _gene in suggestionGeneInCube[_chr]) {
                        tr=document.createElement('tr');
                        td=document.createElement('td');
                        // td.rowSpan = Object.size(suggestionGeneInCube[_chr]);
                        appendStringAsNodes(td, _chr);
                        tr.appendChild(td);
                        // if (!isFirst) tr=document.createElement('tr');
                        // else isFirst = false;
                        td=document.createElement('td');
                        appendStringAsNodes(td, _gene);
                        tr.appendChild(td);
                        
                        td=document.createElement('td');
                        appendStringAsNodes(td, genedata[_chr][_gene][0]);
                        tr.appendChild(td);

                        td=document.createElement('td');
                        appendStringAsNodes(td, genedata[_chr][_gene][3].toFixed(2));
                        tr.appendChild(td);
                        
                        td=document.createElement('td');
                        appendStringAsNodes(td, suggestionGeneInCube[_chr][_gene]);
                        tr.appendChild(td);

                        td=document.createElement('td');
                        chkBox=document.createElement('input');
                        chkBox.type = "checkbox";
                        chkBox.name = "checkBoxToColour"
                        chkBox.checked = ((_chr + "-" + _gene) in uploaded_splines_genes);

                        td.appendChild(chkBox);
                        checkboxes.push([_chr, _gene, chkBox, ((_chr + "-" + _gene) in uploaded_splines_genes), suggestionGeneInCube[_chr][_gene]]); //chr, gene, <input>, wasCheckedBefore
                        tr.appendChild(td);

                        tbdy.appendChild(tr);
                    }
                    
                    var funcCountCheckboxAndDrawGenes = function() {
                        for (var _chk in checkboxes) {
                            if (checkboxes[_chk][3] == checkboxes[_chk][2].checked) continue; // the same status
                            else if (checkboxes[_chk][3]) { //checkbox has been removed
                                DeleteGene(checkboxes[_chk][0], checkboxes[_chk][1]);
                            } else {    //checkbox has been set
                                geneDrawQueue.push([checkboxes[_chk][0], checkboxes[_chk][1], checkboxes[_chk][4]]); 
                            }
                        }
                    }
                }
                tbl.appendChild(tbdy);
                upperTbl.appendChild(tbl);
                drawMessiModalWindow(upperTbl, 'Genes in current cube', '5vh', '30%', false, false, null, funcCountCheckboxAndDrawGenes);
                $('input#inputFilter').keyup(function() {
                    var that = this;
                    $.each($('table.order_table tbody tr'),
                    function(i, val) {
                        if ($($('table.order_table tbody tr')[i]).attr('class') != 'guide' && $(val).text().toUpperCase().indexOf($(that).val().toUpperCase()) == -1) {
                            $('table.order_table tbody tr').eq(i).hide();
                        } else {
                            $('table.order_table tbody tr').eq(i).show();
                        }
                    });
                });
            }

            function waitFunction(arrRequestInfo){
                if (DEBUG) console.log(req_count  + " : " + resp_count);
                if (resp_count < req_count && waitInterval < MAX_WAIT_INTERVAL) {
                    waitInterval = waitInterval + 50;
                    setTimeout(function(){waitFunction(arrRequestInfo);}, 50);
                } else {
                    var internalTemp;
                    var tbl = document.createElement('table');
                    tbl.setAttribute('id','table_cube');
                    var tbdy = document.createElement('tbody');
                    var tr=document.createElement('tr');
                    var td=document.createElement('td');
                    appendStringAsNodes(td, "Chromasome/positions");
                    tr.appendChild(td);
                    td=document.createElement('td');
                    appendStringAsNodes(td, "SNPs");
                    tr.appendChild(td);
                    tbdy.appendChild(tr);
                    if (!arrRequestInfo) arrRequestInfo = [];
                    for (var i = 0; i < arrRequestInfo.length; i++) {
                        internalTemp = arrRequestInfo[i];
                        for (var j = 0; j < internalTemp.length; j++) {
                            tr=document.createElement('tr');
                            td=document.createElement('td');
                            appendStringAsNodes(td, "Chr "+internalTemp[j][0][0] + " ("+internalTemp[j][0][1]+"-"+internalTemp[j][0][2]+")");
                            tr.appendChild(td);
                            td=document.createElement('td');
                            var result = '';
                            var _temp = internalTemp[j][1].responseJSON;
                            for (var it_indx in _temp) {
                                result += " <a target=\"_blank\"  href=\"http://www.ncbi.nlm.nih.gov/SNP/snp_ref.cgi?rs="+_temp[it_indx][1]+"\">rs"+_temp[it_indx][1]+"</a>;";
                            }
                            appendStringAsNodes(td, result);
                            tr.appendChild(td);
                            tbdy.appendChild(tr);
                        }
                    }
                    tbl.appendChild(tbdy);
                    drawMessiModalWindow(tbl, 'Cubic data', '5vh', '30%', true);
                }
            }

            function drawChipSeqDataForCurrentCube() {
                var modelPosition = Local2global(controls.getObject().position);
                var blockIndices = GetBlockIndices(modelPosition);
                var blockIndicesStr = Coords2Str(blockIndices);

                var requestCHIP;
                var urlCHIP;
                var mapResponse = [];
                var jsonObj;
                req_count = 0; //HERE COULD BE PROBLEM WITH USING THE SAME GLOBAL VARIABLES
                resp_count = 0; //HERE COULD BE PROBLEM WITH USING THE SAME GLOBAL VARIABLES

                for (var _obj in objects) {
                    if (objects[_obj].userData[0] == blockIndicesStr) {
                        requestCHIP = objects[_obj].name.replace(regexpPatternURL, "chr=$1&start=$3&end=$4&celline="+current_cell_line);        
                        requestCHIP = requestCHIP.replace('chr=23','chr=X');
                        urlCHIP = 'http://1kgenome.exascale.info/chipseq?' + requestCHIP;
                        req_count++;
                        jsonObj = $.getJSON(urlCHIP + "?callback=?", null, function(data) {resp_count++;});
                        mapResponse.push([objects[_obj], jsonObj]);
                    }
                }
                if (mapResponse.length == 0) {
                    showErrorAlertModalWindow("There is no ChIP-Seq data to be shown in current cube. Please, move into one of the neighbor cubes to observe any data.");
                    return;
                }
                waitInterval = 0;
                waitFunctionForChipSeqData(mapResponse);
                chipSecCubes[blockIndicesStr] = true;
            }


            function waitFunctionForChipSeqData(mapResponse){
                if (DEBUG) console.log(req_count  + " : " + resp_count);
                if (resp_count < req_count && waitInterval < MAX_WAIT_INTERVAL) {
                    waitInterval = waitInterval + 50;
                    setTimeout(function(){waitFunctionForChipSeqData(mapResponse);}, 50);
                } else {
                    for (var _resp in mapResponse) {
                        if (mapResponse[_resp][1].responseJSON) {
                            if (DEBUG) console.log("CHCHCH + " + mapResponse[_resp][0].name);
                            chipseqDataPostionDeterminitionAndDrawCore(mapResponse[_resp][0].userData, mapResponse[_resp][0].geometry.vertices, uploaded_splines[mapResponse[_resp][0].name][1], mapResponse[_resp][1].responseJSON);
                        }
                    }
                }
            }

            function drawChipSeqDataRunner(_intersection) {
                var name = _intersection.object.name;
                var requestCHIP = name.replace(regexpPatternURL, "chr=$1&start=$3&end=$4&celline="+current_cell_line);
                requestCHIP = requestCHIP.replace('chr=23','chr=X');

                var urlCHIP = 'http://1kgenome.exascale.info/chipseq?' + requestCHIP;

                $.getJSON(urlCHIP + "?callback=?", null, 
                    function(data) {
                        chipseqDataPostionDeterminitionAndDraw(data, _intersection);
                    }
                );
            }

            /**
            * ATTENTION!!! _vert1 = uploaded_splines[name][1]
            * Return: array (size = 4) of start position in 'vertices' array, end position in 'vertices' array, vertices_start_position (for a loop to start from previous position), last_seen_interval_end (for a loop to start from previous position)
            */
            function getApproximationForVerticesBeginEndPosition(vertices, _vert1, vertices_start_position, last_seen_interval_end, rangeBegin, rangeEnd, isVertUse) { // rangeBegin = data[ss][1], rangeEnd = data[ss][2]
                // deb_var = _vert1;
                var vert_length = _vert1.length;
                var first_vert = -1;
                var second_vert = -1;
                var left_distance_begin, left_distance_end; //in but without any values
                var start_node= -1, end_node= -1;
                var start_local_vector3, end_local_vector3

                if (DEBUG) console.log("rangeBegin " + rangeBegin+"; rangeEnd " +  rangeEnd + "; _vert1[vert_length-1][1] = " + _vert1[vert_length-1][1])
                if (rangeEnd >= _vert1[vert_length-1][1]) {
                    second_vert = vertices.length-1;
                    end_node =vert_length-1;
                }
                //iterator for beginnings
                if (DEBUG) console.log("L:"+last_seen_interval_end);
                for (var kk = last_seen_interval_end; kk <vert_length; kk++) {
                    if (rangeBegin<_vert1[kk][1]) {// -------start--------v--
                        last_seen_interval_end = kk;
                        //Local to global problems (change from distance in global space - to rate in any space (iuncluding local))
                        left_distance_begin = (rangeBegin - _vert1[kk-1][1])/(_vert1[kk][1] - _vert1[kk-1][1]);//changed!!!
                        start_node = kk-1;
                        break;
                    }
                }

                if (start_node == -1) {
                    if (DEBUG) console.log("Start_node has not been defined ");
                    return null;
                }

                if (second_vert == -1) {
                    //iterator for ends
                    for (var kk = last_seen_interval_end; kk <vert_length; kk++) {
                        if (rangeEnd<_vert1[kk][1]) { // -------end--------v--
                            end_node = kk-1;
                            //Local to global problems (change from distance in global space - to rate in any space (iuncluding local))
                            left_distance_end = (rangeEnd - _vert1[kk-1][1])/(_vert1[kk][1] - _vert1[kk-1][1]); //changed!!!
                            break;
                        }
                    }   
                    if (end_node == -1) {
                        if (DEBUG) console.log("End_node has not been defined " + start_node + "-" + end_node);
                        return null;
                    }
                }
                
                if ((second_vert == -1 && end_node == -1) || start_node == -1) {
                    if (DEBUG) console.log("Nodes have not been defined " + start_node + "-" + end_node + " = vert.length " + second_vert);
                    return null;
                }
                
                if (start_node == _vert1.length-1) {
                    end_node = start_node;
                    start_node = start_node - 1;
                } else if (end_node == start_node) {
                    if (DEBUG) console.log("Nodes has been artificially increased in size to be recognizable.");
                    if (end_node == vert_length-1)
                        start_node--;
                    else {
                        end_node++;
                        left_distance_end = 0;
                    }
                }

                {
                    var start_node_vector = Global2local({x:_vert1[start_node][2], y:_vert1[start_node][3],z:_vert1[start_node][4]});
                    var next_to_start_node_vector = Global2local({x:_vert1[start_node+1][2], y:_vert1[start_node+1][3],z:_vert1[start_node+1][4]});
                    start_local_vector3  = new THREE.Vector3((next_to_start_node_vector.x - start_node_vector.x)*left_distance_begin + start_node_vector.x,
                        (next_to_start_node_vector.y - start_node_vector.y)*left_distance_begin + start_node_vector.y, 
                        (next_to_start_node_vector.z - start_node_vector.z)*left_distance_begin + start_node_vector.z);
                    var minDistance = -1;

                    if (!isVertUse) {
                        for (var kk = vertices_start_position - parseInt(vertices_start_position/2); kk < vertices.length; kk++) {
                            distance = Math.pow(vertices[kk].x - start_local_vector3.x, 2) + 
                                Math.pow(vertices[kk].y - start_local_vector3.y, 2) +
                                Math.pow(vertices[kk].z - start_local_vector3.z, 2);
                            if (minDistance == -1 || (distance < minDistance)) {
                                minDistance = distance;
                                first_vert = kk;
                            }
                        }
                        vertices_start_position = first_vert;
                        if (first_vert == -1) {
                            if (DEBUG) console.log("first_vert has not been defined ");
                            return null;
                        }    
                    }

                    if (first_vert==vertices.length-1) {
                        second_vert = first_vert;
                        first_vert = findPreviousNotGroupedPoint(vertices, first_vert);
                    }
                    if (DEBUG) console.log("MEss: " + start_node + "-" + end_node + " from ("+(_vert1.length-1)+") ; second_vert " + second_vert +" ; first_vert = " +  first_vert + "; vertices_start_position = " + vertices_start_position);
                    
                    if (end_node ==vert_length-1) {
                        var end_local_vector3 = Global2localVector3({x:_vert1[end_node][2], y:_vert1[end_node][3], z:_vert1[end_node][4]});    
                    } else {
                        var end_node_vector = Global2local({x:_vert1[end_node][2], y:_vert1[end_node][3], z:_vert1[end_node][4]});
                        var next_to_end_node_vector = Global2local({x:_vert1[end_node+1][2], y:_vert1[end_node+1][3], z:_vert1[end_node+1][4]});
                        end_local_vector3 = new THREE.Vector3((next_to_end_node_vector.x - end_node_vector.x)*left_distance_begin + end_node_vector.x, 
                            (next_to_end_node_vector.y - end_node_vector.y)*left_distance_begin + end_node_vector.y, 
                            (next_to_end_node_vector.z - end_node_vector.z)*left_distance_begin + end_node_vector.z);    
                    }

                    if (isVertUse) {
                        return [start_node, end_node, null, last_seen_interval_end, start_local_vector3, end_local_vector3];
                    }
                    
                    
                    minDistance = -1;
                    for (var kk = first_vert + 1; kk < vertices.length; kk++) {
                        distance = Math.pow(vertices[kk].x - end_local_vector3.x, 2) + 
                            Math.pow(vertices[kk].y - end_local_vector3.y, 2) +
                            Math.pow(vertices[kk].z - end_local_vector3.z, 2);
                        if (minDistance == -1 || (distance < minDistance)) {
                            minDistance = distance;
                            second_vert = kk;
                        }
                    }
                }

                if (DEBUG) console.log(first_vert +"||/"+ second_vert)
                return [first_vert, second_vert, vertices_start_position, last_seen_interval_end];
            }

            function chipseqDataPostionDeterminitionAndDrawCore(userDataChip, vertices, _vert1, data) {
                var vertices_start_position = 0; //out
                var last_seen_interval_end = 1; //out
                var left_distance_begin, left_distance_end; //in but without any values
                var start_node, end_node;
                var first_vert = -1;
                var second_vert = -1;
                for (var ss = 0; ss <data.length; ss++) {
                    
                    var temp = getApproximationForVerticesBeginEndPosition(vertices, _vert1, vertices_start_position, last_seen_interval_end, data[ss][1], data[ss][2], false);
                    if (!temp) continue;
                    vertices_start_position = temp[2];
                    last_seen_interval_end = temp[3];
                    first_vert = temp[0];
                    second_vert = temp[1];
                    if (DEBUG) console.log(first_vert + "||" + second_vert)

                    var beginningTFVert = findPreviousNotGroupedPoint(vertices, first_vert); //actual end of previous segment for beginning of TF strand (if it is not 0)
                    var endTFVert = findNextNotGroupedPoint(vertices, second_vert); //actual beginning of next segment after end of TF strand (if it is not last)
                    var vert_cut = vertices.slice(((beginningTFVert!=0)?beginningTFVert+1:0), endTFVert-1);
                    vert_cut = getNormalizedVerticesForVertCut(vert_cut);

                    //draw part
                    {
                        var tube_color = getColorForPercentage(data[ss][4]/MAX_CHIP_LVL);
                        // var material = new THREE.MeshLambertMaterial( { color: tube_color, shading: THREE.SmoothShading } );
                        var material = new THREE.MeshLambertMaterial( { color: tube_color, /*emissive: 0xff0000,*/ ambient: 0x000000, shading: THREE.SmoothShading, side: THREE.DoubleSide } );
                        var spline = new THREE.SplineCurve3(vert_cut);
                        var segments = vert_cut.length;
                        var radiusSegments = 5;
                        var tube = new THREE.TubeGeometry( spline, segments, radiusOfTube*1.8, radiusSegments, false, false);
                        tube.dynamic = true;
                        var tubeMesh = new THREE.Mesh(tube, material);
                        tubeMesh.userData = userDataChip;//?
                        tubeMesh.name = data[ss][0] + "-" + String(data[ss][1]) + "-"  + String(data[ss][2]);
                        uploaded_splines_chip[tubeMesh.name] = [data[ss][0], data[ss][1], data[ss][2], data[ss][3], data[ss][4]]
                        scene.add(tubeMesh);
                        chipObjects.push(tubeMesh);
                /*
                        var tube_color = getColorForPercentage(data[ss][4]);
                        var material = new THREE.MeshLambertMaterial( { color: tube_color, shading: THREE.SmoothShading } );
                        var chipVertices = [];
                        for (var pointIndex = first_vert; pointIndex <= second_vert; ++pointIndex) {
                            chipVertices.push(new THREE.Vector3(vertices[pointIndex].x, vertices[pointIndex].y, vertices[pointIndex].z));
                        }
                        var spline = new THREE.SplineCurve3(chipVertices);
                        var segments = chipVertices.length * 1;
                        var radiusSegments = 10;
                        var tube = new THREE.TubeGeometry( spline, segments, radiusOfTube-2, radiusSegments, false, false);
                        tube.dynamic = true;
                        var tubeMesh = new THREE.Mesh(tube, material);
                        tubeMesh.userData = userDataChip;//?
                        tubeMesh.name = data[ss][0] + "-" + String(data[ss][1]) + "-"  + String(data[ss][2]);
                        uploaded_splines_chip[tubeMesh.name] = [data[ss][0], data[ss][1], data[ss][2], data[ss][3], data[ss][4]];                                
                        scene.add(tubeMesh);
                        chipObjects.push(tubeMesh);
                        */
                    }
                }
            }

            function chipseqDataPostionDeterminitionAndDraw(data, _intersection) {
                var userDataChip = _intersection.object.userData;
                // var vertices = vertices of the intersection.object.geometry.vertices
                var vertices = _intersection.object.geometry.vertices;
                // var data = data after
                var _vert1 = uploaded_splines[_intersection.object.name][1];//nodes
                chipseqDataPostionDeterminitionAndDrawCore(userDataChip, vertices, _vert1, data);
            }

            function getColorForPercentage(chipLvl) {
                var pct = chipLvl;
                for (var i = 1; i < percentColors.length - 1; i++) {
                    if (pct < percentColors[i].pct) {
                        break;
                    }
                }
                var lower = percentColors[i - 1];
                var upper = percentColors[i];
                var range = upper.pct - lower.pct;
                var rangePct = (pct - lower.pct) / range;
                var pctLower = 1 - rangePct;
                var pctUpper = rangePct;
                var color = {
                    r: Math.floor(lower.color.r * pctLower + upper.color.r * pctUpper)/255,
                    g: Math.floor(lower.color.g * pctLower + upper.color.g * pctUpper)/255,
                    b: Math.floor(lower.color.b * pctLower + upper.color.b * pctUpper)/255
                };
                return new THREE.Color().setRGB(color.r, color.g, color.b);
            }
            
            function init_new_window_SNP_CHIP_SEQ (intersectPoint, isPlaneMode) {
                if (isPlaneMode) {
                    var _rgn = intersectPoint;
                    var chrid = String(_rgn[0]);
                    // if (DEBUG) console.log(chrid);
                    var chridNoStrand = chrid.split('_')[0];
                    var chridOnlyNumber = chrid.replace(/([\dXYxy]+).*/, "$1");
                    // var chridNoStrand = chrid.substr(0, chrid.length - 2);
                    // var chridOnlyNumber = chridNoStrand;
                    if (chridOnlyNumber[chridOnlyNumber.length - 1] == "a") {
                        chridOnlyNumber = chridOnlyNumber.substr(0, chridOnlyNumber.length - 1);
                    }
                    snp_chip_seq_window = window.open("index2.html?isplane="+isPlaneMode+"&chr=" + chridOnlyNumber.replace("23", 'x') 
                              + "&start=" + String(Math.floor(_rgn[1]))
                              + "&end=" + String(Math.floor(_rgn[2]))      
                            /*+ "&celline="+ current_cell_line*/, //parameter of celline - will be hardcoded in the index2.html , top=500
                              "_blank", "scrollbars=yes, resizable=yes, top=500, left=500, width=400, height=400");
                    return;
                } else {
                    var intersectInModelCoordinates = Local2global(intersectPoint);
                    globalArrayForWindow = searchOctree();
                    var result = '';
                    for (var indx in globalArrayForWindow) {
                        result += globalArrayForWindow[indx].chr.replace("23", 'x') + "-" + ((globalArrayForWindow[indx].helix)?globalArrayForWindow[indx].helix : "null" )+ ":";
                        for (var indx2 in globalArrayForWindow[indx].intervals) {
                            result += Math.floor(globalArrayForWindow[indx].intervals[indx2].start) + "_" + Math.floor(globalArrayForWindow[indx].intervals[indx2].end) + "-";
                        }
                        result += ";";
                    }
                    var radiusSphereGlobal = radiusSphere/scaleFactor;
                    snp_chip_seq_window = window.open("index2.html?isplane="+isPlaneMode+"&path=" + result
                       , //parameter of celline - will be hardcoded in the index2.html , top=500
                              "_blank", "scrollbars=yes, resizable=yes, top=500, left=500, width=400, height=400");
                    return;    
                }
            }

            var chrid2color = {};
			// the pointerLock object has different name in different browsers
			// http://www.html5rocks.com/en/tutorials/pointerlock/intro/
            var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;
            if ( havePointerLock ) {
            	init_controls();
            } else {
            	instructions.innerHTML = "Your browser doesn\'t seem to support Pointer Lock API<br/>Supported browsers: Firefox, Google Chrome.";
            }
            init();
            animate();
            
            function init_light() {
                    var light = new THREE.DirectionalLight( 0xffffff, 1.5 );
                    light.position.set( 1, 1, 1 );
                    scene.add( light );
                    var light = new THREE.DirectionalLight( 0xffffff, 0.75 );
                    light.position.set( -1, - 0.5, -1 );
                    scene.add( light );
            }
            
            /*@deprecated*/
            function draw_low_resolution_model() {
                    // loading 3d-model
					// data - is an array of arrays, each array is a sequence of points of a DNA molecule
					// each point is represented with 4 numbers: base_index, x,y,z
					var color = new THREE.Color().setHSL( Math.random(),  Math.random(),  Math.random());
					for (var chr_index = 0; chr_index < data.length; ++chr_index) {
						chr_data = data[chr_index];
						var CELL_SIZE = 4;
						points_count = chr_data.length / CELL_SIZE; 
						
						var tube_color = new THREE.Color().setHSL( Math.random(),  Math.random(),  Math.random());
						var material = new THREE.MeshBasicMaterial({
								color: tube_color,
								opacity: 1,
								wireframe: true,
								transparent: false
						});
						var spline_points = [];
						for (var point_index = 0; point_index < points_count; ++point_index) {
							x = chr_data[(point_index) * CELL_SIZE];
							y = chr_data[(point_index) * CELL_SIZE + 1];
							z = chr_data[(point_index) * CELL_SIZE + 2];	
							spline_points.push(new THREE.Vector3(x, y, z));									

						}
						var spline = new THREE.SplineCurve3(spline_points);
						var segments = points_count * 2;
						var radiusSegments =  4;
						var tube = new THREE.TubeGeometry(spline, segments, 1, radiusSegments, false, false);
						tube.dynamic = true;
						tubeMesh = new THREE.Mesh(tube, material);							
						scene.add(tubeMesh);
						objects.push(tubeMesh);
                    }            	
            }
            
            //probably trash
            function InitSelectionMesh() {
				var spline = new THREE.SplineCurve3([new THREE.Vector3(0, 0, 0), new THREE.Vector3(100, 100, 100),]);
				var material = new THREE.LineBasicMaterial({color: 0xff0000});
				var segments = 10;
				var radiusSegments = 6;
				var tube = new THREE.TubeGeometry(spline, segments, 20, radiusSegments, false, false);
				tube.dynamic = true;
				tube.verticesNeedUpdate = true;
				selectionMesh = new THREE.Mesh(tube, material);
				selectionMesh.name = "selection_mesh";
                test_mesh = selectionMesh;
				scene.add(selectionMesh);          	
            }
            
            function UpdateTargetBallPosition() {
				var vector = new THREE.Vector3(0, 0, 0);
				var raycaster = projector.pickingRay(vector, camera);
				raycaster.ray.direction.normalize().multiplyScalar(50);
				var x = raycaster.ray.direction.x + raycaster.ray.origin.x;
				var y = raycaster.ray.direction.y + raycaster.ray.origin.y;
				var z = raycaster.ray.direction.z + raycaster.ray.origin.z;
				targetBall.position.set(x,  y, z);
				targetBall.geometry.verticesNeedUpdate = true;
				scene.remove(targetBall);   	
				scene.add(targetBall); 
            }
            
            function InitTargetBall() {
            	var sphere = new THREE.SphereGeometry(0.5, 10, 10);
            	sphere.dynamic = true;
            	targetBall = new THREE.Mesh(sphere, new THREE.LineBasicMaterial({color: 0xff0000}));
				targetBall.name = "target_ball";            	
				UpdateTargetBallPosition();						          	
            }
                                                     
            function getPositionRangeFromCubeIntersection(meshesSearch, radiusSphereImpl) {
                if (!radiusSphereImpl) radiusSphereImpl = radiusSphere;
                var resultSet = [];
                var verts;
                
                var mentionedMeshes = [];
                var name, aLen;
                var chr, helix;
                var tempObject;
                for (var _mesh in meshesSearch) {
                    name = meshesSearch[_mesh].object.name;

                    if (mentionedMeshes != null && ($.inArray(name, mentionedMeshes) != -1)) {
                        continue;
                    }
                    mentionedMeshes.push(name);
                    tempObject = [];

                    //proportional calculations
                    verts = meshesSearch[_mesh].object.geometry.vertices;
                    aLen = verts.length;
                    chr = (name.replace(regexpPatternURL, "$1"));
                    // helix = (name.replace(regexpPatternURL, "$2"));

                    var minDistance = -1;
                    var secMinDistance = -1;
                    var closestPoint = -1;
                    var secClosestPoint = -1;
                    var distance = -1;
                    var distBetweenNodes = -1;
                    var closestPointInSpehere = -1;
                    var closestPointVertInSphere, closestPointVert;
                    var verts_point = intersection.point;
                    var koef = 0;
                    var aStartVector = -1;
                    var aEndVector = -1;
                    var possibleSolutions = [];
                    var countPossibleSolutions = 0;

                    for (var _v = 0; _v < aLen; _v = findNextNotGroupedPoint(verts, _v)) {
                        distance = Math.pow(verts[_v].x - verts_point.x,2) + 
                                Math.pow(verts[_v].y - verts_point.y,2) + 
                                Math.pow(verts[_v].z - verts_point.z,2);

                        if (minDistance == -1 || ( distance < minDistance ))  {
                            if ( distance > 2 * radiusSphereImpl * radiusSphereImpl ) { //sqrt(2)
                                
                                secClosestPoint = closestPoint;
                                secMinDistance = minDistance;
                                closestPoint = _v;
                                minDistance = distance;
                                possibleSolutions[countPossibleSolutions] = {closestPoint: closestPoint, minDistance: minDistance, secClosestPoint: secClosestPoint, secMinDistance: secMinDistance};
                            }

                        } else if ( minDistance > 0 && distance < 16 * radiusSphereImpl * radiusSphereImpl && distance > minDistance ) {
                            if (possibleSolutions[countPossibleSolutions]) countPossibleSolutions++;
                            minDistance = distance;
                            closestPoint = _v;
                            secClosestPoint = -1;
                            secMinDistance = -1;
                        }
                    }

                    if (minDistance == -1) { //everything in the selection area - as there should be at least something in the minDistance after the end of the loop
                        var trackPoints = uploaded_splines[name][1];
                        var objStart = getPointPositionInChr(trackPoints, 0, verts[0]);
                        var objEnd = getPointPositionInChr(trackPoints, objStart.firstPoint, verts[verts.length-1]);

                        tempObject.push({start: objStart, end: objEnd});
                        
                        if (tempObject.length != 0)
                            resultSet.push({chr: chr, intervals: tempObject, size: tempObject.length, helix: helix});
                        continue;
                    }


                    for (var tempObj in possibleSolutions) {
                        minDistance = possibleSolutions[tempObj].minDistance;
                        closestPoint = possibleSolutions[tempObj].closestPoint;
                        secMinDistance = possibleSolutions[tempObj].secMinDistance;
                        secClosestPoint = possibleSolutions[tempObj].secClosestPoint;
                        //for every possible solution - start from null
                        aStartVector = -1; 
                        aEndVector = -1;

                        // set up the secClosestPoint for complete algorithm
                        if (secClosestPoint == -1) {
                            if (closestPoint == 0) {
                                secClosestPoint = closestPoint;
                                secMinDistance = minDistance;
                                minDistance = -1;
                                for (var indx = findNextNotGroupedPoint(verts, secClosestPoint); indx < aLen; indx = findNextNotGroupedPoint(verts, indx)) {
                                    distance = Math.pow(verts[indx].x - verts_point.x,2) + 
                                        Math.pow(verts[indx].y - verts_point.y,2) + 
                                        Math.pow(verts[indx].z - verts_point.z,2);
                            
                                    if (minDistance == -1 || ( distance < minDistance && distance > 2 * radiusSphereImpl * radiusSphereImpl))  { //sqrt(2)
                                        closestPoint = indx;
                                        minDistance = distance;
                                        break;
                                    } 
                                }
                                if (minDistance == -1) {
                                    aEndVector = verts[verts.length-1];
                                } 
                            } else {
                                aStartVector = verts[0];
                            }
                        }

                        //check - if this possible solution is the solution undeed
                        var nextPoint = -1;
                        var nextPointDistance = -1;
                        var isThereSomethingInSphere = false;
                        //---secClosestPoint------.?.----closestpoint-----.?.-----nextPoint-------------> (strand ++)
                        for (var indx = findNextNotGroupedPoint(verts, closestPoint); indx < aLen; indx = findNextNotGroupedPoint(verts, indx)) {
                            distance = Math.pow(verts[indx].x - verts_point.x,2) + 
                                Math.pow(verts[indx].y - verts_point.y,2) + 
                                Math.pow(verts[indx].z - verts_point.z,2);
                            if ( distance > 2 * radiusSphereImpl * radiusSphereImpl ) { //sqrt(2)
                                nextPoint = indx;
                                nextPointDistance = distance;
                                break;
                            } else {
                                isThereSomethingInSphere = true; //if nextPoint will be found - we shouldn't check anything after - use nextPoint as closestPoint and current closestPoint as secClosestPoint
                            }
                        }

                        if (isThereSomethingInSphere) {
                            secClosestPoint = closestPoint;
                            secMinDistance = minDistance;
                            closestPoint = nextPoint;
                            minDistance = nextPointDistance;
                        } else {

                            //check median of the line between two points : if it is located in the radius area
                            distance = Math.pow((verts[closestPoint].x + verts[nextPoint].x)/2 - verts_point.x,2) + 
                                Math.pow((verts[closestPoint].y + verts[nextPoint].y)/2 - verts_point.y,2) + 
                                Math.pow((verts[closestPoint].z + verts[nextPoint].z)/2 - verts_point.z,2);

                            if ( distance < 2 * radiusSphereImpl * radiusSphereImpl ) { //sqrt(2) - must be here as corners of cube!!!
                                secClosestPoint = closestPoint;
                                secMinDistance = minDistance;
                                closestPoint = nextPoint;
                                minDistance = nextPointDistance;
                            } else {

                                distance = Math.pow((verts[closestPoint].x + verts[secClosestPoint].x)/2 - verts_point.x,2) + 
                                    Math.pow((verts[closestPoint].y + verts[secClosestPoint].y)/2 - verts_point.y,2) + 
                                    Math.pow((verts[closestPoint].z + verts[secClosestPoint].z)/2 - verts_point.z,2);
                                if ( distance < 2 * radiusSphereImpl * radiusSphereImpl ) { //sqrt(2) - must be here as corners of cube!!!
                                    //everything is ok, let's move on to the next stage
                                } else {
                                    continue; // that means that this is pseudo solution with *great probability*
                                }
                            }
                        }

                        //DO NOT CHANGE ANYTHING IN THIS BLOCK WITHOUT UNDERSTANDING!!!

                        //=======================BEGIN==================

                        distBetweenNodes = Math.pow(verts[closestPoint].x - verts[secClosestPoint].x, 2) + 
                                    Math.pow(verts[closestPoint].y - verts[secClosestPoint].y, 2) +
                                    Math.pow(verts[closestPoint].z - verts[secClosestPoint].z, 2);
                    
                        /* 1st case:  2---[---x---]-1       */
                        if (findNextNotGroupedPoint(verts,secClosestPoint) != closestPoint ) { //there are points in the sphere area
                            if (DEBUG) console.log("/* 1st case:  2---[---x---]-1       */");
                            if (aStartVector == -1) {
                                /*for begins*/
                                closestPointInSpehere = findNextNotGroupedPoint(verts,secClosestPoint);

                                distance = Math.pow(verts[closestPointInSpehere].x - verts_point.x,2) + 
                                        Math.pow(verts[closestPointInSpehere].y - verts_point.y,2) + 
                                        Math.pow(verts[closestPointInSpehere].z - verts_point.z,2);

                                distBetweenNodes = Math.pow(verts[secClosestPoint].x - verts[closestPointInSpehere].x, 2) + 
                                            Math.pow(verts[secClosestPoint].y - verts[closestPointInSpehere].y, 2) +
                                            Math.pow(verts[secClosestPoint].z - verts[closestPointInSpehere].z, 2);

                                if (distBetweenNodes > secMinDistance) {
                                    //using intersection point
                                    closestPointVert = verts[secClosestPoint];
                                    koef = radiusSphereImpl/Math.sqrt(secMinDistance/2); //sqrt(2) - as we should cover corners of cube
                                    aStartVector = new THREE.Vector3(verts_point.x + (closestPointVert.x-verts_point.x)*koef, 
                                        verts_point.y + (closestPointVert.y-verts_point.y)*koef, 
                                            verts_point.z + (closestPointVert.z-verts_point.z)*koef)
                                } else {
                                    //using intermediate point
                                    closestPointVert = verts[secClosestPoint];
                                    closestPointVertInSphere = verts[closestPointInSpehere];
                                    koef = (radiusSphereImpl * Math.sqrt(2) - Math.sqrt(distance)) / Math.sqrt(distBetweenNodes); //sqrt(2) - as we should cover corners of cube
                                    aStartVector = new THREE.Vector3(closestPointVertInSphere.x + (closestPointVert.x-closestPointVertInSphere.x)*koef, 
                                        closestPointVertInSphere.y + (closestPointVert.y-closestPointVertInSphere.y)*koef, 
                                            closestPointVertInSphere.z + (closestPointVert.z-closestPointVertInSphere.z)*koef)
                                }
                            }
                            
                            if (aEndVector == -1) {
                                /*for ends*/
                                closestPointInSpehere = findPreviousNotGroupedPoint(verts, closestPoint);

                                distance = Math.pow(verts[closestPointInSpehere].x - verts_point.x,2) + 
                                        Math.pow(verts[closestPointInSpehere].y - verts_point.y,2) + 
                                        Math.pow(verts[closestPointInSpehere].z - verts_point.z,2);

                                distBetweenNodes = Math.pow(verts[closestPoint].x - verts[closestPointInSpehere].x, 2) + 
                                            Math.pow(verts[closestPoint].y - verts[closestPointInSpehere].y, 2) +
                                            Math.pow(verts[closestPoint].z - verts[closestPointInSpehere].z, 2);

                                if (distBetweenNodes > minDistance) {
                                    //using intersection point
                                    closestPointVert = verts[closestPoint];
                                    koef = radiusSphereImpl/Math.sqrt(minDistance/2); //sqrt(2) - as we should cover corners of cube
                                    aEndVector = new THREE.Vector3(verts_point.x + (closestPointVert.x-verts_point.x)*koef, 
                                        verts_point.y + (closestPointVert.y-verts_point.y)*koef, 
                                            verts_point.z + (closestPointVert.z-verts_point.z)*koef)
                                } else {
                                    //using intermediate point
                                    closestPointVert = verts[closestPoint];
                                    closestPointVertInSphere = verts[closestPointInSpehere];
                                    koef = (radiusSphereImpl* Math.sqrt(2) - Math.sqrt(distance)) / Math.sqrt(distBetweenNodes); //sqrt(2) - as we should cover corners of cube
                                    aEndVector = new THREE.Vector3(closestPointVertInSphere.x + (closestPointVert.x-closestPointVertInSphere.x)*koef, 
                                        closestPointVertInSphere.y + (closestPointVert.y-closestPointVertInSphere.y)*koef, 
                                            closestPointVertInSphere.z + (closestPointVert.z-closestPointVertInSphere.z)*koef)
                                }
                            }
                        } else if ( findNextNotGroupedPoint(verts, secClosestPoint) == closestPoint 
                                        && distBetweenNodes >= secMinDistance /*condition - on different sides from interaction point*/ ) { //there are no points in the sphere area
                            if (aStartVector == -1) {
                            /*for begins*/
                                //using intersection point
                                closestPointVert = verts[secClosestPoint];
                                koef = radiusSphereImpl/Math.sqrt(secMinDistance / 2); //sqrt(2) - as we should cover corners of cube
                                aStartVector = new THREE.Vector3(verts_point.x + (closestPointVert.x-verts_point.x)*koef, 
                                    verts_point.y + (closestPointVert.y-verts_point.y)*koef, 
                                        verts_point.z + (closestPointVert.z-verts_point.z)*koef);
                            }

                            if (aEndVector == -1) {
                            /*for ends*/
                                //using intersection point
                                closestPointVert = verts[closestPoint];
                                koef = radiusSphereImpl/Math.sqrt(minDistance / 2); //sqrt(2) - as we should cover corners of cube
                                aEndVector = new THREE.Vector3(verts_point.x + (closestPointVert.x-verts_point.x)*koef, 
                                    verts_point.y + (closestPointVert.y-verts_point.y)*koef, 
                                        verts_point.z + (closestPointVert.z-verts_point.z)*koef);
                            }

                        } else if (secMinDistance > distBetweenNodes) { /* 2nd case:  2--1--[---x---]---    */
                            
                            if (DEBUG) console.log("/* 2nd case:  2--1--[---x---]---    */");
                            if (DEBUG) console.log(secMinDistance+ ">" + distBetweenNodes + " | " + aStartVector +  " | " +  aEndVector + " [" + secClosestPoint + " |||" + closestPoint + "]");
                            var tempPoint = findNextNotGroupedPoint(verts, closestPoint);

                            distance = Math.pow(verts[tempPoint].x - verts_point.x,2) + 
                                    Math.pow(verts[tempPoint].y - verts_point.y,2) + 
                                    Math.pow(verts[tempPoint].z - verts_point.z,2);


                            if (distance < 2 * Math.pow(radiusSphereImpl,2)) {
                                /*for begins*/
                                closestPointInSpehere = tempPoint;

                                distBetweenNodes = Math.pow(verts[closestPoint].x - verts[closestPointInSpehere].x, 2) + 
                                            Math.pow(verts[closestPoint].y - verts[closestPointInSpehere].y, 2) +
                                            Math.pow(verts[closestPoint].z - verts[closestPointInSpehere].z, 2);

                                if (aStartVector == -1) {
                                    if (distBetweenNodes > minDistance) {
                                        //using intersection point
                                        closestPointVert = verts[closestPoint];
                                        koef = radiusSphereImpl / Math.sqrt(minDistance/2); //sqrt(2) - as we should cover corners of cube
                                        aStartVector = new THREE.Vector3(verts_point.x + (closestPointVert.x-verts_point.x)*koef, 
                                            verts_point.y + (closestPointVert.y-verts_point.y)*koef, 
                                                verts_point.z + (closestPointVert.z-verts_point.z)*koef)
                                    } else {
                                        //using intermediate point
                                        closestPointVert = verts[closestPoint];
                                        closestPointVertInSphere = verts[closestPointInSpehere];
                                        koef = (radiusSphereImpl*Math.sqrt(2) - Math.sqrt(distance)) / Math.sqrt(distBetweenNodes); //sqrt(2) - as we should cover corners of cube
                                        aStartVector = new THREE.Vector3(closestPointVertInSphere.x + (closestPointVert.x-closestPointVertInSphere.x)*koef, 
                                            closestPointVertInSphere.y + (closestPointVert.y-closestPointVertInSphere.y)*koef, 
                                                closestPointVertInSphere.z + (closestPointVert.z-closestPointVertInSphere.z)*koef)
                                    }
                                }

                                /*for ends*/
                                minDistance = -1;
                                for (var indx = findNextNotGroupedPoint(verts, closestPointInSpehere); indx < verts.length; indx = findNextNotGroupedPoint(verts, indx)) {
                                    distance = Math.pow(verts[indx].x - verts_point.x,2) + 
                                        Math.pow(verts[indx].y - verts_point.y,2) + 
                                        Math.pow(verts[indx].z - verts_point.z,2);
                                        
                                    if (minDistance == -1 || ( distance < minDistance && distance > 2 * radiusSphereImpl * radiusSphereImpl))  { //sqrt(2)
                                        closestPoint = indx;
                                        minDistance = distance;
                                        break;
                                    }
                                }

                                if (closestPoint == -1) {
                                    aEndVector = verts[aLen-1]
                                } else if (aEndVector == -1) {
                                    /*for ends*/
                                    closestPointInSpehere = findPreviousNotGroupedPoint(verts, closestPoint);

                                    distance = Math.pow(verts[closestPointInSpehere].x - verts_point.x,2) + 
                                            Math.pow(verts[closestPointInSpehere].y - verts_point.y,2) + 
                                            Math.pow(verts[closestPointInSpehere].z - verts_point.z,2);

                                    distBetweenNodes = Math.pow(verts[closestPoint].x - verts[closestPointInSpehere].x, 2) + 
                                                Math.pow(verts[closestPoint].y - verts[closestPointInSpehere].y, 2) +
                                                Math.pow(verts[closestPoint].z - verts[closestPointInSpehere].z, 2);

                                    if (distBetweenNodes > minDistance) {
                                        //using intersection point
                                        closestPointVert = verts[closestPoint];
                                        koef = radiusSphereImpl/Math.sqrt(minDistance/2); //sqrt(2) - as we should cover corners of cube
                                        aEndVector = new THREE.Vector3(verts_point.x + (closestPointVert.x-verts_point.x)*koef, 
                                            verts_point.y + (closestPointVert.y-verts_point.y)*koef, 
                                                verts_point.z + (closestPointVert.z-verts_point.z)*koef)
                                    } else {
                                        //using intermediate point
                                        closestPointVert = verts[closestPoint];
                                        closestPointVertInSphere = verts[closestPointInSpehere];
                                        koef = (radiusSphereImpl*Math.sqrt(2) - Math.sqrt(distance)) / Math.sqrt(distBetweenNodes); //sqrt(2) - as we should cover corners of cube
                                        aEndVector = new THREE.Vector3(closestPointVertInSphere.x + (closestPointVert.x-closestPointVertInSphere.x)*koef, 
                                            closestPointVertInSphere.y + (closestPointVert.y-closestPointVertInSphere.y)*koef, 
                                                closestPointVertInSphere.z + (closestPointVert.z-closestPointVertInSphere.z)*koef)
                                    }
                                }
                            } else {
                                //tempPoint - this is the next point out of the sphere
                                secClosestPoint = closestPoint;
                                closestPoint = tempPoint;
                                secMinDistance = minDistance;
                                minDistance = distance;
                                if (aStartVector == -1) {
                                    /*for begins*/
                                    //using intersection point
                                    closestPointVert = verts[secClosestPoint];
                                    koef = radiusSphereImpl/Math.sqrt(secMinDistance/2); //sqrt(2) - as we should cover corners of cube
                                    aStartVector = new THREE.Vector3(verts_point.x + (closestPointVert.x-verts_point.x)*koef, 
                                        verts_point.y + (closestPointVert.y-verts_point.y)*koef, 
                                            verts_point.z + (closestPointVert.z-verts_point.z)*koef);
                                }

                                if (aEndVector == -1) {
                                    /*for ends*/
                                    //using intersection point
                                    closestPointVert = verts[closestPoint];
                                    koef = radiusSphereImpl/Math.sqrt(minDistance/2); //sqrt(2) - as we should cover corners of cube
                                    aEndVector = new THREE.Vector3(verts_point.x + (closestPointVert.x-verts_point.x)*koef, 
                                        verts_point.y + (closestPointVert.y-verts_point.y)*koef, 
                                            verts_point.z + (closestPointVert.z-verts_point.z)*koef);
                                }
                            } 
                        }
                        var trackPoints = uploaded_splines[name][1];
                        var objStart = getPointPositionInChr(trackPoints, 0, aStartVector);
                        var objEnd = getPointPositionInChr(trackPoints, objStart.firstPoint, aEndVector);
                        
                        if (objStart.position == objEnd.position) {
                            tempObject.push({start: objStart.position-50, end: objEnd.position+50});//show the minimum block
                        } else {
                            tempObject.push({start: objStart.position, end: objEnd.position});    
                        }
//===============================END=============================
                    }
                    if (tempObject.length != 0)
                            resultSet.push({chr: chr, intervals: tempObject, size: tempObject.length, helix: helix});
                }
                return resultSet;
            }


            function findNextNotGroupedPoint(verts, startPointIndex) {
                var epsilon = 1 + 0.01; //1% to fluctuations
                var NEGL_DISTANCE = 4*radiusOfTube*radiusOfTube*epsilon; //based on the tubes width (radiusOfTube*2) * (radiusOfTube*2) 
                var distBetweenNodes = -1;
                for (var _v = startPointIndex+1; _v < verts.length; _v++) {
                    if (verts[_v] === 'undefined') continue;
                        
                        distBetweenNodes = Math.pow(verts[startPointIndex].x - verts[_v].x, 2) + 
                                            Math.pow(verts[startPointIndex].y - verts[_v].y, 2) +
                                            Math.pow(verts[startPointIndex].z - verts[_v].z, 2);
                        if (distBetweenNodes > NEGL_DISTANCE) {
                            return _v;
                        }
                }
                return verts.length;
            }

            function findPreviousNotGroupedPoint(verts, startPointIndex) {
                var epsilon = 1 + 0.01; //1% to fluctuations
                var NEGL_DISTANCE = 4*radiusOfTube*radiusOfTube*epsilon; //based on the tubes width (radiusOfTube*2) * (radiusOfTube*2)
                var distBetweenNodes = -1;
                for (var _v = startPointIndex-1; _v >= 0; _v--) {
                        distBetweenNodes = Math.pow(verts[startPointIndex].x - verts[_v].x, 2) + 
                                            Math.pow(verts[startPointIndex].y - verts[_v].y, 2) +
                                            Math.pow(verts[startPointIndex].z - verts[_v].z, 2);
                        if (distBetweenNodes > NEGL_DISTANCE) {
                            return _v;
                        }
                }
                return -1;
            }

            function getPointPositionInChr(trackPoints, startPointIndex, local_verts_point) {
                var verts_point = Local2global(local_verts_point);
                var closestPoint = -1;
                var minDistance = -1;
                var secClosestPoint = -1;
                var secMinDistance = -1;
                var distBetweenNodes = -1;
                for (var pointIndex = startPointIndex; pointIndex < trackPoints.length; ++pointIndex) {
                    var x = trackPoints[pointIndex][2];
                    var y = trackPoints[pointIndex][3];
                    var z = trackPoints[pointIndex][4];

                    var distance = Math.pow(verts_point.x - x, 2) + 
                                    Math.pow(verts_point.y - y, 2) +
                                    Math.pow(verts_point.z - z, 2);
                    if (minDistance == -1 || distance < minDistance) {
                        if (pointIndex - closestPoint == 1) {
                            secMinDistance = minDistance;
                            secClosestPoint = closestPoint;    
                        } else {
                            secMinDistance = -1;
                            secClosestPoint = -1;
                        }
                        minDistance = distance;
                        closestPoint = pointIndex;
                    }
                }
                
                if (DEBUG) console.log("Alll: startPointIndex = " + startPointIndex + " :: " + secClosestPoint + " ["+"] ||| " + closestPoint + " []");
                
                if (secClosestPoint == -1) {
                    if (closestPoint != startPointIndex) {
                        secClosestPoint = closestPoint-1;
                        secMinDistance = Math.pow(verts_point.x - trackPoints[secClosestPoint][2], 2) + 
                                    Math.pow(verts_point.y - trackPoints[secClosestPoint][3], 2) +
                                    Math.pow(verts_point.z - trackPoints[secClosestPoint][4], 2); 
                    } else {
                        secClosestPoint = closestPoint;
                        secMinDistance = minDistance;
                        closestPoint = closestPoint + 1;
                        minDistance = Math.pow(verts_point.x - trackPoints[secClosestPoint][2], 2) + 
                                    Math.pow(verts_point.y - trackPoints[secClosestPoint][3], 2) +
                                    Math.pow(verts_point.z - trackPoints[secClosestPoint][4], 2); 
                    }
                } 

                distBetweenNodes = Math.pow(trackPoints[closestPoint][2] - trackPoints[secClosestPoint][2], 2) + 
                                    Math.pow(trackPoints[closestPoint][3] - trackPoints[secClosestPoint][3], 2) +
                                    Math.pow(trackPoints[closestPoint][4] - trackPoints[secClosestPoint][4], 2);

                if (secMinDistance>=distBetweenNodes) { // v---x------x
                    closestPoint = closestPoint+1;
                    secClosestPoint = secClosestPoint+1;
                    secMinDistance = minDistance;
                    minDistance = Math.pow(verts_point.x - trackPoints[closestPoint][2], 2) + 
                                    Math.pow(verts_point.y - trackPoints[closestPoint][3], 2) +
                                    Math.pow(verts_point.z - trackPoints[closestPoint][4], 2); 
                }

                // x----v-----------x
                //if (DEBUG) console.log(trackPoints[closestPoint][1] + "|||" + trackPoints[secClosestPoint][1]);
                 if (DEBUG) console.log("Alll: startPointIndex = " + startPointIndex + " :: " + secClosestPoint + " ["+trackPoints[secClosestPoint][1]+"] ||| " + closestPoint + " ["+trackPoints[closestPoint][1]+"]");
//                return {position: Math.floor((Math.sqrt(secMinDistance)*trackPoints[closestPoint][1] + Math.sqrt(minDistance)*trackPoints[secClosestPoint][1])/(Math.sqrt(secMinDistance)+Math.sqrt(minDistance))), firstPoint: secClosestPoint};
                
                return {position: Math.floor((trackPoints[secClosestPoint][1]*minDistance + trackPoints[closestPoint][1]*secMinDistance) / (minDistance+secMinDistance)), firstPoint: secClosestPoint};
            }
            
            
            function searchOctree() {
                var tempInt = GetIntersection();

                if (tempInt == null) return;
                if (DEBUG) console.log("call searchOctree()");
                intersectionImpl = tempInt.point;
                var rayCaster = new THREE.Raycaster( new THREE.Vector3().copy( intersectionImpl ), new THREE.Vector3(0,0,radiusSphere).normalize() );
                // var radiusSearch = radiusSphere;
                var meshesSearch = octree.search( rayCaster.ray.origin, radiusSphere, true, rayCaster.ray.direction ); 
                // intersections = rayCaster.intersectOctreeObjects( meshesSearch, true);
                return getPositionRangeFromCubeIntersection(meshesSearch);
            }
			
            function init() {
                    Object.size = function(obj) {
                        var size = 0, key;
                        for (key in obj) {
                            if (obj.hasOwnProperty(key)) size++;
                        }
                        return size;
                    };

            		scene = new THREE.Scene();
					camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 100000 );
                    if (serviceForStructure == "3d") {
                        controls = new THREE.PointerLockControls(camera, startPositionOfCamera.x, startPositionOfCamera.y, startPositionOfCamera.z);
                    } else {
                        controls = new THREE.PointerLockControls(camera) ;
                    }
                        
                    scene.add( controls.getObject() );

					//scene.fog = new THREE.Fog( 0xffffff, 0, blockSize * scaleFactor );
					init_light(scene);    
                    //draw_low_resolution_model();
                  
                    renderer = new THREE.WebGLRenderer();
                    renderer.setClearColor( 0xffffff );
                    renderer.setSize( window.innerWidth, window.innerHeight );
                    
                    InitSelectionMesh();
                    InitTargetBall();

                    // create octree
                    octree = new THREE.Octree( {
                      undeferred: false,
                      depthMax: Infinity,
                      objectsThreshold: 8,
                      overlapPct: 0.15
                       // ,
                       // scene: scene
                    } );

                    divElement = document.getElementById("tabs-1");
                    
                    divElement.appendChild( renderer.domElement );

                    // document.body.appendChild( renderer.domElement );
                    window.addEventListener( 'resize', onWindowResize, false );
            }

            function onWindowResize() {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize( window.innerWidth, window.innerHeight );
                    document.getElementById("blocker").style.top = String($("ul.ui-tabs-nav").height()+27) + "px";
                    mod_message_div.style.bottom = String(infoBlock.clientHeight) + "px";
                    if (typeof $("div#detection-sign").style != 'undefined')
                        $("div#detection-sign").style.bottom = String(infoBlock.clientHeight) + "px";
            }
            
            function appendStringAsNodes(element, html) {
                var frag = document.createDocumentFragment(),
                    tmp = document.createElement('body'), child;
                tmp.innerHTML = html;
                while (child = tmp.firstChild) {
                    frag.appendChild(child);
                }
                element.appendChild(frag);
                frag = tmp = null;
            }

            //generate fake genotype - should be deleted after appearence of the real data!!!
            function getFakeGenotypeForSNP() {
                var text = "";
                var possible = "ACGT";
                for( var i=0; i < 2; i++ )
                    text += possible.charAt(Math.floor(Math.random() * possible.length));
                
                return text;
            }
            
            function reverseLine(s){
                return s.split("").reverse().join("");
            }

            function Local2global(coordinates) {
            	return {x :  zeroCoordinate.x + coordinates.x / scaleFactor, 
            		    y : zeroCoordinate.y + coordinates.y / scaleFactor, 
            		    z : zeroCoordinate.z + coordinates.z / scaleFactor };
            }
            function Global2local(coordinates) {
            	return {x :  (coordinates.x - zeroCoordinate.x) * scaleFactor, 
            		    y :  (coordinates.y - zeroCoordinate.y) * scaleFactor, 
            		    z :  (coordinates.z - zeroCoordinate.z) * scaleFactor };
            }    

            function Local2globalVector3(coordinates) {
                return new THREE.Vector3(zeroCoordinate.x + coordinates.x / scaleFactor, zeroCoordinate.y + coordinates.y / scaleFactor, zeroCoordinate.z + coordinates.z / scaleFactor);
            }

            function Global2localVector3(coordinates) {
                return new THREE.Vector3((coordinates.x - zeroCoordinate.x) * scaleFactor, (coordinates.y - zeroCoordinate.y) * scaleFactor, (coordinates.z - zeroCoordinate.z) * scaleFactor);
            }
            
            function GenerateColor() {
            	mix = [0.8, 0.8, 0.8];
			    var red = Math.random();
			    var green = Math.random();
			    var blue = Math.random();
			    // mix the color
			    red = (red + mix[0]) / 2;
			    green = (green + mix[1]) / 2;
			    blue = (blue + mix[2]) / 2;
			    return new THREE.Color().setRGB(red, green, blue);
            }
            
            function DrawSNPs(positions, track_points) {
            	var track_points_position = 0;
            	for (var point_index = 0; point_index < positions.length; ++point_index) {
            		var base_index = positions[point_index][0];
            		var snp_id = String(positions[point_index][1]);
            		while (track_points_position < track_points.length && track_points[track_points_position][1] <=  base_index) {
            			++track_points_position;
            		}
            		if (track_points_position > 0 && track_points_position < track_points.length) {
            			var prev_base_index = track_points[track_points_position - 1][1];
            			var curr_base_index = track_points[track_points_position][1];
            			var coefficient = (base_index - prev_base_index) / (curr_base_index - prev_base_index);
            			var x = (1 - coefficient) * track_points[track_points_position - 1][2] + coefficient * track_points[track_points_position][2];
            			var y = (1 - coefficient) * track_points[track_points_position - 1][3] + coefficient * track_points[track_points_position][3];
            			var z = (1 - coefficient) * track_points[track_points_position - 1][4] + coefficient * track_points[track_points_position][4];
            			var localCoords = Global2local({ x: x, y : y, z : z });
		            	var sphere = new THREE.SphereGeometry(12, 10, 10);
		            	var snp_ball = new THREE.Mesh(sphere, new THREE.LineBasicMaterial({color: 0xff0000}));
						snp_ball.name = "rs" + snp_id;            	
						snp_ball.position.set(localCoords.x,  localCoords.y, localCoords.z);
						scene.add(snp_ball);
            		}
            	}
            }
            
            function UploadRegionSNP(chr, track_points) {
        		var request = "chr=" + ((chr==='23')?'X':chr) + "&start=" + String(Math.floor(track_points[0][1])) +
        						 "&end=" + String(Math.floor(track_points[track_points.length - 1][1])); 
			    var url = "http://1kgenome.exascale.info/js_snp?" + request;
			    $.getJSON(url + "?callback=?", null, 
			    	function(positions) {
			    		DrawSNPs(positions, track_points);
			    	}
			    ); 	
            }
            
            function UploadSNP(new_model_points) {
            	var new_tracks = new_model_points["data"];
            	var longest = -1;
            	var length = 0;
            	for (var track_index = 0; track_index < new_tracks.length; ++track_index) {
            		var track_points = new_tracks[track_index][1];
            		if (track_points.length > length) {
            			longest = track_index;
            			length = track_points.length;
            		}
            	}
            	for (var track_index = longest; track_index < longest + 1; ++track_index) {
            		var chrid = new_tracks[track_index][0];
            		var chridNoStrand = chrid.substr(0, chrid.length - 2);
            		var chridOnlyNumber = chridNoStrand;
            		if (chridOnlyNumber[chridOnlyNumber.length - 1] == "a") {
            			chridOnlyNumber = chridOnlyNumber.substr(0, chridOnlyNumber.length - 1);
            		}
            		var track_points = new_tracks[track_index][1];
            		UploadRegionSNP(chridOnlyNumber, track_points);
				}
            }
                        
            
            function DrawPoints(model_points, blockIndicesStr, blockIndices) {
            	new_tracks = model_points["data"];
            	
            	for (var track_index = 0; track_index < new_tracks.length; ++track_index) {
            		chrid = new_tracks[track_index][0];
                    chridNoStrand = chrid.split('_')[0];
                    var chridOnlyNum = chrid.replace(/([\d]+).*/, "$1");
            		if (!chrid2color[chridNoStrand]) {
            			//chrid2color[chridNoStrand] = new THREE.Color().setHSL( Math.random(),  Math.random(),  Math.random());
            			chrid2color[chridNoStrand] = GenerateColor();
            		}
            		track_points = new_tracks[track_index][1];
					var tube_color = chrid2color[chridNoStrand];
					var material = new THREE.MeshLambertMaterial( { color: tube_color, shading: THREE.SmoothShading } );
                    var approx_track_point = track_points;
                    if ( serviceForStructure == '3d' ) {
                        approx_track_point = createApproximatedTrackPoints(track_points);
                    }

					var spline_points = [];
					var points_count = approx_track_point.length;
                    var lastChinkPosition;
                    if (points_count <= 1) continue;
					for (var point_index = 0; point_index < points_count; ++point_index) {
						var chunk = approx_track_point[point_index];
                        
						var localCorodinates = Global2local( {x: chunk[2], y: chunk[3], z : chunk[4] });						
						spline_points.push(new THREE.Vector3(localCorodinates.x, localCorodinates.y, localCorodinates.z));
					}
                    var spline = new THREE.SplineCurve3(spline_points);
                    var segments = points_count * 2;
                    var radiusSegments =  6;
                    var tube = new THREE.TubeGeometry(spline, segments, radiusOfTube,    radiusSegments, false, false);

                    if (typeof meter == 'undefined') {
                        if (serviceForStructure == '3d'){
                            meter = parseInt(approx_track_point[approx_track_point.length-1][1] - approx_track_point[0][1])/approx_track_point.length;
                            
                            if (healthness === 'm=leukemia') {

                                basesInSelection = meter;
                                minMeter = meter / 5 ; maxMeter = Math.min(meter * 5, 90000); stepScroll = meter / 5;    
                            } else {
                                basesInSelection = meter/2;
                                minMeter = meter / 10 ; maxMeter = meter * 2; stepScroll = meter / 10;    
                            }
                            
                        } else {
                            meter = basesInSelection;
                            minMeter = 100 ; maxMeter = 3000; stepScroll = 100;
                        }
                    } 
                    
					tube.dynamic = true;
					var tubeMesh = new THREE.Mesh(tube, material);	
                    tubeMesh.userData = [blockIndicesStr, blockIndices];
					
					tubeMesh.name = chrid + "-" + String(track_points[0][1]) + "-"  + String(track_points[track_points.length - 1][1]);

                    if (isCustomerData && typeof customerData != 'undefined') {
                    var arr = AdaptUploadedSpinesForCustomerData(approx_track_point[0][1], approx_track_point[approx_track_point.length - 1][1], chridOnlyNum);
                        uploaded_splines[tubeMesh.name] = [chrid, approx_track_point, arr[0], arr[1], chridOnlyNum];//in usual case - as before
                    } else {
                        uploaded_splines[tubeMesh.name] = [chrid, approx_track_point];//in usual case - as before
                    }
                    
					if (serviceForStructure == '3d') 
                        octree.add(tubeMesh, {useFaces: false, useVertices: true, useSeqVertices: false});
                    else octree.add(tubeMesh, {useFaces: false, useVertices: false, useSeqVertices: true});
                    scene.add(tubeMesh);
					objects.push(tubeMesh);
                    if (DEBUG) console.log('Hi')
				}
                draw_tube_response_counter++;
            }
            function createApproximatedTrackPoints(track_points) {
                
                function Interpolate2(point, otherPoint, bpIndexNeed) {
                    var bpIndex = point[1];
                    var bpIndexOther = otherPoint[1];
                    var coeff = (bpIndexNeed - bpIndex) / (bpIndexOther - bpIndex);
                    var xCoord = point[2] + (otherPoint[2] - point[2]) * coeff;
                    var yCoord = point[3] + (otherPoint[3] - point[3]) * coeff;
                    var zCoord = point[4] + (otherPoint[4] - point[4]) * coeff;
                    return {x: xCoord, y: yCoord, z: zCoord};
                }

                function Interpolate3(previousPoint, point, otherPoint, bpIndexNeed) {
                    var bpIndexPrevious = previousPoint[1];
                    var bpIndexOther = otherPoint[1];
                    var coeff = (bpIndexNeed - bpIndexPrevious) / (bpIndexOther - bpIndexPrevious);
                    var xCoord = (1-coeff) * (1-coeff) * previousPoint[2] + 2*(1-coeff) * coeff * point[2] + otherPoint[2] * coeff * coeff;
                    var yCoord = (1-coeff) * (1-coeff) * previousPoint[3] + 2*(1-coeff) * coeff * point[3] + otherPoint[3] * coeff * coeff;
                    var zCoord = (1-coeff) * (1-coeff) * previousPoint[4] + 2*(1-coeff) * coeff * point[4] + otherPoint[4] * coeff * coeff;
                    return {x: xCoord, y: yCoord, z: zCoord};
                }

                var result = [];
                
                var points_count = track_points.length;
                var rate;
                result[0] = track_points[0];
                var tempObj, previousLastTempObj;
                for (var indx = 0; indx <  points_count-1; indx++) {
                    rate = parseInt((track_points[indx+1][1] - track_points[indx][1])/NUMBER_LIMIT);
                    // if (DEBUG) console.log(track_points[indx][0] + "  -  rate = " + rate);
                    if (rate < 2) {
                        result.push(track_points[indx+1]);
                        continue;
                    }
                    for (var i = 1; i <= rate; i++) {
                        bpIndexNeed = Math.floor(track_points[indx][1] + i/rate* (track_points[indx+1][1] - track_points[indx][1]));
                        /*
                        //3points based Interpolation. Not good for neighbor cubes
                        if (points_count == 2) {
                            tempObj = Interpolate2(track_points[indx], track_points[indx+1], bpIndexNeed);
                        } else if (indx == 0) {
                            tempObj = Interpolate3(track_points[indx], track_points[indx+1], track_points[indx+2], bpIndexNeed);
                            lastTempObj = [track_points[indx+1][0], bpIndexNeed, tempObj.x, tempObj.y, tempObj.z]
                        } else if ( indx < points_count - 2 ) {
                            tempObj = Interpolate3(lastTempObj, track_points[indx+1], track_points[indx+2], bpIndexNeed);
                            if (i == rate) {
                                previousLastTempObj = lastTempObj;
                                lastTempObj = [track_points[indx+1][0], bpIndexNeed, tempObj.x, tempObj.y, tempObj.z]
                            }
                        } else if (indx == points_count - 2) {
                            tempObj = Interpolate3(((previousLastTempObj)?previousLastTempObj:track_points[indx-1]), track_points[indx], track_points[indx+1], bpIndexNeed);
                            // if (i == rate) {
                            //     deb_var = [previousLastTempObj, lastTempObj];
                            //     previousLastTempObj = lastTempObj;
                            //     lastTempObj = [track_points[indx][0], bpIndexNeed, tempObj.x, tempObj.y, tempObj.z]
                            // }
                        }
                        */
                        //linear interpolation
                        tempObj = Interpolate2(track_points[indx], track_points[indx+1], bpIndexNeed);
                        result.push([track_points[indx][0], bpIndexNeed, tempObj.x, tempObj.y, tempObj.z]);
                    }
                    // result.push(track_points[indx+1]);
                }
                return result;
            }

            function createApproximatedTrackPoints1(track_points, spline) {
                var result = [];
                var track_points_len = track_points.length;
                var points_count = spline.length;
                var globalVar;
                var start_point = 0;
                var distance, distance_between_nodes;
                var normal_counter = 0;
                
                for (var indx = 0; indx <  points_count; indx = findNextNotGroupedPoint(spline, indx)) {
                    globalVar = Local2globalVector3(spline[indx]);
                    if (indx == 0) {
                        result[normal_counter] = track_points[0];
                    }

                    for (var indx2 = start_point; indx2 < track_points_len-1/*because of decrease*/; indx2++) {
                        distance = Math.pow(track_points[indx2][2] - globalVar.x,2) + 
                                Math.pow(track_points[indx2][3] - globalVar.y,2) + 
                                Math.pow(track_points[indx2][4] - globalVar.z,2);

                        distance_between_nodes = Math.pow(track_points[indx2][2] - track_points[indx2+1][2],2) + 
                                Math.pow(track_points[indx2][3] - track_points[indx2+1][3],2) + 
                                Math.pow(track_points[indx2][4] - track_points[indx2+1][4],2);

                        if ( distance_between_nodes >= distance ) {
                            result[normal_counter] = [track_points[indx2][0], Math.floor(track_points[indx2][1] + (track_points[indx2+1][1] - track_points[indx2][1]) * distance / distance_between_nodes), globalVar.x, globalVar.y, globalVar.z];
                            break;
                        } else {
                            start_point++;
                            continue;
                        }
                    }
                    normal_counter++;
                }
                
                return result;
            }

            function AdaptUploadedSpinesForCustomerData(beginPos, endPos, chridOnlyNum) {
                var customerDataStart=-1, customerDataEnd=-1;
                {   
                    var custArray = customerData[chridOnlyNum];
                    var lenCustomerData = custArray.length;
                    for (var point_index = 0; point_index < lenCustomerData; ++point_index) {
                        if (customerDataStart==-1 && custArray[point_index][0] > beginPos) {
                            customerDataStart=point_index;
                        } else if (customerDataStart!=-1 && customerDataEnd==-1 && custArray[point_index][0] > endPos) {
                            customerDataEnd=point_index-1;
                            return [customerDataStart, customerDataEnd];
                        }
                    }
                }
            }
            
            function DrawBox(cornerModelCoordinates, edgeSize) {
		       var vertices = [];
		       for (var pointIndex = 0; pointIndex < 8; ++pointIndex) {
		           var xCoord = cornerModelCoordinates.x + edgeSize * (pointIndex % 2);
		           var yCoord = cornerModelCoordinates.y + edgeSize * ((pointIndex >> 1) % 2);
		           var zCoord = cornerModelCoordinates.z + edgeSize * ((pointIndex >> 2) % 2);
		           vertexLocalCoordinates = Global2local({x: xCoord, y: yCoord, z: zCoord });
		           vertices[pointIndex] = new THREE.Vector3(vertexLocalCoordinates.x, vertexLocalCoordinates.y, vertexLocalCoordinates.z);
		       }
		       for (var firstIndex = 0; firstIndex < vertices.length; ++firstIndex) {
		           for (var secondIndex = firstIndex + 1; secondIndex < vertices.length; ++secondIndex) {
		               var matchedCoordinates = ((firstIndex % 2) == (secondIndex % 2)) ? 1 : 0;
		               matchedCoordinates += ((firstIndex >> 1) % 2 == (secondIndex >> 1) % 2) ? 1 : 0;
		               matchedCoordinates += ((firstIndex >> 2) % 2 == (secondIndex >> 2) % 2) ? 1 : 0;
		               if (matchedCoordinates == 2) {
						   var material = new THREE.LineBasicMaterial({color: 0x0000af});
						   var geometry = new THREE.Geometry();
						   geometry.vertices.push(vertices[firstIndex]);
						   geometry.vertices.push(vertices[secondIndex]);	               	
						   var line = new THREE.Line(geometry, material);
						   scene.add(line);
		               }
		           }           
		       }      
            }

            function UploadPoints(blockCornerCoordinates, blockIndicesStr, blockIndices) {
                if (serviceForStructure == "3d")
                    overlap = blockSize * 0.30;
                else
                    overlap = blockSize * 0.2;
                
            	var request = "xstart=" + String(blockCornerCoordinates.x - overlap) 
            				  + "&xend=" + String(blockCornerCoordinates.x + blockSize + overlap)
            				  + "&zstart=" + String(blockCornerCoordinates.z - overlap)      
            				  + "&zend=" + String(blockCornerCoordinates.z + blockSize + overlap)  
            				  + "&ystart=" + String(blockCornerCoordinates.y - overlap)      
            				  + "&yend=" + String(blockCornerCoordinates.y + blockSize + overlap);
			    var url = "http://1kgenome.exascale.info/"+serviceForStructure+"?" + disease3Dexpression + request;
                draw_tube_request_counter++;
			    $.getJSON(url + "?callback=?", null, 
			    	function(model_points) {
			    		DrawPoints(model_points, blockIndicesStr, blockIndices);
			    		//UploadSNP(model_points);
			    	}
			    ).fail(function() { showErrorAlertModalWindow('Service is not available at this moment. We are doing all the best to fix it now. Please, try again later.'); draw_tube_response_counter++;});
            }
            
            function GetBlockIndices(modelPosition) {
            	blockOffset = blockSize / 2;
		        var blockIndexX = Math.floor((modelPosition.x + blockOffset) / blockSize);
		        var blockIndexY = Math.floor((modelPosition.y + blockOffset) / blockSize);
		        var blockIndexZ = Math.floor((modelPosition.z + blockOffset) / blockSize);   
		        //System.out.println(String.format("%f %f %f -> %d %d %d", x, y, z, blockIndexX, blockIndexY, blockIndexZ));
		        return {x : blockIndexX, y : blockIndexY, z : blockIndexZ };
            }
            
            function GetBlockCornerCoordinates(blockIndices) {
            	blockOffset = blockSize / 2;
            	var xCoord = blockIndices.x * blockSize - blockOffset;
            	var yCoord = blockIndices.y * blockSize - blockOffset;
            	var zCoord = blockIndices.z * blockSize - blockOffset;
            	return {x : xCoord, y: yCoord, z: zCoord};
            }
            
            function Coords2Str(coordinates) {
                return String(coordinates.x) + ":" + String(coordinates.y) + ":" + String(coordinates.z);
            }

            function Str2Coords(coorLine) {
                var arr = coorLine.split(':');
                return {x : parseInt(arr[0]), y : parseInt(arr[1]), z : parseInt(arr[2]) };
            }
            
            function UpdateModel() {
            	var modelPosition = Local2global(controls.getObject().position);
            	var blockIndices = GetBlockIndices(modelPosition);
            	var blockIndicesStr = Coords2Str(blockIndices);
                var isDifferentCube = (lastBlockIndicesStr != blockIndicesStr);
                //delete textures in the others cube only if 
                if (isDifferentCube) {
                    //immediate cleaning the octree - recreate everytime you left the cube
                    if (isOneCubeOctree) {
                        octree = new THREE.Octree( {
                          undeferred: false,
                          depthMax: Infinity,
                          objectsThreshold: 8,
                          overlapPct: 0.15
                           // ,
                           // scene: scene
                        } );
                        if (blockIndicesStr in uploaded_area) {

                            var objArray = $.grep(objects, function(v,i){return v.userData[0] === blockIndicesStr});
                            
                            for (var _o in objArray) {
                                if (serviceForStructure == '3d') 
                                    octree.add(objArray[_o], {useFaces: false, useVertices: true, useSeqVertices: false});
                                else octree.add(objArray[_o], {useFaces: false, useVertices: false, useSeqVertices: true});

                            }
                        }
                    }
                    DeleteTexturesFromCubes(blockIndicesStr, blockIndices);
                    lastBlockIndicesStr = blockIndicesStr;
                }

            	if (blockIndicesStr in uploaded_area) {
                    // if (uploaded_area[blockIndicesStr]) // if it is SOMEHOW is still true
                        // return;
            		// recreate textures in the particular cube (Tube Mesh to Line)
                    // RecreateTexturesInCube(blockIndicesStr);
            	} else {
                    uploaded_area[blockIndicesStr] = true;
                    var blockCornerCoordinates = GetBlockCornerCoordinates(blockIndices);
                    DrawBox(blockCornerCoordinates, blockSize);
                    draw_tube_response_counter = 0, draw_tube_request_counter = 0;
                    UploadPoints(blockCornerCoordinates, blockIndicesStr, blockIndices);
                }

                if (isDifferentCube) {
                    checkIncompleteColoredGene();
                    isDifferentCube = false;
                }
                // geneDrawQueue.push([arr[0], [arr[1], genePars[0], genePars[1], genePars[2]]);
                if (geneDrawQueue && geneDrawQueue.length!=0) {
                    if (DEBUG) console.log("Want to Draw " + geneDrawQueue[0][0] + ":" + geneDrawQueue[0][1]);
                    
                    geneDrawQueueLength = geneDrawQueue.length;
                    for (var i = geneDrawQueueLength-1; i >=0; i--) { //in descent as we have to rebuild the index for geneDrawQueue object
                        // if (DEBUG) console.log("!+ " + i)
                         DrawGeneRunner(i,blockIndicesStr);
                    }
                }
            }

            function checkIncompleteColoredGene() {
                var tempArr;
                for (var _gene in geneObjects) {
                    if (!geneObjects[_gene].userData[0]) {
                        tempArr = geneObjects[_gene].name.split("-");
                        geneDrawQueue.push([tempArr[0], tempArr[1], false]);
                    }
                }
            }

            function GetVerticesCut(_obj, geneObjStart, geneObjEnd, isVertUse) {
                var vertices = objects[_obj].geometry.vertices;
                var vert_cut = [], spline_points = [];;
                var vert_cut_sup = [];
                var beginEndArray = getApproximationForVerticesBeginEndPosition(vertices, uploaded_splines[objects[_obj].name][1], 0, 1, geneObjStart, geneObjEnd, isVertUse);

                if (isVertUse) {
                    if ((beginEndArray[1] - beginEndArray[0] == 1) && (beginEndArray[4] && beginEndArray[5])) {
                        if (DEBUG) console.log("isVertUse1 + " + 2)
                        vert_cut_sup.push(beginEndArray[4]);
                        vert_cut_sup.push(beginEndArray[5]);
                    } else if ((beginEndArray[1] - beginEndArray[0] > 1) && (beginEndArray[4] && beginEndArray[5])) {
                        vert_cut = uploaded_splines[objects[_obj].name][1].slice(beginEndArray[0]+1, beginEndArray[1]);
                        vert_cut_sup.push(beginEndArray[4]);
                        vert_cut_sup.push(beginEndArray[5]);
                        if (DEBUG) console.log("isVertUse2 + " + vert_cut.length + "||| " + beginEndArray[0] + "/"+ beginEndArray[1])

                    } else if ((beginEndArray[1] - beginEndArray[0] > 1)) {
                        vert_cut = uploaded_splines[objects[_obj].name][1].slice(beginEndArray[0], beginEndArray[1]+1);
                        if (DEBUG) console.log("isVertUse3 + " + vert_cut.length)

                    } else {
                        return [];
                    }

                    //have to provide local coordintes
                    for (var point_index = 0, points_count = vert_cut.length; point_index < points_count; ++point_index) {
                        var chunk = vert_cut[point_index];
                        
                        var localCorodinates = Global2local( {x: chunk[2], y: chunk[3], z : chunk[4]});                        
                        spline_points.push(new THREE.Vector3(localCorodinates.x, localCorodinates.y, localCorodinates.z));
                    }

                    if (vert_cut_sup.length > 1) {
                        spline_points.splice(0, 0, vert_cut_sup[0]);
                        spline_points.push(vert_cut_sup[1]);
                    }

                    return spline_points;

                } else {
                    var beginningGeneVert = findPreviousNotGroupedPoint(vertices, beginEndArray[0]); //actual end of previous segment for beginning of gene strand (if it is not 0)
                    var endGeneVert = findNextNotGroupedPoint(vertices, beginEndArray[1]); //actual beginning of next segment after end of gene strand (if it is not last)
                    vert_cut = vertices.slice(((beginningGeneVert!=0)?beginningGeneVert+1:0), endGeneVert-1);
                    vert_cut = getNormalizedVerticesForVertCut(vert_cut);    
                }

                return vert_cut;
                
            }

            function DrawGeneRunner(index, blockIndicesStr) {
                var tempArr;
                var geneObj, geneObjStart, geneObjEnd;
                geneObj = geneDrawQueue[index];
                for (var _obj in objects) {
                    if (!objects[_obj].name || objects[_obj].userData[0] != blockIndicesStr) continue;
                    tempArr = objects[_obj].name.split('-');
                    var chridNoStrand = tempArr[0].split('_')[0];
                    var chridOnlyNumber = chridNoStrand.replace(/([\dXYxy]+).*/,"$1");
                    if (geneDrawQueue[index] && chridOnlyNumber == geneDrawQueue[index][0]) {
                        
                        geneObjStart = genedata[geneObj[0]][geneObj[1]][1];
                        geneObjEnd = genedata[geneObj[0]][geneObj[1]][2];
                        if ( (geneObjStart>parseInt(tempArr[1]) && geneObjEnd<parseInt(tempArr[2])) ) { //full cover
                            if (DEBUG) console.log("A" /*+": " +(geneObjStart+">"+parseInt(tempArr[1])+ "&&" +geneObjEnd+"<"+parseInt(tempArr[2]))*/);

                            var vert_cut = GetVerticesCut(_obj, geneObjStart, geneObjEnd, true);
                            // var vertices = objects[_obj].geometry.vertices;
                            // var beginEndArray = getApproximationForVerticesBeginEndPosition(vertices, uploaded_splines[objects[_obj].name][1], 0, 1, geneObjStart, geneObjEnd);
                            // var beginningGeneVert = findPreviousNotGroupedPoint(vertices, beginEndArray[0]); //actual end of previous segment for beginning of gene strand (if it is not 0)
                            // var endGeneVert = findNextNotGroupedPoint(vertices, beginEndArray[1]); //actual beginning of next segment after end of gene strand (if it is not last)
                            //  = vertices.slice(((beginningGeneVert!=0)?beginningGeneVert+1:0), endGeneVert-1);
                            // vert_cut = getNormalizedVerticesForVertCut(vert_cut);
                            if (uploaded_splines_genes[geneObj[0]+"-"+geneObj[1]] && !geneObj[2]) {
                                DeleteGene(geneObj[0], geneObj[1], null, true);
                            }
                            DrawGeneOverTheTube(vert_cut, geneObj, true);
                            geneDrawQueue.splice(index, 1);
                            return;
                        } else if (geneObjStart>parseInt(tempArr[1]) && geneObjStart<parseInt(tempArr[2])) {
                            if (DEBUG) console.log("B + " + (parseInt(tempArr[2])-geneObjStart))

                            var vert_cut = GetVerticesCut(_obj, geneObjStart, parseInt(tempArr[2]), true);
                            // var vertices = objects[_obj].geometry.vertices;
                            // var beginEndArray = getApproximationForVerticesBeginEndPosition(vertices, uploaded_splines[objects[_obj].name][1], 0, 1, geneObjStart, parseInt(tempArr[2]));
                            // var beginningGeneVert = findPreviousNotGroupedPoint(vertices, beginEndArray[0]); //actual end of previous segment for beginning of gene strand (if it is not 0)
                            // var endGeneVert = findNextNotGroupedPoint(vertices, beginEndArray[1]); //actual beginning of next segment after end of gene strand (if it is not last)
                            
                            // var vert_cut = vertices.slice(((beginningGeneVert!=0)?beginningGeneVert+1:0), endGeneVert-1);
                            // vert_cut = getNormalizedVerticesForVertCut(vert_cut);
                            if (uploaded_splines_genes[geneObj[0]+"-"+geneObj[1]] && !geneObj[2]) {
                                DeleteGene(geneObj[0], geneObj[1], null, true);
                            }
                            DrawGeneOverTheTube(vert_cut, geneObj, false);
                            geneDrawQueue.splice(index, 1);
                            return;
                            //from geneObjStart to parseInt(tempArr[2]) - right intersection
                        } else if (geneObjEnd>parseInt(tempArr[1]) && geneObjEnd<parseInt(tempArr[2])) {
                            if (DEBUG) console.log("C");
                            var vert_cut = GetVerticesCut(_obj, parseInt(tempArr[1]), geneObjEnd, true);
                            // var vertices = objects[_obj].geometry.vertices;
                            // var beginEndArray = getApproximationForVerticesBeginEndPosition(vertices, uploaded_splines[objects[_obj].name][1], 0, 1, parseInt(tempArr[1]), geneObjEnd);
                            // if (DEBUG) console.log((vertices.length-1) + " / " + beginEndArray[0] + " - " + beginEndArray[1]);
                            // var beginningGeneVert = findPreviousNotGroupedPoint(vertices, beginEndArray[0]); //actual end of previous segment for beginning of gene strand (if it is not 0)
                            // var endGeneVert = findNextNotGroupedPoint(vertices, beginEndArray[1]); //actual beginning of next segment after end of gene strand (if it is not last)
                            // var vert_cut = vertices.slice(((beginningGeneVert!=0)?beginningGeneVert+1:0), endGeneVert-1);
                            // vert_cut = getNormalizedVerticesForVertCut(vert_cut);
                            if (uploaded_splines_genes[geneObj[0]+"-"+geneObj[1]] && !geneObj[2]) {
                                DeleteGene(geneObj[0], geneObj[1], null, true);
                            }
                            DrawGeneOverTheTube(vert_cut, geneObj, false);
                            geneDrawQueue.splice(index, 1);
                            return;
                            //from parseInt(tempArr[1]) to geneObjEnd - left intersection
                        } else if (geneObjStart<parseInt(tempArr[1]) && geneObjEnd>parseInt(tempArr[2])) {
                            if (DEBUG) console.log("D")
                            var vert_cut = GetVerticesCut(_obj, parseInt(tempArr[1]), parseInt(tempArr[2]), true);
                            // var vertices = objects[_obj].geometry.vertices;
                            // var beginEndArray = getApproximationForVerticesBeginEndPosition(vertices, uploaded_splines[objects[_obj].name][1], 0, 1, parseInt(tempArr[1]), parseInt(tempArr[2]));
                            // var beginningGeneVert = findPreviousNotGroupedPoint(vertices, beginEndArray[0]); //actual end of previous segment for beginning of gene strand (if it is not 0)
                            // var endGeneVert = findNextNotGroupedPoint(vertices, beginEndArray[1]); //actual beginning of next segment after end of gene strand (if it is not last)
                            // var vert_cut = vertices.slice(((beginningGeneVert!=0)?beginningGeneVert+1:0), endGeneVert-1);
                            // vert_cut = getNormalizedVerticesForVertCut(vert_cut);
                            if (uploaded_splines_genes[geneObj[0]+"-"+geneObj[1]] && !geneObj[2]) {
                                DeleteGene(geneObj[0], geneObj[1], null, true);
                            }
                            DrawGeneOverTheTube(vert_cut, geneObj, false);
                            geneDrawQueue.splice(index, 1);
                            return;
                            // from parseInt(tempArr[1]) to parseInt(tempArr[2]) - gene overlaps line interval
                        } else {
                            continue;
                        }
                    }
                }
                if (uploaded_splines_genes[geneObj[0]+"-"+geneObj[1]] && draw_tube_response_counter == draw_tube_request_counter) {
                    geneDrawQueue.splice(index, 1); //can't color this gene
                }
            }

            function DeleteAllGenes() {
                for (var i = geneObjects.length-1; i >= 0; i--) {
                    DeleteGene(null, null, i);
                }
            }

            function DeleteGene(_chr, _gene, index, isPartitionDel) {
                var nameToDelete;
                if (!index) {
                    nameToDelete = _chr + "-" + _gene;
                    index = -1;
                    for (var _geneObj in geneObjects) {
                        if (geneObjects[_geneObj].name == nameToDelete) {
                            index = _geneObj;
                            break;
                        }
                    }
                } else {
                    nameToDelete = geneObjects[index];
                }

                if (index != -1) {
                    scene.remove(geneObjects[index]);
                    geneObjects.splice(index,1);
                }
                if (!isPartitionDel) delete uploaded_splines_genes[nameToDelete];
            }

            // get full part of vertices that should be simplified and @returns central points around which we can buld tube or any other mesh
            function getNormalizedVerticesForVertCut(vert_cut) {
                var splines = [];
                var lastSegmentPoint = 0, opposite4LastSgmentPointMath = 0;
                for (var i = 0; i < vert_cut.length; i = findNextNotGroupedPoint(vert_cut,i)) {
                    lastSegmentPoint = findNextNotGroupedPoint(vert_cut,i) - 1;
                    opposite4LastSgmentPointMath = Math.floor((lastSegmentPoint+i)/2);
                    if ((lastSegmentPoint+i)%2 == 0) {
                        splines.push(new THREE.Vector3(
                            (vert_cut[i].x + 2 * vert_cut[opposite4LastSgmentPointMath].x + vert_cut[lastSegmentPoint].x )/4,
                            (vert_cut[i].y + 2 * vert_cut[opposite4LastSgmentPointMath].y + vert_cut[lastSegmentPoint].y )/4,
                            (vert_cut[i].z + 2 * vert_cut[opposite4LastSgmentPointMath].z + vert_cut[lastSegmentPoint].z )/4));
                    } else {
                        splines.push(new THREE.Vector3(
                            (vert_cut[opposite4LastSgmentPointMath].x + vert_cut[lastSegmentPoint].x )/2,
                            (vert_cut[opposite4LastSgmentPointMath].y + vert_cut[lastSegmentPoint].y )/2,
                            (vert_cut[opposite4LastSgmentPointMath].z + vert_cut[lastSegmentPoint].z )/2));
                    }
                }
                return splines;
            }

            function DrawGeneOverTheTube(vert_cut, geneObject, isComplete) {
                var tube_color = getColorForPercentage(Math.log(genedata[geneObject[0]][geneObject[1]][3])/ Math.log(33093.3057));//math
                // var material = new THREE.MeshLambertMaterial( { color: tube_color, shading: THREE.SmoothShading, side: THREE.DoubleSide} );
                // var material = new THREE.MeshBasicMaterial({
                //                 color: tube_color,
                //                 opacity: 1,
                //                 wireframe: true,
                //                 transparent: false
                //         });  
                var material = new THREE.MeshPhongMaterial( { 
                    shading: THREE.SmoothShading, 
                    side: THREE.DoubleSide,
                    color: tube_color,
                    ambient: tube_color /*0x996633*/, // should generally match color
                    specular: 0x050505,
                    shininess: 100
                } ) 
                if (DEBUG) console.log("draw gene "+geneObject[0]+"-"+geneObject[1] + "|||" + vert_cut.length)
                var spline = new THREE.SplineCurve3(vert_cut);

                var segments = vert_cut.length;
                var radiusSegments = 6;
                var tube = new THREE.TubeGeometry( spline, segments, radiusOfTube*2, radiusSegments, false, false);
                tube.dynamic = true;
                var tubeMesh = new THREE.Mesh(tube, material);
                tubeMesh.userData = [isComplete];
                tubeMesh.name = geneObject[0] + "-" + geneObject[1];
                if (!uploaded_splines_genes[tubeMesh.name])
                    uploaded_splines_genes[tubeMesh.name] = genedata[geneObject[0]][geneObject[1]];
                scene.add(tubeMesh);
                geneObjects.push(tubeMesh);
            }

            //Delete Mesh out of the alowed space region
            function DeleteTexturesFromCubes(blockIndicesStr, blockIndices) {
                var objectsIndcesToDelete = [];
                var tempUserData, tempUserDataCoord;
                var distanceToDelete = 1;
                //for (var _obj in objects) {
                if (DEBUG) console.log("Delete started");
                
                for (var _obj = 0; _obj < objects.length; ++_obj) {
                        tempUserData = objects[_obj].userData[0];
                        tempUserDataCoord = objects[_obj].userData[1];
                        if (tempUserData != blockIndicesStr && !(blockIndices.x - tempUserDataCoord.x <= distanceToDelete && blockIndices.x - tempUserDataCoord.x >= (-1*distanceToDelete) && blockIndices.y - tempUserDataCoord.y <= distanceToDelete && blockIndices.y - tempUserDataCoord.y >= (-1*distanceToDelete) && blockIndices.z - tempUserDataCoord.z <= distanceToDelete && blockIndices.z - tempUserDataCoord.z >= (-1*distanceToDelete))) {
                            
                            if (tempUserData in uploaded_area) delete uploaded_area[tempUserData];
                            scene.remove(objects[_obj]);

                            delete uploaded_splines[objects[_obj].name];
                            if (!isOneCubeOctree) octree.remove(objects[_obj]);
                            
                            objectsIndcesToDelete.push(_obj);
                        }
                }
                // octree.rebuild();
                if (DEBUG) console.log("Delete finished");
                if (objects.length>0 && objectsIndcesToDelete.length>0) {
                    objects = $.grep(objects, function(v,i){return $.inArray(i,objectsIndcesToDelete)==-1});
                }
                
                if (chipObjects.length==0) return;
                objectsIndcesToDelete = [];
                if (DEBUG) console.log("Chip Delete started");

                for (var _obj = 0; _obj < chipObjects.length; ++_obj) {
                        tempUserData = chipObjects[_obj].userData[0];
                        tempUserDataCoord = chipObjects[_obj].userData[1];


                        if (tempUserData != blockIndicesStr && !(blockIndices.x - tempUserDataCoord.x <= distanceToDelete && blockIndices.x - tempUserDataCoord.x >= (-1*distanceToDelete) && blockIndices.y - tempUserDataCoord.y <= distanceToDelete && blockIndices.y - tempUserDataCoord.y >= (-1*distanceToDelete) && blockIndices.z - tempUserDataCoord.z <= distanceToDelete && blockIndices.z - tempUserDataCoord.z >= (-1*distanceToDelete))) {
                            if (DEBUG) console.log(tempUserData);
                            if (tempUserData in chipSecCubes) delete chipSecCubes[tempUserData];
                            if (tempUserData in uploaded_area) delete uploaded_area[tempUserData];
                            scene.remove(chipObjects[_obj]);

                            delete uploaded_splines_chip[chipObjects[_obj].name];
                            
                            objectsIndcesToDelete.push(_obj);
                        }
                }
                // octree.rebuild();
                if (DEBUG) console.log("Chip Delete finished");
                if (chipObjects.length>0 && objectsIndcesToDelete.length>0) {
                    chipObjects = $.grep(chipObjects, function(v,i){return $.inArray(i,objectsIndcesToDelete)==-1});
                }
                
                
                
            }

            function GetIntersectionCHIPSEQ() {
                var vector = new THREE.Vector3(0, 0, 0);
                var raycaster = projector.pickingRay(vector, camera);
                var closestObjectDistance;
                var intersects = raycaster.intersectObjects(chipObjects);
                if (intersects.length == 0) {
                    return null;
                }
                closestObjectDistance = intersects[0].distance;
                intersects = $.grep(intersects, function(v){return v.distance <= closestObjectDistance + 5});
                return intersects;
            }

            function GetIntersection() {
            	var vector = new THREE.Vector3(0, 0, 0);
            	var raycaster = projector.pickingRay(vector, camera);
            	
                // var intersects = raycaster.intersectObjects(objects);
                var intersects = raycaster.intersectObjects(objects);
				if (intersects.length == 0) {
					return null;
				}
				return intersects[0];
            }


            
            function GetSelectedTrackPoints(intersectPoint, trackName) {
            	var intersectInModelCoordinates = Local2global(intersectPoint);
                // trackPoints from 3dQuery
            	var trackPoints = uploaded_splines[trackName][1];
            	var chrid = trackName.split("-")[0];
            	var closestPoint = -1;
            	var minDistance = -1;
            	for (var pointIndex = 0; pointIndex < trackPoints.length; ++pointIndex) {
                    if (typeof trackPoints[pointIndex] == 'undefined'){
                        if (DEBUG) console.log("ff+ " + pointIndex);
                        continue;
                    }
            		var x = trackPoints[pointIndex][2];
            		var y = trackPoints[pointIndex][3];
            		var z = trackPoints[pointIndex][4];
            		var distance = Math.pow(intersectInModelCoordinates.x - x, 2) + 
            						Math.pow(intersectInModelCoordinates.y - y, 2) +
            						Math.pow(intersectInModelCoordinates.z - z, 2);
            		if (minDistance == -1 || distance < minDistance) {
            			minDistance = distance;
            			closestPoint = pointIndex;
            		}
            	}
			    
			    var start = closestPoint;
			    while (start > 0 && Math.abs(trackPoints[start][1] - trackPoints[closestPoint][1]) < basesInSelection / 2) {
			    	--start;
			    }
			    var end = closestPoint;
			    while (end < trackPoints.length - 1 && Math.abs(trackPoints[end][1] - trackPoints[closestPoint][1]) < basesInSelection / 2) {
			    	++end;
			    }
			    
			   	function Interpolate(point, otherPoint, bpIndexNeed) {
			   		var bpIndex = trackPoints[point][1];
			   		var bpIndexOther = trackPoints[otherPoint][1];
			   		var coeff = (bpIndexNeed - bpIndex) / (bpIndexOther - bpIndex);
			   		var xCoord = trackPoints[point][2] + (trackPoints[otherPoint][2] - trackPoints[point][2]) * coeff;
			   		var yCoord = trackPoints[point][3] + (trackPoints[otherPoint][3] - trackPoints[point][3]) * coeff;
			   		var zCoord = trackPoints[point][4] + (trackPoints[otherPoint][4] - trackPoints[point][4]) * coeff;
			   		return {x: xCoord, y: yCoord, z: zCoord};
			   	}
			   	
		   		var otherPoint = start < trackPoints.length - 1 ? start + 1 : start;
		   		var exactStartPosition = Interpolate(start, otherPoint, trackPoints[closestPoint][1] - basesInSelection / 2);
		   		otherPoint = end > 0 ? end - 1 : end;
		   		var exactEndPosition = Interpolate(end, otherPoint, trackPoints[closestPoint][1] + basesInSelection / 2);
				
				var selectionTrackPoints = [Global2local(exactStartPosition)];
				for (var pointIndex = start + 1; pointIndex < end; ++pointIndex) {
					selectionTrackPoints.push(Global2local({x: trackPoints[pointIndex][2], y: trackPoints[pointIndex][3], z: trackPoints[pointIndex][4]}));
				}
				selectionTrackPoints.push(Global2local(exactEndPosition));
                //draw selection old - plane
                // if (is_plane_mode)
                if (mode_id == 0)
                {
                    var spline = new THREE.SplineCurve3(selectionTrackPoints);
                    var segments = serviceForStructure=='3d' ? Math.floor(basesInSelection/6500) : basesInSelection/50; 
                    var radiusSegments = 6;
                    
                    var tube = new THREE.TubeGeometry(spline, segments, radiusOfTube+10, radiusSegments, false, false);
                    tube.dynamic = true;
                    scene.remove(selectionMesh);

                    delete selectionMesh;
                    {
                        var material = new THREE.MeshBasicMaterial({
                                color: 0xff0000,
                                opacity: 1,
                                wireframe: true,
                                transparent: false
                        });                     
                        
                        selectionMesh = new THREE.Mesh(tube, material);
                        selectionMesh.geometry.verticesNeedUpdate = true;
                        scene.add(selectionMesh);
                    }
                    
                } else if (mode_id == 1)
				//draw selection new - cube
                {
                    var cube = new THREE.CubeGeometry(radiusSphere*2,radiusSphere*2,radiusSphere*2, 5, 5, 5);
                    cube.dynamic = true;
                    scene.remove(selectionMesh);
                    {
                        var material = new THREE.MeshBasicMaterial({
                                color: 0xff0000,
                                opacity: 1,
                                wireframe: true,
                                transparent: false
                        });                     
                        
                        selectionMesh = new THREE.Mesh(cube, material);
                        selectionMesh.position = new THREE.Vector3(intersectPoint.x, intersectPoint.y, intersectPoint.z);
                        // selectionMesh.geometry.verticesNeedUpdate = true;
                        scene.add(selectionMesh);
                    }
                    
                }
				return [chrid, trackPoints[closestPoint][1] - basesInSelection / 2, 
							trackPoints[closestPoint][1] + basesInSelection / 2]; 	
            }
            
            function ClearInfo() {
            	if (infoBlock) {
            		infoBlock.innerHTML = "";
                    lastRegion = [];
                    rgn = [];
                    document.getElementById('detection-sign').style.display = "none";
            	}
            }
            
            function PositionToString(region) {
            	var helix = region[0].split("_")[1];//temp storage
                if (typeof helix == 'undefined')
                    helix = '';
                else if (helix == 'a') helix = ', helix A';
                else helix = ', helix B';
            	var info = "Selection: chromosome: " + region[0].split("_")[0] +  helix;
            	info += ", bases: " + String(Math.floor(region[1])) + "&ndash;" + String(Math.floor(region[2]));
            	return info;            	
            }

			function UploadRegionData(region) {
            	var request = "start=" + String(Math.floor(region[1])) 
            				  + "&end=" + String(Math.floor(region[2]))
            				  + "&chrid=" + String(region[0]);
			    var url = "http://1kgenome.exascale.info/range?" + request;		
			    $.getJSON(url + "?callback=?", null, 
			    	function(regionInfo) {
			    		var key = PositionToString(region);
			    		var chrid = region[0];
			    		chrid = chrid.replace("_b", "_a");
			    		var key_a = PositionToString([chrid, region[1], region[2]]);
			    		chrid = chrid.replace("_a", "_b");
			    		var key_b = PositionToString([chrid, region[1], region[2]]);
			    		formated_data = "<br/>@Bases: <a target='_blank' style=\"color: rgb(0,255,0)\" href='http://1kgenome.exascale.info/range?" + request + "'>" + regionInfo.substring(0, 50) + "...</a>";
			    		regionData[key_a][1] = formated_data;
			    		regionData[key_b][1] = formated_data;
			    		infoBlock.innerHTML = regionData[key][0] + regionData[key][1] + regionData[key][2];
			    		/*
			    		if (infoBlock.innerHTML == key) {
			    			infoBlock.innerHTML = regionData[key];
			    		} else {
			    			if (DEBUG) console.log(": " + infoBlock.innerHTML);
			    		}
			    		*/
			    	}
			    ); 	
			    
			    {//SNPs
			    	var chrid = String(region[0]);
                     if (DEBUG) console.log(chrid);
            		var chridNoStrand = chrid.split('_')[0];
            		var chridOnlyNumber = chridNoStrand;
            		if (chridOnlyNumber[chridOnlyNumber.length - 1] == "a") {
            			chridOnlyNumber = chridOnlyNumber.substr(0, chridOnlyNumber.length - 1);
            		}
			    	
	        		var request = "chr=" + ((chridOnlyNumber=='23')?'X':chridOnlyNumber) + "&start=" + String(Math.floor(region[1])) +
	        						 "&end=" + String(Math.floor(region[2])); 
				    var url = "http://1kgenome.exascale.info/js_snp?" + request;
				    $.getJSON(url + "?callback=?", null, 
				    	function(positions) {
				    		snips = "";
                            var genotypeArray = [];
			            	for (var point_index = 0; point_index < positions.length; ++point_index) {
			            		var base_index = positions[point_index][0];

                                genotypeArray[point_index] = /*getFakeGenotypeForSNP();*/positions[point_index][2]+positions[point_index][3];
			            		var snp_id = /*"rs" + */String(positions[point_index][1]);
			            		snips += " <a target=\"_blank\" style=\"color: rgb(255,255,0)\" href=\"http://www.ncbi.nlm.nih.gov/SNP/snp_ref.cgi?rs="+snp_id+"\">rs"+snp_id+"</a>;";
			            	}

			            	formated_data = "<br/>@SNPs:" + snips;
			            	var key = PositionToString(region);
				    		var chrid = region[0];
				    		chrid = chrid.replace("_b", "_a");
				    		var key_a = PositionToString([chrid, region[1], region[2]]);
				    		chrid = chrid.replace("_a", "_b");
				    		var key_b = PositionToString([chrid, region[1], region[2]]);
				    		regionData[key_a][2] = formated_data;
				    		regionData[key_b][2] = formated_data;
                            regionData[key_a][3] = genotypeArray;
                            regionData[key_b][3] = genotypeArray;
				    		infoBlock.innerHTML = regionData[key][0] + regionData[key][1] + regionData[key][2];
				    	}
				    );
			    }		    

			}

            function buildCubeDataStructureSNPs(resultSet) {
                    if (resultSet == null || resultSet.length == 0) {
                        if (DEBUG) console.log("EMPTY area - you should not see this");
                        return;
                    }
                 var arrRequestInfo = [];
                 for (var track_index in resultSet) {
                    var chridOnlyNumber = resultSet[track_index].chr;
                    arrRequestInfo[track_index] = [];
                    for (var intervals_indx in resultSet[track_index].intervals) {
                        if (DEBUG) console.log("["+track_index+"]" + "["+intervals_indx+"]")
                        var request = "chr=" + ((chridOnlyNumber=='23')?'X':chridOnlyNumber) + "&start=" + String(Math.floor(resultSet[track_index].intervals[intervals_indx].start)) +
                                     "&end=" + String(Math.floor(resultSet[track_index].intervals[intervals_indx].end)); 
                        var url = "http://1kgenome.exascale.info/js_snp?" + request;
                        req_count++;
                        arrRequestInfo[track_index][intervals_indx] = [];
                        arrRequestInfo[track_index][intervals_indx][0] = [chridOnlyNumber, String(resultSet[track_index].intervals[intervals_indx].start), String(resultSet[track_index].intervals[intervals_indx].end)];
                        arrRequestInfo[track_index][intervals_indx][1] = $.getJSON(url + "?callback=?", null, 
                            function(positions) {
                                snips = "";
                                for (var point_index = 0; point_index < positions.length; ++point_index) {
                                    var base_index = positions[point_index][0];
                                    var snp_id = /*"rs" + */String(positions[point_index][1]);
                                    snips += " <a target=\"_blank\" style=\"color: rgb(0,0,255)\" href=\"http://www.ncbi.nlm.nih.gov/SNP/snp_ref.cgi?rs="+snp_id+"\">rs"+snp_id+"</a>;";
                                }
                                if (tableStrContent.length == 0) tableStrContent += snips;
                                else tableStrContent += "<br><hr>" + snips;

                                resp_count++;
                            }
                        );
                    }
                }
                return arrRequestInfo;
            }
            
            function UpdateInfoChipSeq() {
                intersection = GetIntersectionCHIPSEQ();
                if (intersection == null) {
                    ClearInfo();
                    return;
                }
                
                var temp;
                if (typeof lastIntersection  != 'undefined' && intersection[0].point.x == lastIntersection.x && intersection[0].point.y == lastIntersection.y && intersection[0].point.z == lastIntersection.z) {
                    return;
                } else {
                    ClearInfo();
                    for (var inter_indx in intersection) {
                        temp = uploaded_splines_chip[intersection[inter_indx].object.name];
                        // infoBlock.innerHTML += intersection[inter_indx].object.name + "; ";
                        infoBlock.innerHTML += "<a target='_blank' style='color: rgb(255,255,0)' href='http://genome.ucsc.edu/cgi-bin/hgTracks?db=hg19&position=chr"+temp[0]+"%3A"+temp[1]+"-"+temp[2]+"' >"+temp[0]+"-"+temp[1] + ":"+temp[2] + " -> " + temp[3] + "("+temp[4]+")</a>; ";
                    }
                    lastIntersection = intersection[0].point;
                }
            }

            function UpdateInfo() {
                if (mode_id == 2) {
                    UpdateInfoChipSeq();
                    return;
                }

                intersection = GetIntersection();
                if (intersection == null) {
                    ClearInfo();
                    return;
                }

                if (mode_id == 1) {

                    ClearInfo();
                    //draw selection new - cube
                    {
                        var cube = new THREE.CubeGeometry(radiusSphere*2,radiusSphere*2,radiusSphere*2, 5, 5, 5);
                        cube.dynamic = true;
                        scene.remove(selectionMesh);
                        {
                            var material = new THREE.MeshBasicMaterial({
                                    color: 0xff0000,
                                    opacity: 1,
                                    wireframe: true,
                                    transparent: false
                            });
                            selectionMesh = new THREE.Mesh(cube, material);
                            selectionMesh.position = new THREE.Vector3(intersection.point.x, intersection.point.y, intersection.point.z);
                            scene.add(selectionMesh);
                        }
                    }
                    return;
                }

            	object = intersection.object;
            	point = intersection.point;
            	if (object.name == "") {
                    ClearInfo();
            		return;
            	}

                if ((typeof uploaded_splines[object.name] === 'undefined')) {
                    if (DEBUG) console.log("Warning: undefined!!!"); 
                    ClearInfo();
                    return;
                }


            	var region = GetSelectedTrackPoints(point, object.name);
                rgn = region;
            	var positionStr = PositionToString(region);
            	if (positionStr in regionData && (lastRegion==null || lastRegion[0] != regionData[positionStr][0] && lastRegion[1] != regionData[positionStr][1] && lastRegion[2] != regionData[positionStr][2])) {
            		infoBlock.innerHTML = regionData[positionStr][0] + regionData[positionStr][1] + regionData[positionStr][2]; //@TODO: change place of storing data for genotype!!! and call here only regionData[positionStr]
                    lastRegion = regionData[positionStr];
                    
                    if (isCustomerData) {
                        var custDataArray = customerData[uploaded_splines[object.name][4]].slice(uploaded_splines[object.name][2],uploaded_splines[object.name][3]+1);
                        var startRegPos = parseInt(region[1]);
                        var endRegPos = parseInt(region[2]);
                        for (var indx = 0; indx < custDataArray.length; indx++) {
                            if ( custDataArray[indx][0] < startRegPos ) continue;
                            else if (custDataArray[indx][0] > endRegPos ) {
                                document.getElementById('detection-sign').style.display = "none";
                                break;
                            }
                            else {
                                document.getElementById('detection-sign').style.display = "";
                                break;
                            }
                        }
                    }
                    
            	} else if (!(positionStr in regionData)) {
            		//show something immidiately
            		infoBlock.innerHTML = positionStr + "<br/>data uploading...";
            		//also works like flag: request is already sent
            		regionData[PositionToString([region[0].replace("_b", "_a"), region[1], region[2]])] = [positionStr, "", ""];
            		regionData[PositionToString([region[0].replace("_a", "_b"), region[1], region[2]])] = [positionStr, "", ""];
                    //show snps of the user here
                    
                    if (isCustomerData) {
                        var custDataArray = customerData[uploaded_splines[object.name][4]].slice(uploaded_splines[object.name][2],uploaded_splines[object.name][3]+1);
                        var startRegPos = parseInt(region[1]);
                        var endRegPos = parseInt(region[2]);
                        for (var indx = 0; indx < custDataArray.length; indx++) {
                            if ( custDataArray[indx][0] < startRegPos ) continue;
                            else if (custDataArray[indx][0] > endRegPos ) {
                                document.getElementById('detection-sign').style.display = "none";
                                break;
                            }
                            else {
                                document.getElementById('detection-sign').style.display = "";
                                break;
                            }
                        }
                    }
                    
                    
            		UploadRegionData(region);            		
            	}
            }

            function animate() {
                    requestAnimationFrame( animate );
                    UpdateTargetBallPosition();
                    UpdateInfo();
                   	UpdateModel();
                        
                    // updateGUI();    
                    controls.update( Date.now() - time );
                    renderer.render( scene, camera );
                    octree.update();
                    time = Date.now();
            }
            
            function showErrorAlertModalWindow(message, functionBeforeCallback) {
                drawMessiModalWindow(message, 'Error Message', null, null, false, true, 'anim error', functionBeforeCallback);
            }
            
            function exitFromFullScreen() {
                document.exitFullscreen = document.mozCancelFullScreen || document.webkitCancelFullScreen || document.msExitFullscreen;
                document.exitFullscreen();
                
            }
            
            function enterInFullScreen() {
                var element = document.body;
                element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;
                element.requestFullscreen();
            }

            function exitPointerLockFunction() {
                is_modal_opened = true;
                $('p#textmode').text('');
                document.exitPointerLock = document.exitPointerLock ||
                                            document.mozExitPointerLock ||
                                            document.webkitExitPointerLock;
                document.exitPointerLock();
                keys_block.style.display = "none";
                if ( /Firefox/i.test( navigator.userAgent ) ) exitFromFullScreen();
            }

            function drawMessiModalWindow(content, title, top, left, isDelayed, isCenter, titleClass, functionBeforeCallback) {
                if (!titleClass) titleClass = 'success';
                var callbackFunc = function(val) { 
                    if (functionBeforeCallback)
                        functionBeforeCallback();
                    if ( /Firefox/i.test( navigator.userAgent ) ) enterInFullScreen();
                    element.requestPointerLock = element.requestPointerLock||element.mozRequestPointerLock||element.webkitRequestPointerLock;
                    element.requestPointerLock();
                    document.getElementById('detection-sign').style.display = "none";
                    if ($(document).height() > FIXED_HEIGHT_SCREEN)
                        keys_block.style.display = "block";
                    is_modal_opened = false;
                }

                if (!isDelayed) {
                    exitPointerLockFunction();
                }
                var element = document.body;
                if (isCenter)
                    _messi = new Messi(content, {title: title, center: isCenter, titleClass: titleClass, buttons: [{id: 0, label: 'Ok', val: 'O'}], 
                    callback: callbackFunc});
                else
                    _messi = new Messi(content, {title: title, center: isCenter, viewport: {top: top, left: left}, titleClass: titleClass, buttons: [{id: 0, label: 'Ok', val: 'O'}], 
                    callback: callbackFunc});

            }

        </script>
        
        <script>
        	
            keys_block = document.getElementById('keys');
            keys_block.style.display = "none";
            infoBlock = document.createElement('div');
			infoBlock.id = "infoblock";
			// document.body.appendChild(infoBlock); 
            divElement.appendChild(infoBlock);
            mod_message_div = document.createElement('p');
            mod_message_div.id = "textmode";
            mod_message_div.style.bottom = String(infoBlock.clientHeight) + "px";
            document.getElementById("detection-sign").style.bottom = String(infoBlock.clientHeight) + "px";
            document.getElementById('detection-sign').style.display = "none";
//            mod_message_div.style = "display:none";
            mod_message_div.appendChild(document.createTextNode(""));
            divElement.appendChild(mod_message_div);
            
            // var gui = new dat.GUI();

            // var func = function() {
            //   this.displayOutline = false;
            // };
            // gui.add(text, 'displayOutline');

			/*staticBlock = document.createElement('div');
			staticBlock.id = "staticblock";
			staticBlock.innerHTML = "<em>3DBD Genome browser</em>, contact: <a target='_blank' href='http://exascale.info/'>eXascale Infolab</a>, {phil, ruslan}@exascale.info; <a target='_blank' href='http://www.scs.carleton.ca/'>McGill University SoCS</a>, jeromew@cs.mcgill.ca, alexander.butyaev@mail.mcgill.ca.";
			// document.body.appendChild(staticBlock); 
            divElement.appendChild(staticBlock);*/
				
		</script>
    </body>
</html>