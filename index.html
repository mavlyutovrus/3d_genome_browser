<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>3DBD genome browser</title>
		<link href="css/main.css" rel="stylesheet" type="text/css"/>
        <link rel="stylesheet" href="http://code.jquery.com/ui/1.10.3/themes/smoothness/jquery-ui.css">
        <link rel="stylesheet" href="js/messi/messi.min.css" />
        <!-- jquery -->
        <script src="http://code.jquery.com/jquery-1.10.2.js"></script>
        <script src="http://code.jquery.com/ui/1.10.4/jquery-ui.js"></script>

        <!-- lite version of three.js distrib   -->
        <!--script src="js/min.three.js"></script-->
        <script type="text/javascript" src="js/three.min_new.js"></script>
        <script type="text/javascript" src="js/threeoctree.js"></script>

    	<!-- hacked PointerLockControls.js from "three/examples/js/controls/PointerLockControls.js" -->
		<script src="js/PointerLockControls.js"></script>
    	
        <script type='text/javascript' src='js/messi/messi.min.js'></script>

        <script src="content/TextMessages.js"></script>

        <!--script type="text/javascript" src="https://apis.google.com/js/plusone.js"></script-->

        <script>
              $(function() {
                $( "#tabs" ).tabs();
              });
        </script>

		<!-- low-resolution 3d model  -->
		<!--<script src="data.js"></script>-->
        
    </head>
    <body>
        <!-- Share scripts for FB/ Twt-->
        <script>(function(d, s, id) {
          var js, fjs = d.getElementsByTagName(s)[0];
          if (d.getElementById(id)) return;
          js = d.createElement(s); js.id = id;
          js.src = "http://connect.facebook.net/us_US/all.js#xfbml=1";
          fjs.parentNode.insertBefore(js, fjs);
        }(document, 'script', 'facebook-jssdk'));
        </script>
        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');
        </script>


        
        <!-- google analytics -->
        <div id="tabs">
          <ul>
            <li><a id="href_tabs-0" href="#tabs-0">Welcome Page/UI</a></li>
            <li><a id="href_tabs-1" href="#tabs-1">Genome Browser</a></li>
            <li><a id="href_tabs-2" href="#tabs-2">Something else</a></li>
            <li><a id="href_tabs-3" href="#tabs-3">Contact us</a></li>
          </ul>
          <div id="tabs-0">
            <p>Welcome to 3D Genome Browser page</p>
            <p><input id = "incoords" type="text" title="The format of data 'x,y,z'." size="40">
                <p>
                    <button type="button" onclick="var incoords = document.getElementById('incoords').value; if (validate(incoords)) {ChangeCameraPosition(incoords); $('#tabs').tabs('option', 'active', 1); } else {window.alert('Wrong format of input data. It should be [x,y,z] where any symbol(s) except for numeric could be separators');}">Action</button>
                </p>
            </p>
          </div>
          <div id="tabs-1">
                <div id="blocker">
                    <div id="instructions">
                        <span style="font-size:40px">Click to Explore</span><br/>W, A, S, D = Move, MOUSE = Look around, SCROLL = +/- selection size<br/>C = Change mode, Left Click = <i>CUBIC mode:</i> explore SNPs in cubic area; <i>CHIPSEQ mode:</i> color CHIP-Seq data, Tab = for more information<br/>G = get relation between Transcription Factors and SNPs (<i>PLANE</i> and <i>CUBIC mode</i>)<br/>

                        Supported browsers: Firefox, Google Chrome.
                    </div>
                </div>
          </div>
          <div id="tabs-2">
            <p></p>
          </div>
          <div id="tabs-3">
            <p><em>3DBD Genome browser</em>, contact: <a target='_blank' href='http://exascale.info/'>eXascale Infolab</a>:
                <a style="color: rgb(0,0,255)" href="mailto:phil@exascale.info?subject=[3D Genome Browser]">Philippe Cudre-Mauroux</a>, <a style="color: rgb(0,0,255)" href="mailto:ruslan@exascale.info?subject=[3D Genome Browser]">Ruslan Mavlyutov</a>; <a target='_blank' href='http://csb.cs.mcgill.ca/'>McGill University SoCS</a>: <a style="color: rgb(0,0,255)" href="mailto:jeromew@cs.mcgill.ca?subject=[3D Genome Browser]">Jérôme Waldispühl</a>, <a style="color: rgb(0,0,255)" href="mailto:alexander.butyaev@mail.mcgill.ca?subject=[3D Genome Browser]">Alexander Butyaev</a>.</p>
            
            <!--Share conteiner -->
            <div>
                <div class="button twitter" data-type="button_count"><a href="https://twitter.com/share" class="twitter-share-button" data-url="http://1kgenome.exascale.info" data-text="The best 3D Genome Browser">Tweet</a></div>
                <div class="fb-share-button" data-href="https://1kgenome.exascale.info" data-type="button_count" data-text="The best 3D Genome Browser">
                </div>
                <div class="g-plusone" data-size="tall" data-href="http://1kgenome.exascale.info" data-text="The best 3D Genome Browser" data-annotation="inline" data-width="300" ></div>
                <!--div class="g-plusone" data-annotation="inline" data-width="300"></div-->
                <!--g:plusone></g:plusone>
                <script type="text/javascript">
                    window.___gcfg = {
                        lang: 'en-US'
                    };
                    (function() {
                        var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
                        po.src = 'https://apis.google.com/js/platform.js';
                        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
                    })();
                </script-->
            <!--/div-->



          </div>
        </div>

		<!-- main part -->
        <script>
            var globalArrayForWindow;

            var MAX_WAIT_INTERVAL = 10000;
            var waitInterval = 0;
            var resp_count = 0;
            var req_count = 0;
            var tableStrContent = '';

            var rgn;//made it global for table

            var lastRegion, lastIntersection;
            var arrayOfCHIPCoveredTubes = [];
            var lastMode;
            var _messi;
            var is_modal_opened = false;
            var mod_message_div;
            var MAX_CHIP_LVL = 1000;
            var percentColors = [
                { pct: 0.0, color: { r: 0x00, g: 0xff, b: 0 } },
                { pct: 0.5, color: { r: 0x88, g: 0x88, b: 0 } },
                { pct: 1.0, color: { r: 0xff, g: 0x00, b: 0 } } ];
            var current_cell_line = 'K562';
            var is_coloring_of_chipseq = false;
            var deb_var;
            var lastBlockIndicesStr;
            var radiusSphere = 40, segmentsWidth = 32, segmentsHeight = 16; //sphere zone parameters
            var maxRadiusSphere = 140, minRadiusSphere = 20;
            var regexpPattern = /[^\d]*([\d]+)[^\d]+([\d]+)[^\d]+([\d]+)[^\d]*/; //format smth(0+) [num] smth(1+) [num] smth(1+) [num] smth(0+)
            var regexpPatternURL = /([\dXY]{1,2})[_]*([abAB]*)[^\d]+([\d]+)[^\d]+([\d]+)/ ;
            var divElement;
            var test_mesh;
        	var DEBUG = true;
			// zero point in local coordinates translates into zeroCoordinate in the model coordinates        
        	var zeroCoordinate = {x : 400.0, y: 150.0, z: 0.0};
        	// 1 point in the model coordinates =  scaleFactor points in local coordinates
        	var scaleFactor = 10; 
        	var blockSize = 400;
        
            var camera, scene, renderer, controls;
            var projector = new THREE.Projector();
            
            var infoBlock, staticBlock;
            
            var selectionMesh;
            
            var targetBall;
            
            var basesInSelection = 1500;
            
            var sphere;
            var uploaded_area = {};
            
            var uploaded_splines = {};
            var uploaded_splines_chip = {};
            var uploaded_splines_selection = {};

            var time = Date.now();

			// 3d dna molecules
            var objects = [];

            var chipObjects = [];

            var lines = [];
            
            var regionData = {};
			
			// dark screen, when the game starts
            var blocker = document.getElementById( 'blocker' );
            var instructions = document.getElementById( 'instructions' );
            
            var position = "";
            

            var snp_chip_seq_window;

            var is_plane_mode = true; //start with plane mode
            var mode_name;
            var mode_id = 0;
            var NUMBER_OF_MODES = 3;

            function validate(incoords) {
                return (incoords.match(regexpPattern) != null);
            }

            function ChangeCameraPosition(incoords) {
                
                var str = incoords.replace(regexpPattern, "$1:$2:$3");
                var arr = str.split(':');
                controls.getObject().position = new THREE.Vector3(parseInt(arr[0]), parseInt(arr[1]), parseInt(arr[2]));
            }

            function changeModeIndicator() {
                //maybe it's not necessary 
                ClearInfo();

                switch(mode_id) {
                    case 0: //plane mode
                        if (lastMode == 2) cleanCHIPSEQdata();
                        mode_name = 'Plane mode';
                        $('p#textmode').text(mode_name+' (TAB for info)');
                        lastMode = 0;
                        break;
                    case 1: //cubic mode
                        if (lastMode == 2) cleanCHIPSEQdata();
                        mode_name = 'Cubic mode';
                        $('p#textmode').text(mode_name+' (TAB for info)');
                        lastMode = 1;
                        break;
                    case 2: //CHiP-SEQ mode
                        scene.remove(selectionMesh);
                        mode_name = 'CHiP-Seq mode';
                        $('p#textmode').text(mode_name+' (TAB for info)');
                        lastMode = 2;
                        break;
                    default:
                        $('p#textmode').text('');
                        break;
                }
            }
            
            function cleanCHIPSEQdata() {
                for (var indx in chipObjects) {
                    scene.remove(chipObjects[indx]);
                }
                chipObjects = [];
                uploaded_splines_chip = {};
                arrayOfCHIPCoveredTubes = [];
            }

            function init_controls() {
                var element = document.body;
                var pointerlockchange = function ( event ) {
                    // console.log( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element);
                    if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element) {
                        controls.enabled = true;
                        blocker.style.display = 'none';
                        changeModeIndicator();
                    } else {
                        controls.enabled = false;
                        blocker.style.display = '-webkit-box';
                        blocker.style.display = '-moz-box';
                        blocker.style.display = 'box';
                        if (!is_modal_opened) instructions.style.display = '';
                        $('p#textmode').text('');
                    }
            	}
                var pointerlockerror = function ( event ) {
                    instructions.style.display = '';
                }

                // Hook pointer lock state change events
                document.addEventListener( 'pointerlockchange', pointerlockchange, false );
                document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
                document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );

                document.addEventListener( 'pointerlockerror', pointerlockerror, false );
                document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
                document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );
                window.addEventListener( "oncontextmenu", function ( event ) { 
                }, false );
                
                window.addEventListener("click",function(e) {
                if(controls.enabled == true) {
                        if (mode_id == 1) { // only cubic mode
                            is_modal_opened = true;
                            $('p#textmode').text('');
                            document.exitPointerLock = document.exitPointerLock ||
                                                        document.mozExitPointerLock ||
                                                        document.webkitExitPointerLock;
                            document.exitPointerLock();
                            tableStrContent = '';
                            buildCubeDataStructureSNPs(searchOctree())

                            waitFunction();

                            return false;
                        } else if (mode_id == 2) { // only for CHIP-SEq mode
                            var _intersection = GetIntersection();
                            if (_intersection == null) {
                                alert("Point the area firstly!");
                                return;
                            }
                            if (_intersection.object.name == "")
                                return;
                            if ($.inArray(_intersection.object.name, arrayOfCHIPCoveredTubes) != -1)
                                return;
                            
                            arrayOfCHIPCoveredTubes.push(_intersection.object.name);
                            drawChipSeqDataRunner(_intersection); //should be renamed
                        }
                    }
                });

                instructions.addEventListener( 'click', function ( event ) {
                    instructions.style.display = 'none';
                    // Ask the browser to lock the pointer
                    element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
                    if ( /Firefox/i.test( navigator.userAgent ) ) {
                        var fullscreenchange = function ( event ) {
                            if ( document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element ) {
                                document.removeEventListener( 'fullscreenchange', fullscreenchange );
                                document.removeEventListener( 'mozfullscreenchange', fullscreenchange );
                                element.requestPointerLock();
                            }
                        }
                        document.addEventListener( 'fullscreenchange', fullscreenchange, false );
                        document.addEventListener( 'mozfullscreenchange', fullscreenchange, false );
                        element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;
                        element.requestFullscreen();
                    } else {
                        element.requestPointerLock();
                    }
                }, false );    
                
				{
                    var GKeyDownHandler = function (event) {
                        var element = document.body;
                        if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element )
                            switch ( event.keyCode ) {
                                /*moved to the left click event for the window*/
                                // case 84: //t
                                    
                                //     break;
                                case 71: //g
                                    // if (!is_plane_mode) {
                                    if (mode_id == 0) {
                                        var _intersection = GetIntersection();
                                        if (_intersection == null) {
                                            alert("Point the area firstly!");
                                            return;
                                        }
                                        init_new_window_SNP_CHIP_SEQ(rgn, true);
                                    } else if (mode_id == 1) {
                                        var _intersection = GetIntersection();
                                        if (_intersection == null) {
                                            alert("Point the area firstly!");
                                            return;
                                        }

                                        init_new_window_SNP_CHIP_SEQ(_intersection.point, false);
                                    }
                                    break;
                                case 67: //c - change mode
                                    // is_plane_mode = !is_plane_mode;
                                    mode_id ++;
                                    if (mode_id >= NUMBER_OF_MODES) mode_id = 0;
                                    changeModeIndicator();
                                    break;  
                                case 9: //tab - information about current mode
                                    is_modal_opened = true;
                                    $('p#textmode').text('');
                                    document.exitPointerLock = document.exitPointerLock ||
                                                                document.mozExitPointerLock ||
                                                                document.webkitExitPointerLock;
                                    document.exitPointerLock();
                                    _messi = new Messi(textMessages[mode_name], {title: mode_name, titleClass: 'success', buttons: [{id: 0, label: 'Ok', val: 'O'}], 
                                        callback: function(val) { element.requestPointerLock = element.requestPointerLock ||
                                                                     element.mozRequestPointerLock ||
                                                                     element.webkitRequestPointerLock;
                                        element.requestPointerLock(); is_modal_opened = false;}});
                                    return false;
                            }
                    }

                    //scrolling event
					var scrollHandler = function (event) {
                        var element = document.body;
                        if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ){
                            if (event.detail != null && event.detail < 0 || event.wheelDeltaY != null && event.wheelDeltaY > 0) {
                                basesInSelection = Math.min(3000, basesInSelection + 100);
                                radiusSphere = Math.min(maxRadiusSphere, radiusSphere + 10);
                            } else {
                                basesInSelection = Math.max(100, basesInSelection - 100);
                                radiusSphere = Math.max(minRadiusSphere, radiusSphere -10);
                            }    
                        }
						
					};
					var mousewheelevt = (/Firefox/i.test(navigator.userAgent)) ? "DOMMouseScroll" : "mousewheel";
					if (document.attachEvent) //if IE (and Opera depending on user setting) 
                    {
                        document.attachEvent("on"+mousewheelevt, scrollHandler);
                        document.attachEvent("onkeydown", GKeyDownHandler);
                    }
					else if (document.addEventListener) //WC3 browsers
                    {
                        document.addEventListener(mousewheelevt, scrollHandler, false);
                        document.addEventListener("keydown", GKeyDownHandler, false);
                    }
				}
            }

            function waitFunction(){
                console.log(req_count  + " : " + resp_count);
                if (resp_count < req_count && waitInterval < MAX_WAIT_INTERVAL) {
                    waitInterval = waitInterval + 50;
                    setTimeout(waitFunction, 50);
                } else {
                    var element = document.body;
                    _messi = new Messi(tableStrContent, {title: 'Cubic data', center: false, viewport: {top: '5vh', left: '30%'}, titleClass: 'success', buttons: [{id: 0, label: 'Ok', val: 'O'}], 
                                            callback: function(val) { element.requestPointerLock = element.requestPointerLock ||
                                                                         element.mozRequestPointerLock ||
                                                                         element.webkitRequestPointerLock;
                                            element.requestPointerLock(); is_modal_opened = false;}});
                }
            }

            function drawModalWindowTable(meshesSearch) {


                var element = document.body;
                    _messi = new Messi(tableStrContent, {title: 'Cubic data', center: false, viewport: {top: '5vh', left: '30%'}, titleClass: 'success', buttons: [{id: 0, label: 'Ok', val: 'O'}], 
                                            callback: function(val) { element.requestPointerLock = element.requestPointerLock ||
                                                                         element.mozRequestPointerLock ||
                                                                         element.webkitRequestPointerLock;
                                            element.requestPointerLock(); is_modal_opened = false;}});
            }

            function drawChipSeqDataRunner(_intersection) {
                var name = _intersection.object.name;
                var requestCHIP = name.replace(regexpPatternURL, "chr=$1&start=$3&end=$4&celline="+current_cell_line);

                var urlCHIP = 'http://1kgenome.exascale.info/chipseq?' + requestCHIP;

                $.getJSON(urlCHIP + "?callback=?", null, 
                    function(data) {
                        drawChipSeqData(data, _intersection);
                    }
                );
            }

            function drawChipSeqData(data, _intersection) {
                var name = _intersection.object.name;
                var vertices = _intersection.object.geometry.vertices;
                var aLen = vertices.length;
                var startRange = parseInt(name.replace(regexpPatternURL, "$3"));
                var endRange = parseInt(name.replace(regexpPatternURL, "$4"));
                var unit = (endRange - startRange)/(aLen-1);
                var aStart, aEnd; //in array of vertices proportionally
                var chipVertices;
                var chipName;
                deb_var = data;
                for (var indx in data) {
                    if (startRange >= data[indx][1])
                        aStart = 0;
                    else
                        aStart = Math.ceil((data[indx][1]-startRange)/unit);
                    
                    if (endRange <= data[indx][2])
                        aEnd = aLen-1;
                    else
                        aEnd = Math.floor((data[indx][2]-startRange)/unit);
                    var tube_color = getColorForPercentage(data[indx][4]);
                    var material = new THREE.MeshLambertMaterial( { color: tube_color, shading: THREE.SmoothShading } );
                    chipVertices = [];
                    
                    for (var pointIndex = aStart; pointIndex <= aEnd; ++pointIndex) {
                        chipVertices.push(vertices[pointIndex])
                    }
                    deb_var=  chipVertices;
                    var spline = new THREE.SplineCurve3(chipVertices);
                    
                    var segments = chipVertices.length * 2;
                    var radiusSegments = 5;
                    var tube = new THREE.TubeGeometry( spline, segments, 10, radiusSegments, false, false);
                    tube.dynamic = true;
                    var tubeMesh = new THREE.Mesh(tube, material);  
                    // tubeMesh.userData = [blockIndicesStr, blockIndices];//?
                    
                    tubeMesh.name = data[indx][0] + "-" + String(data[indx][1]) + "-"  + String(data[indx][2]);
                    uploaded_splines_chip[tubeMesh.name] = [data[indx][0], data[indx][1], data[indx][2], data[indx][3], data[indx][4]];                                
                    scene.add(tubeMesh);
                    chipObjects.push(tubeMesh);
                }
            }

            function getColorForPercentage(chipLvl) {
                var pct = chipLvl/MAX_CHIP_LVL;
                for (var i = 1; i < percentColors.length - 1; i++) {
                    if (pct < percentColors[i].pct) {
                        break;
                    }
                }
                var lower = percentColors[i - 1];
                var upper = percentColors[i];
                var range = upper.pct - lower.pct;
                var rangePct = (pct - lower.pct) / range;
                var pctLower = 1 - rangePct;
                var pctUpper = rangePct;
                var color = {
                    r: Math.floor(lower.color.r * pctLower + upper.color.r * pctUpper)/255,
                    g: Math.floor(lower.color.g * pctLower + upper.color.g * pctUpper)/255,
                    b: Math.floor(lower.color.b * pctLower + upper.color.b * pctUpper)/255
                };
                return new THREE.Color().setRGB(color.r, color.g, color.b);
            }
            
            function init_new_window_SNP_CHIP_SEQ (intersectPoint, isPlaneMode) {
                if (isPlaneMode) {
                    var _rgn = intersectPoint;
                    var chrid = String(_rgn[0]);
                    // console.log(chrid);
                    var chridNoStrand = chrid.substr(0, chrid.length - 2);
                    var chridOnlyNumber = chridNoStrand;
                    if (chridOnlyNumber[chridOnlyNumber.length - 1] == "a") {
                        chridOnlyNumber = chridOnlyNumber.substr(0, chridOnlyNumber.length - 1);
                    }
                    snp_chip_seq_window = window.open("index2.html?isplane="+isPlaneMode+"&chr=" + chridOnlyNumber 
                              + "&start=" + String(_rgn[1])
                              + "&end=" + String(_rgn[2])      
                            /*+ "&celline="+ current_cell_line*/, //parameter of celline - will be hardcoded in the index2.html
                              "_blank", "dependent, scrollbars=yes, resizable=yes, top=500, left=500, width=400, height=400");
                    return;
                } else {
                    var intersectInModelCoordinates = Local2global(intersectPoint);
                    globalArrayForWindow = searchOctree();
                    var result = '';
                    for (var indx in globalArrayForWindow) {
                        result += globalArrayForWindow[indx].chr + "-" + globalArrayForWindow[indx].helix + ":";
                        for (var indx2 in globalArrayForWindow[indx].intervals) {
                            result += globalArrayForWindow[indx].intervals[indx2].start + "_" + globalArrayForWindow[indx].intervals[indx2].end + "-";
                        }
                        result += ";";
                    }
                    var radiusSphereGlobal = radiusSphere/scaleFactor;
                    snp_chip_seq_window = window.open("index2.html?isplane="+isPlaneMode+"&path=" + result
                        // "&xstart=" + String(intersectInModelCoordinates.x - radiusSphereGlobal) 
                        //       + "&xend=" + String(intersectInModelCoordinates.x + radiusSphereGlobal)
                        //       + "&zstart=" + String(intersectInModelCoordinates.z - radiusSphereGlobal)      
                        //       + "&zend=" + String(intersectInModelCoordinates.z + radiusSphereGlobal)  
                        //       + "&ystart=" + String(intersectInModelCoordinates.y - radiusSphereGlobal)      
                        //       + "&yend=" + String(intersectInModelCoordinates.y + radiusSphereGlobal)
                            /*+ "&celline="+ current_cell_line*/, //parameter of celline - will be hardcoded in the index2.html
                              "_blank", "dependent, scrollbars=yes, resizable=yes, top=500, left=500, width=400, height=400");
                    return;    
                }
                
            }


            
            var chrid2color = {};
            
			// the pointerLock object has different name in different browsers
			// http://www.html5rocks.com/en/tutorials/pointerlock/intro/
            var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;
            if ( havePointerLock ) {
            	init_controls();
            } else {
            	instructions.innerHTML = "Your browser doesn\'t seem to support Pointer Lock API<br/>Supported browsers: Firefox, Google Chrome.";
            }
            init();
            animate();
            
            function init_light() {
                    var light = new THREE.DirectionalLight( 0xffffff, 1.5 );
                    light.position.set( 1, 1, 1 );
                    scene.add( light );
                    var light = new THREE.DirectionalLight( 0xffffff, 0.75 );
                    light.position.set( -1, - 0.5, -1 );
                    scene.add( light );
            }
            
            function draw_low_resolution_model() {
                    // loading 3d-model
					// data - is an array of arrays, each array is a sequence of points of a DNA molecule
					// each point is represented with 4 numbers: base_index, x,y,z
					var color = new THREE.Color().setHSL( Math.random(),  Math.random(),  Math.random());
					for (var chr_index = 0; chr_index < data.length; ++chr_index) {
						chr_data = data[chr_index];
						var CELL_SIZE = 4;
						points_count = chr_data.length / CELL_SIZE; 
						
						var tube_color = new THREE.Color().setHSL( Math.random(),  Math.random(),  Math.random());
						var material = new THREE.MeshBasicMaterial({
								color: tube_color,
								opacity: 1,
								wireframe: true,
								transparent: false
						});
						var spline_points = [];
						for (var point_index = 0; point_index < points_count; ++point_index) {
							x = chr_data[(point_index) * CELL_SIZE];
							y = chr_data[(point_index) * CELL_SIZE + 1];
							z = chr_data[(point_index) * CELL_SIZE + 2];	
							spline_points.push(new THREE.Vector3(x, y, z));									

						}
						var spline = new THREE.SplineCurve3(spline_points);
						var segments = points_count * 2;
						var radiusSegments =  4;
						var tube = new THREE.TubeGeometry(spline, segments, 1, radiusSegments, false, false);
						tube.dynamic = true;
						tubeMesh = new THREE.Mesh(tube, material);							
						scene.add(tubeMesh);
						objects.push(tubeMesh);
                    }            	
            }
            
            function InitSelectionMesh() {
				var spline = new THREE.SplineCurve3([new THREE.Vector3(0, 0, 0), new THREE.Vector3(100, 100, 100),]);
				var material = new THREE.LineBasicMaterial({color: 0xff0000});
				var segments = 10;
				var radiusSegments = 6;
				var tube = new THREE.TubeGeometry(spline, segments, 20, radiusSegments, false, false);
				tube.dynamic = true;
				tube.verticesNeedUpdate = true;
				selectionMesh = new THREE.Mesh(tube, material);
				selectionMesh.name = "selection_mesh";
                test_mesh = selectionMesh;
				scene.add(selectionMesh);          	
            }
            
            function UpdateTargetBallPosition() {
				var vector = new THREE.Vector3(0, 0, 0);
				var raycaster = projector.pickingRay(vector, camera);
				raycaster.ray.direction.normalize().multiplyScalar(50);
				var x = raycaster.ray.direction.x + raycaster.ray.origin.x;
				var y = raycaster.ray.direction.y + raycaster.ray.origin.y;
				var z = raycaster.ray.direction.z + raycaster.ray.origin.z;
				targetBall.position.set(x,  y, z);
				targetBall.geometry.verticesNeedUpdate = true;
				scene.remove(targetBall);   	
				scene.add(targetBall); 
            }
            
            function InitTargetBall() {
            	var sphere = new THREE.SphereGeometry(0.5, 10, 10);
            	sphere.dynamic = true;
            	targetBall = new THREE.Mesh(sphere, new THREE.LineBasicMaterial({color: 0xff0000}));
				targetBall.name = "target_ball";            	
				UpdateTargetBallPosition();						          	
            }

            function getPositionRangeFromCubeIntersection(meshesSearch) {
                var resultSet = [];
                var verts;
                var POSSIBLE_HOLE_IN_VERTICES = 5;
                var mentionedMeshes = [];
                var name, vertices, aLen, startRange, endRange, unit;
                var aStart, aEnd, counter, chr, helix;
                var tempObject;
                for (var _mesh in meshesSearch) {
                    name = meshesSearch[_mesh].object.name;

                    if (mentionedMeshes != null && ($.inArray(name, mentionedMeshes) != -1)) {
                        continue;
                    }
                    mentionedMeshes.push(name);
                    tempObject = [];

                    //proportional calculations
                    verts = meshesSearch[_mesh].object.geometry.vertices;
                    aLen = verts.length;
                    chr = (name.replace(regexpPatternURL, "$1"));
                    helix = (name.replace(regexpPatternURL, "$2"));
                    startRange = parseInt(name.replace(regexpPatternURL, "$3"));
                    endRange = parseInt(name.replace(regexpPatternURL, "$4"));
                    unit = (endRange - startRange)/(aLen-1);

                    aStart = -1;
                    aEnd = -1;
                    counter == 0;
                    for (var _v in verts) {
                        if (intersection.point.x - radiusSphere <= verts[_v].x &&
                            intersection.point.x + radiusSphere >= verts[_v].x &&
                            intersection.point.y - radiusSphere <= verts[_v].y &&
                            intersection.point.y + radiusSphere >= verts[_v].y &&
                            intersection.point.z - radiusSphere <= verts[_v].z &&
                            intersection.point.z + radiusSphere >= verts[_v].z) {

                            if (aStart == -1) {
                                aStart = _v;
                                aEnd = _v;
                                counter = 0;
                            } else {
                                aEnd = _v;
                                counter = 0;
                            }
                        } else {
                            if (aEnd != -1) {
                                counter++;

                                //define the beginning of the line
                                if (counter == POSSIBLE_HOLE_IN_VERTICES) {
                                    if (aStart == 0) {
                                        aStart = startRange; //reassign variable from index to value (position)
                                    } else {
                                        aStart = Math.ceil(startRange + unit * (aStart - 1)); //!! Artificially increase of observed area
                                    }

                                    if (aEnd == verts.length - 1) {
                                        aEnd = endRange; //reassign variable from index to value (position)
                                    } else {
                                        // console.log(aEnd);
                                        // console.log( startRange +"+"+unit +" * ("+aEnd + " + 1)");
                                        var aEndClone = aEnd - 1+1; //weird hint to change from the string
                                        aEnd = Math.floor(startRange + unit * (aEndClone + 1));
                                        // console.log(aEnd);
                                    }

                                    tempObject.push({start: aStart, end: aEnd});
                                    aStart = -1;
                                    aEnd = -1;
                                }
                            }
                        }
                    }
                    if (tempObject.length != 0)
                        resultSet.push({chr: chr, intervals: tempObject, size: tempObject.length, helix: helix}); 
                }
                return resultSet;
            }

            function searchOctree() {
                intersectionImpl = GetIntersection().point;
                var rayCaster = new THREE.Raycaster( new THREE.Vector3().copy( intersectionImpl ), new THREE.Vector3(0,0,radiusSphere).normalize() );
                // var radiusSearch = radiusSphere;
                var meshesSearch = octree.search( rayCaster.ray.origin, radiusSphere, true, rayCaster.ray.direction ); 
                // intersections = rayCaster.intersectOctreeObjects( meshesSearch, true);

                return getPositionRangeFromCubeIntersection(meshesSearch);
            }
			
            function init() {
            		scene = new THREE.Scene();
					camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 100000 );
                    controls = new THREE.PointerLockControls( camera );
                    scene.add( controls.getObject() );

					//scene.fog = new THREE.Fog( 0xffffff, 0, blockSize * scaleFactor );
					init_light(scene);    
                    //draw_low_resolution_model();
                  
                    renderer = new THREE.WebGLRenderer();
                    renderer.setClearColor( 0xffffff );
                    renderer.setSize( window.innerWidth, window.innerHeight );
                    
                    InitSelectionMesh();
                    InitTargetBall();

                    // create octree
                    octree = new THREE.Octree( {
                      undeferred: false,
                      depthMax: Infinity,
                      objectsThreshold: 8,
                      overlapPct: 0.15
                       // ,
                       // scene: scene
                    } );

                    divElement = document.getElementById("tabs-1");
                    

                    divElement.appendChild( renderer.domElement );

                    // document.body.appendChild( renderer.domElement );
                    window.addEventListener( 'resize', onWindowResize, false );   
                    
            }

            function onWindowResize() {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize( window.innerWidth, window.innerHeight );
                    
            }
            
            function Local2global(coordinates) {
            	return {x :  zeroCoordinate.x + coordinates.x / scaleFactor, 
            		    y : zeroCoordinate.y + coordinates.y / scaleFactor, 
            		    z : zeroCoordinate.z + coordinates.z / scaleFactor };
            }
            function Global2local(coordinates) {
            	return {x :  (coordinates.x - zeroCoordinate.x) * scaleFactor, 
            		    y :  (coordinates.y - zeroCoordinate.y) * scaleFactor, 
            		    z :  (coordinates.z - zeroCoordinate.z) * scaleFactor };
            }       
            
            function GenerateColor() {
            	mix = [0.8, 0.8, 0.8];
			    var red = Math.random();
			    var green = Math.random();
			    var blue = Math.random();
			    // mix the color
			    red = (red + mix[0]) / 2;
			    green = (green + mix[1]) / 2;
			    blue = (blue + mix[2]) / 2;
			    return new THREE.Color().setRGB(red, green, blue);
            }
            
            function DrawSNPs(positions, track_points) {
            	var track_points_position = 0;
            	for (var point_index = 0; point_index < positions.length; ++point_index) {
            		var base_index = positions[point_index][0];
            		var snp_id = String(positions[point_index][1]);
            		while (track_points_position < track_points.length && track_points[track_points_position][1] <=  base_index) {
            			++track_points_position;
            		}
            		if (track_points_position > 0 && track_points_position < track_points.length) {
            			var prev_base_index = track_points[track_points_position - 1][1];
            			var curr_base_index = track_points[track_points_position][1];
            			var coefficient = (base_index - prev_base_index) / (curr_base_index - prev_base_index);
            			var x = (1 - coefficient) * track_points[track_points_position - 1][2] + coefficient * track_points[track_points_position][2];
            			var y = (1 - coefficient) * track_points[track_points_position - 1][3] + coefficient * track_points[track_points_position][3];
            			var z = (1 - coefficient) * track_points[track_points_position - 1][4] + coefficient * track_points[track_points_position][4];
            			var localCoords = Global2local({ x: x, y : y, z : z });
		            	var sphere = new THREE.SphereGeometry(12, 10, 10);
		            	var snp_ball = new THREE.Mesh(sphere, new THREE.LineBasicMaterial({color: 0xff0000}));
						snp_ball.name = "rs" + snp_id;            	
						snp_ball.position.set(localCoords.x,  localCoords.y, localCoords.z);
						scene.add(snp_ball); 
            		}
            	}
            }
            
            function UploadRegionSNP(chr, track_points) {
        		var request = "chr=" + chr + "&start=" + String(track_points[0][1]) +
        						 "&end=" + String(track_points[track_points.length - 1][1]); 
			    var url = "http://1kgenome.exascale.info/js_snp?" + request;
			    $.getJSON(url + "?callback=?", null, 
			    	function(positions) {
			    		DrawSNPs(positions, track_points);
			    	}
			    ); 	
            }
            
            function UploadSNP(new_model_points) {
            	var new_tracks = new_model_points["data"];
            	var longest = -1;
            	var length = 0;
            	for (var track_index = 0; track_index < new_tracks.length; ++track_index) {
            		var track_points = new_tracks[track_index][1];
            		if (track_points.length > length) {
            			longest = track_index;
            			length = track_points.length;
            		}
            	}
            	for (var track_index = longest; track_index < longest + 1; ++track_index) {
            		var chrid = new_tracks[track_index][0];
            		var chridNoStrand = chrid.substr(0, chrid.length - 2);
            		var chridOnlyNumber = chridNoStrand;
            		if (chridOnlyNumber[chridOnlyNumber.length - 1] == "a") {
            			chridOnlyNumber = chridOnlyNumber.substr(0, chridOnlyNumber.length - 1);
            		}
            		var track_points = new_tracks[track_index][1];
            		UploadRegionSNP(chridOnlyNumber, track_points);
				}
            }
                        
            
            function DrawPoints(model_points, blockIndicesStr, blockIndices) {
            	new_tracks = model_points["data"];
            	
            	for (var track_index = 0; track_index < new_tracks.length; ++track_index) {
            		chrid = new_tracks[track_index][0];
            		chridNoStrand = chrid.substr(0, chrid.length - 2);
            		if (!chrid2color[chridNoStrand]) {
            			//chrid2color[chridNoStrand] = new THREE.Color().setHSL( Math.random(),  Math.random(),  Math.random());
            			chrid2color[chridNoStrand] = GenerateColor();
            		}
            		track_points = new_tracks[track_index][1];
					var tube_color = chrid2color[chridNoStrand];
					var material = new THREE.MeshLambertMaterial( { color: tube_color, shading: THREE.SmoothShading } );
					/*
					var material = new THREE.MeshBasicMaterial({
							color: tube_color,
							opacity: 1,
							wireframe: false,
							transparent: false
					  });
					*/								
					var spline_points = [];
					var points_count = track_points.length;
					for (var point_index = 0; point_index < points_count; ++point_index) {
						var chunk = track_points[point_index];
						var localCorodinates = Global2local( {x: chunk[2], y: chunk[3], z : chunk[4] });						
						spline_points.push(new THREE.Vector3(localCorodinates.x, localCorodinates.y, localCorodinates.z));
					}
					var spline = new THREE.SplineCurve3(spline_points);
					var segments = points_count * 2;
					var radiusSegments = 6;
					var tube = new THREE.TubeGeometry(spline, segments, 10, radiusSegments, false, false);
					tube.dynamic = true;
					var tubeMesh = new THREE.Mesh(tube, material);	
                    tubeMesh.userData = [blockIndicesStr, blockIndices];
					
					tubeMesh.name = chrid + "-" + String(track_points[0][1]) + "-"  + String(track_points[track_points.length - 1][1]);
					uploaded_splines[tubeMesh.name] = [chrid, track_points];								
					octree.add(tubeMesh, {useFaces: false, useVertices: true});
                    scene.add(tubeMesh);
					objects.push(tubeMesh);
                    console.log('Hi')
				}
            }
            
            function DrawBox(cornerModelCoordinates, edgeSize) {
		       var vertices = [];
		       for (var pointIndex = 0; pointIndex < 8; ++pointIndex) {
		           var xCoord = cornerModelCoordinates.x + edgeSize * (pointIndex % 2);
		           var yCoord = cornerModelCoordinates.y + edgeSize * ((pointIndex >> 1) % 2);
		           var zCoord = cornerModelCoordinates.z + edgeSize * ((pointIndex >> 2) % 2);
		           vertexLocalCoordinates = Global2local({x: xCoord, y: yCoord, z: zCoord });
		           vertices[pointIndex] = new THREE.Vector3(vertexLocalCoordinates.x, vertexLocalCoordinates.y, vertexLocalCoordinates.z);
		       }
		       for (var firstIndex = 0; firstIndex < vertices.length; ++firstIndex) {
		           for (var secondIndex = firstIndex + 1; secondIndex < vertices.length; ++secondIndex) {
		               var matchedCoordinates = ((firstIndex % 2) == (secondIndex % 2)) ? 1 : 0;
		               matchedCoordinates += ((firstIndex >> 1) % 2 == (secondIndex >> 1) % 2) ? 1 : 0;
		               matchedCoordinates += ((firstIndex >> 2) % 2 == (secondIndex >> 2) % 2) ? 1 : 0;
		               if (matchedCoordinates == 2) {
						   var material = new THREE.LineBasicMaterial({color: 0x0000af});
						   var geometry = new THREE.Geometry();
						   geometry.vertices.push(vertices[firstIndex]);
						   geometry.vertices.push(vertices[secondIndex]);	               	
						   var line = new THREE.Line(geometry, material);
						   scene.add(line);
		               }
		           }           
		       }      
            }

            function UploadPoints(blockCornerCoordinates, blockIndicesStr, blockIndices) {
            	overlap = blockSize * 0.2;
            	var request = "xstart=" + String(blockCornerCoordinates.x - overlap) 
            				  + "&xend=" + String(blockCornerCoordinates.x + blockSize + overlap)
            				  + "&zstart=" + String(blockCornerCoordinates.z - overlap)      
            				  + "&zend=" + String(blockCornerCoordinates.z + blockSize + overlap)  
            				  + "&ystart=" + String(blockCornerCoordinates.y - overlap)      
            				  + "&yend=" + String(blockCornerCoordinates.y + blockSize + overlap);  	
			    var url = "http://1kgenome.exascale.info/js_test?" + request;
			    $.getJSON(url + "?callback=?", null, 
			    	function(model_points) {
			    		DrawPoints(model_points, blockIndicesStr, blockIndices);
			    		//UploadSNP(model_points);
			    	}
			    );
            }
            
            function GetBlockIndices(modelPosition) {
            	blockOffset = blockSize / 2;
		        var blockIndexX = Math.floor((modelPosition.x + blockOffset) / blockSize);
		        var blockIndexY = Math.floor((modelPosition.y + blockOffset) / blockSize);
		        var blockIndexZ = Math.floor((modelPosition.z + blockOffset) / blockSize);   
		        //System.out.println(String.format("%f %f %f -> %d %d %d", x, y, z, blockIndexX, blockIndexY, blockIndexZ));
		        return {x : blockIndexX, y : blockIndexY, z : blockIndexZ };
            }
            
            function GetBlockCornerCoordinates(blockIndices) {
            	blockOffset = blockSize / 2;
            	var xCoord = blockIndices.x * blockSize - blockOffset;
            	var yCoord = blockIndices.y * blockSize - blockOffset;
            	var zCoord = blockIndices.z * blockSize - blockOffset;
            	return {x : xCoord, y: yCoord, z: zCoord};
            }
            
            function Coords2Str(coordinates) {
                return String(coordinates.x) + ":" + String(coordinates.y) + ":" + String(coordinates.z);
            }

            function Str2Coords(coorLine) {
                var arr = coorLine.split(':');
                return {x : parseInt(arr[0]), y : parseInt(arr[1]), z : parseInt(arr[2]) };
            }
            
            function UpdateModel() {
            	var modelPosition = Local2global(controls.getObject().position);
            	var blockIndices = GetBlockIndices(modelPosition);
            	var blockIndicesStr = Coords2Str(blockIndices);
            	if (blockIndicesStr in uploaded_area) {
                    // if (uploaded_area[blockIndicesStr]) // if it is SOMEHOW is still true
                        // return;
            		// recreate textures in the particular cube (Tube Mesh to Line)
                    // RecreateTexturesInCube(blockIndicesStr);
            	} else {
                    uploaded_area[blockIndicesStr] = true;
                    var blockCornerCoordinates = GetBlockCornerCoordinates(blockIndices);
                    DrawBox(blockCornerCoordinates, blockSize);
                    UploadPoints(blockCornerCoordinates, blockIndicesStr, blockIndices);

                }
                
                //delete textures in the others cube only if 
                if (lastBlockIndicesStr != blockIndicesStr) {
                    DeleteTexturesFromCubes2(blockIndicesStr, blockIndices);
                    lastBlockIndicesStr = blockIndicesStr;
                }   
            }

            //Delete Mesh out of the alowed space region
            function DeleteTexturesFromCubes2(blockIndicesStr, blockIndices) {
                var objectsIndcesToDelete = [];
                var tempUserData, tempUserDataCoord;
                var distanceToDelete = 1;
                //for (var _obj in objects) {
                for (var _obj = 0; _obj < objects.length; ++_obj) {
                        tempUserData = objects[_obj].userData[0];
                        tempUserDataCoord = objects[_obj].userData[1];

                        if (tempUserData != blockIndicesStr && !(blockIndices.x - tempUserDataCoord.x <= distanceToDelete && blockIndices.x - tempUserDataCoord.x >= (-1*distanceToDelete) && blockIndices.y - tempUserDataCoord.y <= distanceToDelete && blockIndices.y - tempUserDataCoord.y >= (-1*distanceToDelete) && blockIndices.z - tempUserDataCoord.z <= distanceToDelete && blockIndices.z - tempUserDataCoord.z >= (-1*distanceToDelete))) {
                            
                            if (tempUserData in uploaded_area) delete uploaded_area[tempUserData];
                            scene.remove(objects[_obj]);

                            delete uploaded_splines[objects[_obj].name];
                            octree.remove(objects[_obj]);
                            
                            objectsIndcesToDelete.push(_obj);
                        }
                }
                if (objects.length>0 && objectsIndcesToDelete.length>0) {
                    objects = $.grep(objects, function(v,i){return $.inArray(i,objectsIndcesToDelete)==-1});
                }   
            }

            function GetIntersectionCHIPSEQ() {
                var vector = new THREE.Vector3(0, 0, 0);
                var raycaster = projector.pickingRay(vector, camera);
                var closestObjectDistance;
                var intersects = raycaster.intersectObjects(chipObjects);
                if (intersects.length == 0) {
                    return null;
                }
                closestObjectDistance = intersects[0].distance;
                intersects = $.grep(intersects, function(v){return v.distance <= closestObjectDistance + 5});
                return intersects;
            }

            function GetIntersection() {
            	var vector = new THREE.Vector3(0, 0, 0);
            	var raycaster = projector.pickingRay(vector, camera);
            	
                // var intersects = raycaster.intersectObjects(objects);
                var intersects = raycaster.intersectObjects(objects);
				if (intersects.length == 0) {
					return null;
				}
				return intersects[0];
            }
            
            function GetSelectedTrackPoints(intersectPoint, trackName) {
            	var intersectInModelCoordinates = Local2global(intersectPoint);
                // trackPoints from 3dQuery
            	var trackPoints = uploaded_splines[trackName][1];
            	var chrid = trackName.split("-")[0];
            	var closestPoint = -1;
            	var minDistance = -1;
            	for (var pointIndex = 0; pointIndex < trackPoints.length; ++pointIndex) {
            		var x = trackPoints[pointIndex][2];
            		var y = trackPoints[pointIndex][3];
            		var z = trackPoints[pointIndex][4];
            		var distance = Math.pow(intersectInModelCoordinates.x - x, 2) + 
            						Math.pow(intersectInModelCoordinates.y - y, 2) +
            						Math.pow(intersectInModelCoordinates.z - z, 2);
            		if (minDistance == -1 || distance < minDistance) {
            			minDistance = distance;
            			closestPoint = pointIndex;
            		}
            	}
			    
			    var start = closestPoint;
			    while (start > 0 && Math.abs(trackPoints[start][1] - trackPoints[closestPoint][1]) < basesInSelection / 2) {
			    	--start;
			    }
			    var end = closestPoint;
			    while (end < trackPoints.length - 1 && Math.abs(trackPoints[end][1] - trackPoints[closestPoint][1]) < basesInSelection / 2) {
			    	++end;
			    }
			    
			   	function Interpolate(point, otherPoint, bpIndexNeed) {
			   		var bpIndex = trackPoints[point][1];
			   		var bpIndexOther = trackPoints[otherPoint][1];
			   		var coeff = (bpIndexNeed - bpIndex) / (bpIndexOther - bpIndex);
			   		var xCoord = trackPoints[point][2] + (trackPoints[otherPoint][2] - trackPoints[point][2]) * coeff;
			   		var yCoord = trackPoints[point][3] + (trackPoints[otherPoint][3] - trackPoints[point][3]) * coeff;
			   		var zCoord = trackPoints[point][4] + (trackPoints[otherPoint][4] - trackPoints[point][4]) * coeff;
			   		return {x: xCoord, y: yCoord, z: zCoord};
			   	}
			   	
		   		var otherPoint = start < trackPoints.length - 1 ? start + 1 : start;
		   		var exactStartPosition = Interpolate(start, otherPoint, trackPoints[closestPoint][1] - basesInSelection / 2);
		   		otherPoint = end > 0 ? end - 1 : end;
		   		var exactEndPosition = Interpolate(end, otherPoint, trackPoints[closestPoint][1] + basesInSelection / 2);
				
				var selectionTrackPoints = [Global2local(exactStartPosition)];
				for (var pointIndex = start + 1; pointIndex < end; ++pointIndex) {
					selectionTrackPoints.push(Global2local({x: trackPoints[pointIndex][2], y: trackPoints[pointIndex][3], z: trackPoints[pointIndex][4]}));
				}
				selectionTrackPoints.push(Global2local(exactEndPosition));
                //draw selection old - plane
                // if (is_plane_mode)
                if (mode_id == 0)
                {
                    var spline = new THREE.SplineCurve3(selectionTrackPoints);
                    var segments = basesInSelection / 50;
                    var radiusSegments = 6;
                    var tube = new THREE.TubeGeometry(spline, segments, 20, radiusSegments, false, false);
                    tube.dynamic = true;
                    scene.remove(selectionMesh);

                    delete selectionMesh;
                    {
                        var material = new THREE.MeshBasicMaterial({
                                color: 0xff0000,
                                opacity: 1,
                                wireframe: true,
                                transparent: false
                        });                     
                        
                        selectionMesh = new THREE.Mesh(tube, material);
                        selectionMesh.geometry.verticesNeedUpdate = true;
                        scene.add(selectionMesh);
                    }
                    
                } else if (mode_id == 1)
				//draw selection new - cube
                {
                    var cube = new THREE.CubeGeometry(radiusSphere*2,radiusSphere*2,radiusSphere*2, 5, 5, 5);
                    cube.dynamic = true;
                    scene.remove(selectionMesh);
                    {
                        var material = new THREE.MeshBasicMaterial({
                                color: 0xff0000,
                                opacity: 1,
                                wireframe: true,
                                transparent: false
                        });                     
                        
                        selectionMesh = new THREE.Mesh(cube, material);
                        selectionMesh.position = new THREE.Vector3(intersectPoint.x, intersectPoint.y, intersectPoint.z);
                        // selectionMesh.geometry.verticesNeedUpdate = true;
                        scene.add(selectionMesh);
                    }
                    
                }
				return [chrid, trackPoints[closestPoint][1] - basesInSelection / 2, 
							trackPoints[closestPoint][1] + basesInSelection / 2]; 	
            }
            
            function ClearInfo() {
            	if (infoBlock) {
            		infoBlock.innerHTML = "";
                    lastRegion = [];
                    rgn = [];
            	}

            }
            
            
            function PositionToString(region) {
            	var helix = region[0].split("_")[1] == "a" ? "helix A" : "helix B";
            	var info = "Selection: chromosome: " + region[0].split("_")[0] + ", " + helix;
            	info += ", bases: " + String(region[1]) + "&ndash;" + String(region[2]);
            	return info;            	
            }

			function Popup(data) {
				var popup = window.open("","MsgWindow","width=200,height=100");
				popup.document.write("<p>" + data + "</p>");								
			}

			function UploadRegionData(region) {
            	var request = "start=" + String(region[1]) 
            				  + "&end=" + String(region[2])
            				  + "&chrid=" + String(region[0]);
			    var url = "http://1kgenome.exascale.info/range?" + request;		
			    $.getJSON(url + "?callback=?", null, 
			    	function(regionInfo) {
			    		var key = PositionToString(region);
			    		var chrid = region[0];
			    		chrid = chrid.replace("_b", "_a");
			    		var key_a = PositionToString([chrid, region[1], region[2]]);
			    		chrid = chrid.replace("_a", "_b");
			    		var key_b = PositionToString([chrid, region[1], region[2]]);
			    		formated_data = "<br/>@Bases: <a target='_blank' style=\"color: rgb(0,255,0)\" href='http://1kgenome.exascale.info/range?" + request + "'>" + regionInfo.substring(0, 50) + "...</a>";
			    		regionData[key_a][1] = formated_data;
			    		regionData[key_b][1] = formated_data;
			    		infoBlock.innerHTML = regionData[key];
			    		/*
			    		if (infoBlock.innerHTML == key) {
			    			infoBlock.innerHTML = regionData[key];
			    		} else {
			    			console.log("da fuck: " + infoBlock.innerHTML);
			    		}
			    		*/
			    	}
			    ); 	
			    
			    {//SNPs
			    	var chrid = String(region[0]);
                    // console.log(chrid);
            		var chridNoStrand = chrid.substr(0, chrid.length - 2);
            		var chridOnlyNumber = chridNoStrand;
            		if (chridOnlyNumber[chridOnlyNumber.length - 1] == "a") {
            			chridOnlyNumber = chridOnlyNumber.substr(0, chridOnlyNumber.length - 1);
            		}
			    	
	        		var request = "chr=" + chridOnlyNumber + "&start=" + String(region[1]) +
	        						 "&end=" + String(region[2]); 
				    var url = "http://1kgenome.exascale.info/js_snp?" + request;
				    $.getJSON(url + "?callback=?", null, 
				    	function(positions) {
				    		snips = "";
			            	for (var point_index = 0; point_index < positions.length; ++point_index) {
			            		var base_index = positions[point_index][0];
			            		var snp_id = /*"rs" + */String(positions[point_index][1]);
			            		snips += " <a target=\"_blank\" style=\"color: rgb(255,255,0)\" href=\"http://www.ncbi.nlm.nih.gov/SNP/snp_ref.cgi?rs="+snp_id+"\">rs"+snp_id+"</a>;";
			            	}

			            	formated_data = "<br/>@SNPs:" + snips;
			            	var key = PositionToString(region);
				    		var chrid = region[0];
				    		chrid = chrid.replace("_b", "_a");
				    		var key_a = PositionToString([chrid, region[1], region[2]]);
				    		chrid = chrid.replace("_a", "_b");
				    		var key_b = PositionToString([chrid, region[1], region[2]]);
				    		regionData[key_a][2] = formated_data;
				    		regionData[key_b][2] = formated_data;
				    		infoBlock.innerHTML = regionData[key];
				    	}
				    );
			    }		    

			}

            /*@deprecated*/
            function buildCubeDataStructure(model_points) {
                 var new_cube_tracks = model_points["data"];
                    if (new_cube_tracks.length == 0) {
                        console.log("NULL");
                        resp_count++;
                        return;
                    }
                 for (var track_index = 0; track_index < new_cube_tracks.length; ++track_index) {
                    chrid = new_cube_tracks[track_index][0];
                    chridNoStrand = chrid.substr(0, chrid.length - 2);
                    var chridOnlyNumber = chridNoStrand;
                    if (chridOnlyNumber[chridOnlyNumber.length - 1] == "a") {
                        chridOnlyNumber = chridOnlyNumber.substr(0, chridOnlyNumber.length - 1);
                    }

                    track_points = new_cube_tracks[track_index][1];
                    var request = "chr=" + chridOnlyNumber + "&start=" + String(track_points[0][1]) +
                                     "&end=" + String(track_points[track_points.length - 1][1]); 
                    var url = "http://1kgenome.exascale.info/js_snp?" + request;
                    req_count++;
                    $.getJSON(url + "?callback=?", null, 
                        function(positions) {
                            snips = "";
                            for (var point_index = 0; point_index < positions.length; ++point_index) {
                                var base_index = positions[point_index][0];
                                var snp_id = /*"rs" + */String(positions[point_index][1]);
                                snips += " <a target=\"_blank\" style=\"color: rgb(0,0,255)\" href=\"http://www.ncbi.nlm.nih.gov/SNP/snp_ref.cgi?rs="+snp_id+"\">rs"+snp_id+"</a>;";
                            }
                            // infoBlock.innerHTML += snips;
                            if (tableStrContent.length == 0) tableStrContent += snips;
                            else tableStrContent += "<br>" + snips;

                            console.log("Alexander");
                            resp_count++;
                        }
                    );
                }
                req_count--;
            }

            function buildCubeDataStructureSNPs(resultSet) {
                    if (resultSet == null || resultSet.length == 0) {
                        console.log("EMPTY area - you should not see this");
                        return;
                    }
                 for (var track_index in resultSet) {
                    var chridOnlyNumber = resultSet[track_index].chr;
                    for (var intervals_indx in resultSet[track_index].intervals) {
                        var request = "chr=" + chridOnlyNumber + "&start=" + String(resultSet[track_index].intervals[intervals_indx].start) +
                                     "&end=" + String(resultSet[track_index].intervals[intervals_indx].end); 
                        var url = "http://1kgenome.exascale.info/js_snp?" + request;
                        req_count++;
                        $.getJSON(url + "?callback=?", null, 
                            function(positions) {
                                snips = "";
                                for (var point_index = 0; point_index < positions.length; ++point_index) {
                                    var base_index = positions[point_index][0];
                                    var snp_id = /*"rs" + */String(positions[point_index][1]);
                                    snips += " <a target=\"_blank\" style=\"color: rgb(0,0,255)\" href=\"http://www.ncbi.nlm.nih.gov/SNP/snp_ref.cgi?rs="+snp_id+"\">rs"+snp_id+"</a>;";
                                }
                                if (tableStrContent.length == 0) tableStrContent += snips;
                                else tableStrContent += "<br>" + snips;

                                console.log("Alexander");
                                resp_count++;
                            }
                        );
                    }
                }
            }

            function GetSelectedTrackPointsVollume3Dquery(intersectPoint) {
                var intersectInModelCoordinates = Local2global(intersectPoint);
                
                var radiusSphereGlobal = 2 * radiusSphere/scaleFactor;

                tableStrContent = '';
                console.log("Clean tableStrContent");
                req_count =1;
                resp_count = 0;
                var request = "xstart=" + String(intersectInModelCoordinates.x - radiusSphereGlobal) 
                              + "&xend=" + String(intersectInModelCoordinates.x + radiusSphereGlobal)
                              + "&zstart=" + String(intersectInModelCoordinates.z - radiusSphereGlobal)      
                              + "&zend=" + String(intersectInModelCoordinates.z + radiusSphereGlobal)  
                              + "&ystart=" + String(intersectInModelCoordinates.y - radiusSphereGlobal)      
                              + "&yend=" + String(intersectInModelCoordinates.y + radiusSphereGlobal);      
                var url = "http://1kgenome.exascale.info/js_test?" + request;
                $.getJSON(url + "?callback=?", null, 
                    function(model_points) {
                        buildCubeDataStructure(model_points);
                    }
                );

                
            }
            
            function UpdateInfoChipSeq() {
                intersection = GetIntersectionCHIPSEQ();
                if (intersection == null) {
                    ClearInfo();
                    return;
                }
                
                var temp;
                if (typeof lastIntersection  != 'undefined' && intersection[0].point.x == lastIntersection.x && intersection[0].point.y == lastIntersection.y && intersection[0].point.z == lastIntersection.z) {
                    return;
                } else {
                    ClearInfo();
                    for (var inter_indx in intersection) {
                        temp = uploaded_splines_chip[intersection[inter_indx].object.name];
                        // infoBlock.innerHTML += intersection[inter_indx].object.name + "; ";
                        infoBlock.innerHTML += "<a target='_blank' style='color: rgb(255,255,0)' href='http://genome.ucsc.edu/cgi-bin/hgTracks?db=hg19&position=chr"+temp[0]+"%3A"+temp[1]+"-"+temp[2]+"' >"+temp[0]+"-"+temp[1] + ":"+temp[2] + " -> " + temp[3] + "("+temp[4]+")</a>; ";
                    }
                    lastIntersection = intersection[0].point;
                }
            }

            function UpdateInfo() {
                if (mode_id == 2) {
                    UpdateInfoChipSeq();
                    return;
                }

                intersection = GetIntersection();
                if (intersection == null) {
                    ClearInfo();
                    return;
                }

                if (mode_id == 1) {

                    ClearInfo();
                    //draw selection new - cube
                    {
                        var cube = new THREE.CubeGeometry(radiusSphere*2,radiusSphere*2,radiusSphere*2, 5, 5, 5);
                        cube.dynamic = true;
                        scene.remove(selectionMesh);
                        {
                            var material = new THREE.MeshBasicMaterial({
                                    color: 0xff0000,
                                    opacity: 1,
                                    wireframe: true,
                                    transparent: false
                            });
                            selectionMesh = new THREE.Mesh(cube, material);
                            selectionMesh.position = new THREE.Vector3(intersection.point.x, intersection.point.y, intersection.point.z);
                            scene.add(selectionMesh);
                        }
                    }
                    // if (typeof lastIntersection  == 'undefined' || intersection.point.x != lastIntersection.x || intersection.point.y != lastIntersection.y || intersection.point.z != lastIntersection.z) {
                    //     GetSelectedTrackPointsVollume3Dquery(intersection.point);
                    //     lastIntersection = intersection.point;
                    // }
                    return;
                }

            	object = intersection.object;
            	point = intersection.point;
            	if (object.name == "") {
                    ClearInfo();
            		return;
            	}

                if ((typeof uploaded_splines[object.name] === 'undefined')) {
                    console.log("Warning: undefined!!!"); 
                    ClearInfo();
                    return;
                }


            	var region = GetSelectedTrackPoints(point, object.name);
                rgn = region;
            	var positionStr = PositionToString(region);
            	if (positionStr in regionData && (lastRegion==null || lastRegion[0] != regionData[positionStr][0] && lastRegion[1] != regionData[positionStr][1] && lastRegion[2] != regionData[positionStr][2])) {
            		infoBlock.innerHTML = regionData[positionStr];
                    lastRegion = regionData[positionStr];
            	} else if (!(positionStr in regionData)) {
            		//show something immidiately
            		infoBlock.innerHTML = positionStr + "<br/>data uploading...";
            		//also works like flag: request is already sent
            		regionData[PositionToString([region[0].replace("_b", "_a"), region[1], region[2]])] = [positionStr, "", ""];
            		regionData[PositionToString([region[0].replace("_a", "_b"), region[1], region[2]])] = [positionStr, "", ""];
            		UploadRegionData(region);            		
            	}
            }

            function animate() {
                    requestAnimationFrame( animate );
                    UpdateTargetBallPosition();
                    UpdateInfo();
                   	UpdateModel();
                        
                    // updateGUI();    
                    controls.update( Date.now() - time );
                    renderer.render( scene, camera );
                    octree.update();
                    time = Date.now();
            }

        </script>
        
        <script>
        	infoBlock = document.createElement('div');
			infoBlock.id = "infoblock";
			// document.body.appendChild(infoBlock); 
            divElement.appendChild(infoBlock);
            mod_message_div = document.createElement('p');
            mod_message_div.id = "textmode";
            mod_message_div.style = "display:none";
            mod_message_div.appendChild(document.createTextNode(""));
            divElement.appendChild(mod_message_div);

			
			/*staticBlock = document.createElement('div');
			staticBlock.id = "staticblock";
			staticBlock.innerHTML = "<em>3DBD Genome browser</em>, contact: <a target='_blank' href='http://exascale.info/'>eXascale Infolab</a>, {phil, ruslan}@exascale.info; <a target='_blank' href='http://www.scs.carleton.ca/'>McGill University SoCS</a>, jeromew@cs.mcgill.ca, alexander.butyaev@mail.mcgill.ca.";
			// document.body.appendChild(staticBlock); 
            divElement.appendChild(staticBlock);*/
				
		</script>
    </body>
</html>
